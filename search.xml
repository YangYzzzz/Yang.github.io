<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>『深度学习』动手学深度学习——阅读笔记2</title>
      <link href="/post/52e1e34e.html"/>
      <url>/post/52e1e34e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『深度学习』动手学深度学习——阅读笔记2"><a href="#『深度学习』动手学深度学习——阅读笔记2" class="headerlink" title="『深度学习』动手学深度学习——阅读笔记2"></a>『深度学习』动手学深度学习——阅读笔记2</h1><p>❀<strong>目录</strong>❀</p><p><strong><em><a href="https://yangyzzzz.github.io/post/866b08a7.html">『深度学习』动手学深度学习——阅读笔记1</a></em></strong></p><p><strong><em><a href="https://yangyzzzz.github.io/post/52e1e34e.html">『深度学习』动手学深度学习——阅读笔记2</a></em></strong></p><h2 id="七-现代神经网络"><a href="#七-现代神经网络" class="headerlink" title="七. 现代神经网络"></a>七. 现代神经网络</h2><h3 id="5-BN（批量标准化）"><a href="#5-BN（批量标准化）" class="headerlink" title="5. BN（批量标准化）"></a>5. BN（批量标准化）</h3><p>对于典型的多层感知机或卷积神经网络。当我们训练时，中间层中的变量（例如，多层感知机中的仿射变换输出）可能具有更广的变化范围：不论是沿着从输入到输出的层，跨同一层中的单元，或是随着时间的推移，模型参数的随着训练更新变幻莫测。 批量规范化的发明者非正式地假设，这些变量分布中的这种偏移可能会阻碍网络的收敛。</p><p> $ \gamma $ 和 $ \beta $ 都是可学习参数，分别用作对标准化后的值进行缩放(scale)和平移(shift)，提高网络的表达能力(不加此参数的话，中间层的输出将被限制在标准正态分布下)。随着网络的训练，网络会学到最合适的 <script type="math/tex">\gamma</script> 和 <script type="math/tex">\beta</script>，最终中间层的输出将服从均值为 <script type="math/tex">\beta</script>，方差为 <script type="math/tex">\gamma^{2}</script> 的正态分布。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-04-02-50c0b208f5320af816b0ca6ef23e9ed2-image-20240121214253450-5bfb09.png" alt></p><p>对于卷积层而言，每个通道单独做批量规范化，每个通道都有自己的拉伸（scale）和偏移（shift）参数，这两个参数都是标量。</p><p>如何手写一个层（广播机制很重要，可以简化一些维度上的变化）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BatchNorm</span>(nn.Module):</span><br><span class="line">    <span class="comment"># num_features：完全连接层的输出数量或卷积层的输出通道数。</span></span><br><span class="line">    <span class="comment"># num_dims：2表示完全连接层，4表示卷积层</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_features, num_dims</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="keyword">if</span> num_dims == <span class="number">2</span>:</span><br><span class="line">            shape = (<span class="number">1</span>, num_features)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            shape = (<span class="number">1</span>, num_features, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 参与求梯度和迭代的拉伸和偏移参数，分别初始化成1和0</span></span><br><span class="line">        self.gamma = nn.Parameter(torch.ones(shape))</span><br><span class="line">        self.beta = nn.Parameter(torch.zeros(shape))</span><br><span class="line">        <span class="comment"># 非模型参数的变量初始化为0和1</span></span><br><span class="line">        self.moving_mean = torch.zeros(shape)</span><br><span class="line">        self.moving_var = torch.ones(shape)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="comment"># 如果X不在内存上，将moving_mean和moving_var</span></span><br><span class="line">        <span class="comment"># 复制到X所在显存上</span></span><br><span class="line">        <span class="keyword">if</span> self.moving_mean.device != X.device:</span><br><span class="line">            self.moving_mean = self.moving_mean.to(X.device)</span><br><span class="line">            self.moving_var = self.moving_var.to(X.device)</span><br><span class="line">        <span class="comment"># 保存更新过的moving_mean和moving_var</span></span><br><span class="line">        Y, self.moving_mean, self.moving_var = batch_norm(</span><br><span class="line">            X, self.gamma, self.beta, self.moving_mean,</span><br><span class="line">            self.moving_var, eps=<span class="number">1e-5</span>, momentum=<span class="number">0.9</span>)</span><br><span class="line">        <span class="keyword">return</span> Y</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">batch_norm</span>(<span class="params">X, gamma, beta, moving_mean, moving_var, eps, momentum</span>):</span><br><span class="line">    <span class="comment"># 通过is_grad_enabled来判断当前模式是训练模式还是预测模式</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> torch.is_grad_enabled():</span><br><span class="line">        <span class="comment"># 如果是在预测模式下，直接使用传入的移动平均所得的均值和方差</span></span><br><span class="line">        X_hat = (X - moving_mean) / torch.sqrt(moving_var + eps)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(X.shape) <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(X.shape) == <span class="number">2</span>:</span><br><span class="line">            <span class="comment"># 使用全连接层的情况，计算特征维上的均值和方差</span></span><br><span class="line">            mean = X.mean(dim=<span class="number">0</span>)</span><br><span class="line">            var = ((X - mean) ** <span class="number">2</span>).mean(dim=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 使用二维卷积层的情况，计算通道维上（axis=1）的均值和方差。</span></span><br><span class="line">            <span class="comment"># 这里我们需要保持X的形状以便后面可以做广播运算</span></span><br><span class="line">            mean = X.mean(dim=(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>), keepdim=<span class="literal">True</span>)</span><br><span class="line">            var = ((X - mean) ** <span class="number">2</span>).mean(dim=(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>), keepdim=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 训练模式下，用当前的均值和方差做标准化</span></span><br><span class="line">        X_hat = (X - mean) / torch.sqrt(var + eps)</span><br><span class="line">        <span class="comment"># 更新移动平均的均值和方差</span></span><br><span class="line">        moving_mean = momentum * moving_mean + (<span class="number">1.0</span> - momentum) * mean</span><br><span class="line">        moving_var = momentum * moving_var + (<span class="number">1.0</span> - momentum) * var</span><br><span class="line">    Y = gamma * X_hat + beta  <span class="comment"># 缩放和移位</span></span><br><span class="line">    <span class="keyword">return</span> Y, moving_mean.data, moving_var.data</span><br></pre></td></tr></table></figure><p>深度学习的某些本质（误：</p><blockquote><p><em>直观地说，批量规范化被认为可以使优化更加平滑。 然而，我们必须小心区分直觉和对我们观察到的现象的真实解释。 回想一下，我们甚至不知道简单的神经网络（多层感知机和传统的卷积神经网络）为什么如此有效。 即使在暂退法和权重衰减的情况下，它们仍然非常灵活，因此无法通过常规的学习理论泛化保证来解释它们是否能够泛化到看不见的数据。</em></p><p><em>在提出批量规范化的论文中，作者除了介绍了其应用，还解释了其原理：通过减少内部协变量偏移（internal covariate shift）。 据推测，作者所说的内部协变量转移类似于上述的投机直觉，即变量值的分布在训练过程中会发生变化。 然而，这种解释有两个问题： 1、这种偏移与严格定义的协变量偏移（covariate shift）非常不同，所以这个名字用词不当； 2、这种解释只提供了一种不明确的直觉，但留下了一个有待后续挖掘的问题：为什么这项技术如此有效？ 本书旨在传达实践者用来发展深层神经网络的直觉。 然而，重要的是将这些指导性直觉与既定的科学事实区分开来。 最终，当你掌握了这些方法，并开始撰写自己的研究论文时，你会希望清楚地区分技术和直觉。</em></p><p><em>随着批量规范化的普及，内部协变量偏移的解释反复出现在技术文献的辩论，特别是关于“如何展示机器学习研究”的更广泛的讨论中。 Ali Rahimi在接受2017年NeurIPS大会的“接受时间考验奖”（Test of Time Award）时发表了一篇令人难忘的演讲。他将“内部协变量转移”作为焦点，将现代深度学习的实践比作炼金术。 他对该示例进行了详细回顾 (<a href="https://zh-v2.d2l.ai/chapter_references/zreferences.html#id97">Lipton and Steinhardt, 2018</a>)，概述了机器学习中令人不安的趋势。 此外，一些作者对批量规范化的成功提出了另一种解释：在某些方面，批量规范化的表现出与原始论文 (<a href="https://zh-v2.d2l.ai/chapter_references/zreferences.html#id143">Santurkar et al., 2018</a>)中声称的行为是相反的。</em></p><p><em>然而，与机器学习文献中成千上万类似模糊的说法相比，内部协变量偏移没有更值得批评。 很可能，它作为这些辩论的焦点而产生共鸣，要归功于目标受众对它的广泛认可。 批量规范化已经被证明是一种不可或缺的方法。它适用于几乎所有图像分类器，并在学术界获得了数万引用。</em></p></blockquote><h3 id="6-Resnet"><a href="#6-Resnet" class="headerlink" title="6. Resnet"></a>6. Resnet</h3><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-07-59-6034c52553892433634e8aad5fba0cc1-image-20240121225229657-b3a1e5.png" alt="image-20240121225229657"></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-05-21-7cfc62d35922827f2129940de36a9cc9-image-20240121225250246-d7e394.png" alt></p><p>在每个Block的第一个残差块中，完成通道数翻倍与长宽减半的操作，在后续的残差块中，通道数和长宽均保持不变，第一个Block是例外。整个网络主体是多个Block，一个Block内部有多个残差块，一个残差块的内部如上图所示，分为两类。</p><ul><li><p>学习嵌套函数（nested function）是训练神经网络的理想情况。在深层神经网络中，学习另一层作为恒等映射（identity function）较容易（尽管这是一个极端情况）。</p></li><li><p>残差映射可以更容易地学习同一函数，例如将权重层中的参数近似为零。</p></li><li><p>利用残差块（residual blocks）可以训练出一个有效的深层神经网络：输入可以通过层间的残余连接更快地向前传播。</p></li></ul><h3 id="7-DenseNet"><a href="#7-DenseNet" class="headerlink" title="7. DenseNet"></a>7. DenseNet</h3><p>ResNet将f分解为两部分：一个简单的线性项和一个复杂的非线性项。 那么再向前拓展一步，如果我们想将f拓展成超过两部分的信息呢？ 一种方案便是DenseNet。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-05-36-50589242f127ecef4ec86323dfc286f0-image-20240121231914771-c4a4f4.png" alt></p><p>这样会导致通道数极多，每层稠密连接块后，需要过渡层来减少通道数并减半长与宽。</p><h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h3><p>将 <code>Conv - BN - ReLu</code> 优化为 <code>BN - ReLu - Conv - ... - Pool</code>。</p><p>长宽通过<code>Conv</code>的<code>stride / Pool</code> (Pool甚至都用的少，或者说几乎不放在堆叠块内使用)调整，通道通过 <code>Conv</code> 调。</p><p><code>Pool</code>用到的地方：</p><ol><li>最后的自适应全局池化</li><li>最开始的浅层特征降采样</li></ol><h2 id="八-循环网络"><a href="#八-循环网络" class="headerlink" title="八. 循环网络"></a>八. 循环网络</h2><p>简言之，如果说卷积神经网络可以有效地处理空间信息， 那么本章的<em>循环神经网络</em>（recurrent neural network，RNN）则可以更好地处理序列信息。 循环神经网络通过引入状态变量存储过去的信息和当前的输入，从而可以确定当前的输出。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-06-16-06cd69ae493fe6cce348b246d82e54a4-image-20240122210142958-d187bb.png" alt></p><h3 id="1-序列模型"><a href="#1-序列模型" class="headerlink" title="1. 序列模型"></a>1. 序列模型</h3><h4 id="1-1-策略"><a href="#1-1-策略" class="headerlink" title="1.1 策略"></a>1.1 策略</h4><p>两种策略，我们认为预测一个时间点上的数据，不需要以往全部时间点的数据，而只需要一个长度的时间跨度。</p><ol><li>自回归模型：同全连接层</li><li>隐式自回归模型：保留一些对过去观测的总结<script type="math/tex">h_t</script>, 并且随时间步更新<script type="math/tex">h_t</script>。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-06-30-ec1c58a4a36a69ee1abd26b46c382f64-image-20240122223709072-0a2b74.png" alt></p><p>事实上，如果基于一个马尔可夫模型， 我们还可以得到一个反向的条件概率分布。 然而，在许多情况下，数据存在一个自然的方向，即在时间上是前进的。 很明显，未来的事件不能影响过去。 因此，如果我们改变，可能会影响未来发生的事情，但不能反过来。 也就是说，如果我们改变，基于过去事件得到的分布不会改变。 因此，解释应该比解释更容易。</p><h4 id="1-2-k步预测"><a href="#1-2-k步预测" class="headerlink" title="1.2 k步预测"></a>1.2 k步预测</h4><p>模型预测下一个时间步的能力， 也就是<em>单步预测</em>（one-step-ahead prediction）。</p><p>k步预测即必须使用我们自己的预测（而不是原始数据）来进行多步预测，这一定会导致更大的偏差。</p><h3 id="2-有隐状态的循环神经网络"><a href="#2-有隐状态的循环神经网络" class="headerlink" title="2. 有隐状态的循环神经网络"></a>2. 有隐状态的循环神经网络</h3><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-06-46-4bfe3c5a0f0ea76e81115eff92d64c64-image-20240122224254933-3ad94e.png" alt></p><p>在循环神经网络（RNN）中，隐状态的概念是关键。假设我们有一个时间步长的输入序列 <script type="math/tex">X_t</script>，每个时间步对应于输入当前时间的样本。为了捕捉时间序列的依赖关系，循环神经网络会保留前一个时间步的 <strong>隐状态</strong> <script type="math/tex">\mathbf{H}_{t-1}</script>，并通过权重矩阵 <script type="math/tex">W_{hh}</script> 与当前输入 <script type="math/tex">\mathbf{X}_t</script> 结合，计算出当前时间步的隐状态 <script type="math/tex">\mathbf{H}_t</script>：</p><script type="math/tex; mode=display">\mathbf{H}_t = \phi(\mathbf{X}_t W_{zh} + \mathbf{H}_{t-1} W_{hh} + \mathbf{b}_h)</script><p>其中，<script type="math/tex">\phi</script> 是激活函数，通常为 <script type="math/tex">\tanh</script> 或 <script type="math/tex">\sigma</script>。</p><p>与传统神经网络不同，RNN 会通过这种递归的方式将前一时间步的隐状态与当前输入结合，从而捕捉序列中的依赖关系。这种机制使得网络能够记住之前时间步的信息，被称为 <strong>循环（recurrent）</strong>。因此，基于这种隐状态计算的网络称为 <strong>循环神经网络（Recurrent Neural Network, RNN）</strong>。</p><p>最后，输出层依赖于当前时间步的隐状态与权重矩阵 <script type="math/tex">W_{hq}</script> 计算得出：</p><script type="math/tex; mode=display">\mathbf{O}_t = \mathbf{H}_t W_{hq} + \mathbf{b}_q</script><p>RNN 的参数包括隐状态的权重 <script type="math/tex">W_{hh}</script>、输入的权重 <script type="math/tex">W_{zh}</script>、输出的权重 <script type="math/tex">W_{hq}</script>、以及对应的偏置项。尽管这些参数在每个时间步中保持不变，但 RNN 通过将隐状态递归地传递给下一个时间步，能够捕捉到时间序列中的长期依赖关系。</p><p>总结下核心思想：把每个时间点的特征打包，依次排队送入模型中，因此<strong>这个模型不需要处理时间维度，只需要每次更新内部隐藏状态即可</strong>，因此参数开销不会随着时间步的增加而增加，但运行时间开销会随着时间步的增加而增加。</p><h3 id="3-梯度裁剪策略"><a href="#3-梯度裁剪策略" class="headerlink" title="3. 梯度裁剪策略"></a>3. 梯度裁剪策略</h3><p>由于隐藏状态的持续更新，导致梯度反向传播时，在计算隐藏状态中间值的梯度时，由于复合函数求导，出现了矩阵大量连乘的情况，可能出现梯度消失或梯度爆炸。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-39-40-b0a0953442824c0da81476b52757869a-image-20240122225506645-a39f24.png" alt></p><p>解决方法有三：</p><ul><li><p>截断时间步</p></li><li><p>随机截断</p></li><li><p><strong>梯度裁剪</strong></p></li></ul><script type="math/tex; mode=display">\mathbf{g} \leftarrow \min\left(1, \frac{\theta}{\|\mathbf{g}\|}\right) \mathbf{g}.</script><p>其中梯度裁剪使用较多，其核心思想即将梯度<script type="math/tex">g</script>投影回给定半径的球来裁剪梯度，如此可以缓解梯度爆炸，却无法缓解梯度消失。<code>torch</code>在实现该方法时，还会随时储存中间变量的梯度，以便重复使用，避免冗余计算。</p><h2 id="九-现代循环神经网络"><a href="#九-现代循环神经网络" class="headerlink" title="九. 现代循环神经网络"></a>九. 现代循环神经网络</h2><p>上述循环神经网络存在问题：记忆遗忘，即早期记忆会随着迭代而消失，然而早期记忆可能很重要；一些记忆是无用的，不应该保留无用记忆等等。现代循环神经网络致力于解决这些问题。</p><h3 id="1-门控循环"><a href="#1-门控循环" class="headerlink" title="1.  门控循环"></a>1.  门控循环</h3><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F17-17-39-805944544d3a346870f57a70c6731228-image-20240122231153269-cbc983.png" alt="image-20240122231153269"></p><h4 id="1-1-重置门"><a href="#1-1-重置门" class="headerlink" title="1.1 重置门"></a>1.1 重置门</h4><p>重置门更新门皆有一组新的参数训练而成，仍然与时间步无关。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-08-01-a09a930a09978d160c7e5cb9a9629160-image-20240122231413600-76bc5e.png" alt="image-20240122231413600"></p><p>重置门控制来减少以往状态的影响，值越大代表越受过往影响，而值等于0时相当于抛弃了状态，与MLP无异。得到的结果成为候选隐状态。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-42-16-840431cdf62e7eb7df19e3c923a7bc3e-image-20240122231638979-2c4764.png" alt></p><h4 id="1-2-更新门"><a href="#1-2-更新门" class="headerlink" title="1.2 更新门"></a>1.2 更新门</h4><p>更新门控制候选隐状态和上一步隐状态的比例，即当前的隐状态在多大程度上来自旧的状态和新的候选状态。</p><p>例如，如果整个子序列的所有时间步的更新门都接近于1， 则无论序列的长度如何，在序列起始时间步的旧隐状态都将很容易保留并传递到序列结束。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-08-03-10c60a887fa36571c2299081405db289-image-20240122231837844-404302.png" alt="image-20240122231837844"></p><p>门控循环单元具有以下两个显著特征：</p><ul><li>重置门有助于捕获序列中的短期依赖关系；</li><li>更新门有助于捕获序列中的长期依赖关系。</li></ul><h3 id="2-LSTM"><a href="#2-LSTM" class="headerlink" title="2. LSTM"></a>2. LSTM</h3><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-42-33-5806f27bad54486e3e76514849e410cd-image-20240122233240457-cf2259.png" alt></p><p>与门控网络整体结构类似。</p><p><strong>输入门，遗忘门，输出门</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-08-03-96ec13c92a9fd136f47f5339d3cae217-image-20240122232248739-627452.png" alt="image-20240122232248739"></p><p>长短期记忆网络是典型的具有重要状态控制的隐变量自回归模型。 多年来已经提出了其许多变体，例如，多层、残差连接、不同类型的正则化。 然而，由于序列的长距离依赖性，训练长短期记忆网络 和其他序列模型（例如门控循环单元）的成本是相当高的。</p><ul><li>长短期记忆网络有三种类型的门：输入门、遗忘门和输出门。</li><li>长短期记忆网络的隐藏层输出包括“隐状态”和“记忆元”。只有隐状态会传递到输出层，而记忆元完全属于内部信息。</li><li>长短期记忆网络可以缓解梯度消失和梯度爆炸。</li></ul><h3 id="3-深层循环网络"><a href="#3-深层循环网络" class="headerlink" title="3. 深层循环网络"></a>3. 深层循环网络</h3><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-08-04-8fbe46ded7017f0c756bb017365a5312-image-20240122234552543-07bc29.png" alt="image-20240122234552543"></p><p>多个隐藏层叠加起来，可以产生更加灵活的机制，但是深度循环神经网络需要大量的调参（如学习率和修剪） 来确保合适的收敛，模型的初始化也需要谨慎。</p><h3 id="4-双向LSTM"><a href="#4-双向LSTM" class="headerlink" title="4. 双向LSTM"></a>4. 双向LSTM</h3><p>模型具备前瞻能力，更好的在当前时间步同时关注上文与下文。<em>双向循环神经网络</em>（bidirectional RNNs） 添加了反向传递信息的隐藏层，以便更灵活地处理此类信息。</p><p>双向的隐藏层各自独立，参数也独立互不影响，结果汇聚到输出层，在不考虑输出层的情况下，输出的神经元个数是隐藏层神经元个数乘以2。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-08-04-43a506b8955c096d0bc10d6481cf54f0-image-20240122235845817-a0944c.png" alt="image-20240122235845817"></p><p>双向层效果不好，使用在实践中非常少，并且仅仅应用于部分场合。 例如，填充缺失的单词、词元注释（例如，用于命名实体识别） 以及作为序列处理流水线中的一个步骤对序列进行编码（例如，用于机器翻译）。</p><h3 id="5-Encoder-Decoder"><a href="#5-Encoder-Decoder" class="headerlink" title="5. Encoder-Decoder"></a>5. Encoder-Decoder</h3><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-43-03-4efc50953147088f688daa8fe17362ea-image-20240123013934110-f8678c.png" alt></p><ul><li><p>根据“编码器-解码器”架构的设计， 我们可以使用两个循环神经网络来设计一个序列到序列学习的模型。</p></li><li><p>在实现编码器和解码器时，我们可以使用多层循环神经网络。</p></li><li><p>我们可以使用遮蔽来过滤不相关的计算，例如在计算损失时。</p></li><li><p>在”编码器－解码器”训练中，强制教学方法将原始输出序列（而非预测结果）输入解码器。</p></li><li><p>BLEU是一种常用的评估方法，它通过测量预测序列和标签序列之间的n元语法的匹配度来评估预测。</p></li></ul><h2 id="十-注意力机制"><a href="#十-注意力机制" class="headerlink" title="十. 注意力机制"></a>十. 注意力机制</h2><h3 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h3><p>“是否包含自主性提示”将注意力机制与全连接层或汇聚层区别开来。自主性提示被称为<em>查询</em>（query）。 给定任何查询，注意力机制通过<em>注意力汇聚</em>（attention pooling） 将选择引导至<em>感官输入</em>（sensory inputs，例如中间特征表示）。 在注意力机制中，这些感官输入被称为<em>值</em>（value）。 更通俗的解释，每个值都与一个<em>键</em>（key）配对， 这可以想象为感官输入的非自主提示，可以通过设计注意力汇聚的方式， 便于给定的查询（自主性提示）与键（非自主性提示）进行匹配， 这将引导得出最匹配的值（感官输入）。</p><p>精简而言：<strong>注意力机制即找到一种计算方式，按一定的权重将不同的值汇聚起来，权重是由当前查询和各个键之间的某种相似度得到的，而权重之和应为1</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-43-47-c1fa7a6deb9a6778d175f2dbaaabe9ac-image-20240124214443058-403900.png" alt></p><p>一个通用的计算公式如下，$x$为查村，$x_i$为键，$y_i$为对应的值</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-45-00-ff1d5c28df4e5e66d566342e19e200a8-image-20240124215128737-b4e79c.png" alt></p><h3 id="2-Nadaraya-Watson核回归"><a href="#2-Nadaraya-Watson核回归" class="headerlink" title="2. Nadaraya-Watson核回归"></a>2. Nadaraya-Watson核回归</h3><p><strong>无参数形式</strong></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-45-12-1decfe339ff0e4eb6515e0358a70dc44-image-20240124215001092-1f435f.png" alt></p><p>进一步化简为：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-08-06-c7bbc61038b0f3bad3019f7d99baf158-image-20240124215325488-63ee25.png" alt="image-20240124215325488"></p><p>没有可学习的参数，仅仅是当键和查询越接近时，分配到的注意力权重便会越多。</p><p><strong>有参数形式</strong>：只有一个可学习参数。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-45-28-798d3f6796c57310ebc48f56bf086992-image-20240124215615663-fd92a4.png" alt></p><h3 id="3-注意力评分函数"><a href="#3-注意力评分函数" class="headerlink" title="3. 注意力评分函数"></a>3. 注意力评分函数</h3><h4 id="3-1-掩蔽softmax"><a href="#3-1-掩蔽softmax" class="headerlink" title="3.1 掩蔽softmax"></a>3.1 掩蔽softmax</h4><p><code>seq2seq</code>的关键，<code>Transformer</code>解码器的核心机制。有些词元是填充词，在计算<code>softmax</code>时需要被忽略，为了仅将有意义的词元作为值来获取注意力汇聚， 可以指定一个有效序列长度（即有效词元的个数）， 以便在计算<code>softmax</code>时过滤掉超出指定范围的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@save</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">masked_softmax</span>(<span class="params">X, valid_lens</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;通过在最后一个轴上掩蔽元素来执行softmax操作&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># X:3D张量，valid_lens:1D或2D张量</span></span><br><span class="line">    <span class="keyword">if</span> valid_lens <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> nn.functional.softmax(X, dim=-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        shape = X.shape</span><br><span class="line">        <span class="keyword">if</span> valid_lens.dim() == <span class="number">1</span>:</span><br><span class="line">            valid_lens = torch.repeat_interleave(valid_lens, shape[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            valid_lens = valid_lens.reshape(-<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 最后一轴上被掩蔽的元素使用一个非常大的负值替换，从而其softmax输出为0</span></span><br><span class="line">        X = d2l.sequence_mask(X.reshape(-<span class="number">1</span>, shape[-<span class="number">1</span>]), valid_lens,</span><br><span class="line">                              value=-<span class="number">1e6</span>)</span><br><span class="line">        <span class="keyword">return</span> nn.functional.softmax(X.reshape(shape), dim=-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="3-2-加性自注意力"><a href="#3-2-加性自注意力" class="headerlink" title="3.2 加性自注意力"></a>3.2 加性自注意力</h4><p>当查询和键是不同长度时，可以使用加性注意力，然而不同长度可以通过线性层转换，一般不使用该方法。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-08-06-dad9a50459705c4a84106802d6a5afaa-image-20240124222753382-858433.png" alt="image-20240124222753382"></p><h4 id="3-3-缩放点积注意力"><a href="#3-3-缩放点积注意力" class="headerlink" title="3.3 缩放点积注意力"></a>3.3 缩放点积注意力</h4><p>最经典的算法，<code>Transformer</code>的基础。</p><p>缩放的原因：假设查询和键都满足零均值和单位方差，那么点积过后均值仍为0，而方差为d，因此我们需要除以根号d来规范方差仍为单位方差。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-46-23-b8e8852fb1ad78106e4ea8155e447ac9-image-20240124134156293-9d8724.png" alt></p><h4 id="3-4-多头注意力"><a href="#3-4-多头注意力" class="headerlink" title="3.4 多头注意力"></a>3.4 多头注意力</h4><p>独立学习得到的组不同的 <em>线性投影</em>（linear projections）来变换查询、键和值。 然后，这组变换后的查询、键和值将并行地送到注意力汇聚中。 最后，将这个注意力汇聚的输出拼接在一起， 并且通过另一个可以学习的线性投影进行变换， 以产生最终输出。</p><p>每个头可能会关注输入的不同部分，可以学习到输入不同角度的特征。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-46-50-63f188d249f85d73b20e3a37fcece2b3-image-20240124225830451-4adf0a.png" alt></p><p>我们通常设置各头的特征维度均相同，可以通过并行化计算的方法来简化编程和计算。比如将多个线性层矩阵合并计算，具体请参考<code>Transformer</code>的源码实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">predict_seq2seq</span>(<span class="params">net, src_sentence, src_vocab, tgt_vocab, num_steps,</span></span><br><span class="line"><span class="params">                    device, save_attention_weights=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;序列到序列模型的预测&quot;&quot;&quot;</span></span><br><span class="line">    src_tokens = src_vocab[src_sentence.lower().split(<span class="string">&#x27; &#x27;</span>)] + [</span><br><span class="line">        src_vocab[<span class="string">&#x27;&lt;eos&gt;&#x27;</span>]]</span><br><span class="line">    enc_valid_len = np.array([<span class="built_in">len</span>(src_tokens)], ctx=device) <span class="comment"># 计算实际长度！！</span></span><br><span class="line">    src_tokens = d2l.truncate_pad(src_tokens, num_steps, src_vocab[<span class="string">&#x27;&lt;pad&gt;&#x27;</span>])</span><br><span class="line">    <span class="comment"># 添加批量轴</span></span><br><span class="line">    enc_X = np.expand_dims(np.array(src_tokens, ctx=device), axis=<span class="number">0</span>)</span><br><span class="line">    enc_outputs = net.encoder(enc_X, enc_valid_len)</span><br><span class="line">    dec_state = net.decoder.init_state(enc_outputs, enc_valid_len) <span class="comment"># 在这步填充进解码器中，方便后续在attention中实现softmax掩码！！</span></span><br><span class="line">    <span class="comment"># 添加批量轴</span></span><br><span class="line">    dec_X = np.expand_dims(np.array([tgt_vocab[<span class="string">&#x27;&lt;bos&gt;&#x27;</span>]], ctx=device),</span><br><span class="line">                           axis=<span class="number">0</span>)</span><br><span class="line">    output_seq, attention_weight_seq = [], []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_steps):</span><br><span class="line">        Y, dec_state = net.decoder(dec_X, dec_state)</span><br><span class="line">        <span class="comment"># 我们使用具有预测最高可能性的词元，作为解码器在下一时间步的输入</span></span><br><span class="line">        dec_X = Y.argmax(axis=<span class="number">2</span>)</span><br><span class="line">        pred = dec_X.squeeze(axis=<span class="number">0</span>).astype(<span class="string">&#x27;int32&#x27;</span>).item()</span><br><span class="line">        <span class="comment"># 保存注意力权重（稍后讨论）</span></span><br><span class="line">        <span class="keyword">if</span> save_attention_weights:</span><br><span class="line">            attention_weight_seq.append(net.decoder.attention_weights)</span><br><span class="line">        <span class="comment"># 一旦序列结束词元被预测，输出序列的生成就完成了</span></span><br><span class="line">        <span class="keyword">if</span> pred == tgt_vocab[<span class="string">&#x27;&lt;eos&gt;&#x27;</span>]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        output_seq.append(pred)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(tgt_vocab.to_tokens(output_seq)), attention_weight_seq</span><br></pre></td></tr></table></figure><h4 id="3-5-自注意力，位置编码，Transformer"><a href="#3-5-自注意力，位置编码，Transformer" class="headerlink" title="3.5 自注意力，位置编码，Transformer"></a>3.5 自注意力，位置编码，Transformer</h4><p><strong>自注意力</strong>：</p><p>自注意力即kqv来自同一组输入，目前大多模型均使用自注意力机制。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-48-04-ea3a230f12114d986b9234a2d397b68e-image-20240124230750142-aac0cf.png" alt></p><p><strong>位置编码</strong></p><p>由于<code>Attention</code>中不考虑位置因素，我们需要手动加上位置编码，一种经典的三角函数编码如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-08-07-51220a44aff999b9b86628908506d70d-image-20240124230811609-2aac27.png" alt="image-20240124230811609"></p><p>此函数为在时间维度上呈周期性波动的三角函数，且随着列数越靠后，周期越大。目前通常使用这种编码及其变种，如旋转位置编码（RoPE），相对位置编码等。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-48-23-a2e3983b46f8faaa05425c734ff977ee-image-20240124230949219-1cf282.png" alt></p><p><strong>Transformer</strong>:</p><ul><li>Transformer是编码器－解码器架构的一个实践，尽管在实际情况中编码器或解码器可以单独使用。</li><li>在Transformer中，多头自注意力用于表示输入序列和输出序列，不过解码器必须通过掩蔽机制来保留自回归属性。</li><li>Transformer中的残差连接和层规范化是训练非常深度模型的重要工具。</li><li>Transformer模型中基于位置的前馈网络使用同一个多层感知机，作用是对所有序列位置的表示进行转换。</li></ul><h2 id="十一-优化算法"><a href="#十一-优化算法" class="headerlink" title="十一. 优化算法"></a>十一. 优化算法</h2><p>本部分涉及凸优化理论，笔者数学基础目前有限，待进一步学习后尝试继续完善此节。</p><blockquote><p>凸优化问题有助于分析算法的特点。 毕竟对大多数非凸问题来说，获得有意义的理论保证很难，但是直觉和洞察往往会延续。</p></blockquote><h3 id="1-优化算法基础"><a href="#1-优化算法基础" class="headerlink" title="1. 优化算法基础"></a>1. 优化算法基础</h3><p><strong>小批量随机梯度下降</strong>：小批量指每次<code>batch_size</code>个样本同时计算，可以更好的利用向量化特性加速运算，随机指在样本中随机取出，这样可以对梯度有异常扰动，更适合收敛到最优解。</p><ul><li>由于减少了深度学习框架的额外开销，使用更好的内存定位以及CPU和GPU上的缓存，向量化使代码更加高效。</li><li>随机梯度下降的“统计效率”与大批量一次处理数据的“计算效率”之间存在权衡。小批量随机梯度下降提供了两全其美的答案：计算和统计效率。</li><li>在小批量随机梯度下降中，我们处理通过训练数据的随机排列获得的批量数据（即每个观测值只处理一次，但按随机顺序），平均梯度的方法也减小了方差。</li><li>在训练期间降低学习率有助于训练。</li><li>一般来说，小批量随机梯度下降比随机梯度下降和梯度下降的速度快，收敛风险较小。</li></ul><h3 id="2-动量法"><a href="#2-动量法" class="headerlink" title="2. 动量法"></a>2. 动量法</h3><p>核心为引入动量机制，可类比数学中的滑动均值的概念。</p><h4 id="2-1-为何需要动量法"><a href="#2-1-为何需要动量法" class="headerlink" title="2.1 为何需要动量法"></a>2.1 为何需要动量法</h4><p>对于传统的梯度下降优化方法，存在显著的两难问题，例如两个自变量$x1, x2，y=x1+100*x2$，$x2$方向上的梯度比$x1$方向大得多，那么如果选择较小的学习率，则可以确保解不会在$x2$方向上发散，但要承受在$x1$方向的缓慢收敛；反之较大学习率，则在$x1$方向进展很快，但$x2$方向则会发散。</p><p>归根到底这是每个参数更新仅依赖于当前计算梯度和学习率导致的。</p><h4 id="2-2-泄露平均值"><a href="#2-2-泄露平均值" class="headerlink" title="2.2 泄露平均值"></a>2.2 泄露平均值</h4><p>上文说到，我们的随机梯度下降通过一小批样本取平均的方式减少了随机采样导致的方差。如果我们能够持续从方差减少中收益呢？我们采用<em>泄露平均值</em>（leaky average）取代梯度计算。这种方法也即动量法，公式如下。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-08-08-b5342fc838915dc1b1e0217964030efd-image-20240126131018433-4bc4e5.png" alt="image-20240126131018433"></p><p>我们动态维护每一个参数的过去平均梯度，并在参数更新时使用平均梯度而不是当前梯度进行更新，其中$\beta$为动量系数，一般取0.9/0.99，平均值初始化为$v_{0}=0$。</p><h3 id="3-AdaGrad-RMSProp"><a href="#3-AdaGrad-RMSProp" class="headerlink" title="3. AdaGrad/RMSProp"></a>3. AdaGrad/RMSProp</h3><p>此两种算法一脉相传。</p><h4 id="3-1-稀疏特征的处理"><a href="#3-1-稀疏特征的处理" class="headerlink" title="3.1 稀疏特征的处理"></a>3.1 稀疏特征的处理</h4><p>稀疏特征即偶尔会出现的特征，比如AI相关材料中“深度学习”（假设编码为0011）总是要比”英雄联盟“（假设编码为1100）出现的更加频繁，而假设只有一个全连接层（四个参数，$w1,w2,w3,w4$），那么只有“英雄联盟”出现时，$w1,w2$才会得到有意义的更新。这会导致常见特征的参数会迅速收敛到最佳值，而对于“英雄联盟”的参数缺少足够的观测以确定其最佳值。换句话说，学习率要么对常见特征而言降低太慢，要么对稀疏特征而言降低太快。</p><p>因此需要设计一种方案来根据一个特征的出现频率来动态调整学习率，出现频率越高，则学习率更低，出现频率更低，则学习率更高。理想中可以设计一个特定特征次数出现的计数器$s(i, t)$，使得$\eta_i = \frac{\eta_0}{\sqrt{s(i, t) + c}}$。</p><h4 id="3-2-AdaGrad"><a href="#3-2-AdaGrad" class="headerlink" title="3.2 AdaGrad"></a>3.2 AdaGrad</h4><p>AdaGrad（自适应梯度下降）算法即设计了一种粗略计数器$s(i, t)$来统计频率，首先何为特征的出现频率，这是我们无法准确统计的，在这里，将参数先前的梯度平方和视作“频率”，进而使用$s(i, t+1) = s(i, t) + \left(\partial_i f(\mathbf{x})\right)^2$来计算频率进而调整学习率。归根到底即为每个参数进行独立的学习率调整，随着训练的进行，频繁更新的参数学习率会越来越低，而更新较少的参数会保持相对较大的学习率。</p><script type="math/tex; mode=display">\begin{split}\begin{aligned}    \mathbf{g}_t & = \partial_{\mathbf{w}} l(y_t, f(\mathbf{x}_t, \mathbf{w})), \\    \mathbf{s}_t & = \mathbf{s}_{t-1} + \mathbf{g}_t^2, \\    \mathbf{w}_t & = \mathbf{w}_{t-1} - \frac{\eta}{\sqrt{\mathbf{s}_t + \epsilon}} \cdot \mathbf{g}_t.\end{aligned}\end{split}</script><p>但其具备较大的局限性，诸如学习率趋于0等巨大问题，因此后续有很多工作皆是基于此继续调整算法。</p><h4 id="3-3-RMSProp"><a href="#3-3-RMSProp" class="headerlink" title="3.3 RMSProp"></a>3.3 RMSProp</h4><p>AdaGrad算法的最大缺点在于其学习率按预定时间表$\mathcal{O}(t^{-\frac{1}{2}})$显著降低，即将梯度$g<em>t$的平方累加$\mathbf{s}_t = \mathbf{s}</em>{t-1} + \mathbf{g}<em>t^2$，如此没有约束力，$s_t$将持续增长，在算法收敛时呈线性递增。因此研究者借鉴了动量法中泄露平均值的思想，即令$\mathbf{s}_t \leftarrow \gamma \mathbf{s}</em>{t-1} + (1-\gamma) \mathbf{g}_t^2$，其余部分不变，便是RMSProp算法。在这种算法下，$s_t$权重为1的综合起历史时间步的梯度平方，使得参数学习率不会随时间收敛于0。</p><h3 id="4-Adam"><a href="#4-Adam" class="headerlink" title="4. Adam"></a>4. Adam</h3><p>Adam算法是集大成者，将所有技术汇总到一起，是<strong>最常用的优化算法</strong>。我们直接介绍其算法原理——使用指数加权移动平均值估算梯度的动量（动量法）和二次矩（RMSProp算法）。</p><script type="math/tex; mode=display">\begin{split}\begin{aligned}    \mathbf{v}_t & \leftarrow \beta_1 \mathbf{v}_{t-1} + (1 - \beta_1) \mathbf{g}_t, \\    \mathbf{s}_t & \leftarrow \beta_2 \mathbf{s}_{t-1} + (1 - \beta_2) \mathbf{g}_t^2.\end{aligned}\end{split}</script><p>一般$\beta<em>{1} = 0.9, beta</em>{2} = 0.999$，方差估计移动远慢于动量估计的移动。接着，由于对$v,s$初始化为0，初始阶段存在较大偏差，因此需要在初始阶段作偏差校正：</p><script type="math/tex; mode=display">\hat{\mathbf{v}}_t = \frac{\mathbf{v}_t}{1 - \beta_1^t} \text{ and } \hat{\mathbf{s}}_t = \frac{\mathbf{s}_t}{1 - \beta_2^t}</script><p>最后，更新梯度如下：</p><script type="math/tex; mode=display">\mathbf{g}_t' = \frac{\eta \hat{\mathbf{v}}_t}{\sqrt{\hat{\mathbf{s}}_t} + \epsilon} \\\mathbf{x}_t \leftarrow \mathbf{x}_{t-1} - \mathbf{g}_t'.</script><p><strong>设计思路</strong>：$s,v$状态存储了参数梯度动量和规模，并可以通过稍微不同的初始化和更新条件来修正偏项；其次，两种算法组合简单，并且明确的学习率$\eta$使我们能够控制步长来解决收敛问题。</p><h3 id="5-学习率调度器"><a href="#5-学习率调度器" class="headerlink" title="5. 学习率调度器"></a>5. 学习率调度器</h3><h4 id="5-1-调度策略"><a href="#5-1-调度策略" class="headerlink" title="5.1 调度策略"></a>5.1 调度策略</h4><p>首先我们具备明确的目标，即在训练过程中应逐步降低学习率，以便更好收敛或者说减小参数的固有方差。而降低学习率的策略分为多种，诸如线性调度策略，分段调度策略，余弦调度策略等。公式为余弦调度策略，较好理解，不过多赘述。</p><script type="math/tex; mode=display">\eta_t = \eta_T + \frac{\eta_0 - \eta_T}{2} \left(1 + \cos(\pi t/T)\right)</script><h4 id="5-2-预热策略"><a href="#5-2-预热策略" class="headerlink" title="5.2 预热策略"></a>5.2 预热策略</h4><p>在某些情况下，初始化参数不足以得到良好的解。因此我们需要一种预热策略，在训练的早期阶段逐步提高学习率至最大值（为简单起见普遍使用线性递增策略），目的是在训练早期尽可能跳出局部最优区域而广泛寻找最优解，随后使用学习率调度器冷却直至结束，预热策略可以适用于任何调度器，一个可能的学习率变化图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F17-56-07-3224ec3cd50762e6f2e5f29ed99eaf38-image-20241029175607600-9a3736.png" alt="image-20241029175607600"></p><h2 id="十二-计算性能"><a href="#十二-计算性能" class="headerlink" title="十二. 计算性能"></a>十二. 计算性能</h2><p>参考<code>OpenMLSYS</code>学习笔记，在此不过多赘述。</p><h2 id="十三-计算机视觉"><a href="#十三-计算机视觉" class="headerlink" title="十三. 计算机视觉"></a>十三. 计算机视觉</h2><h3 id="1-转置卷积-全卷积网络"><a href="#1-转置卷积-全卷积网络" class="headerlink" title="1. 转置卷积+全卷积网络"></a>1. 转置卷积+全卷积网络</h3><p><strong>转置卷积</strong>：用于图像的上采样，类似普通卷积的逆操作，步长和填充应用在输出上，而不是像普通卷积一样应用在输入上，从数学分析：</p><ul><li><strong>步长=1，填充=0</strong>：此时 $输出的长宽 =  输入长宽 + 卷积核长宽 - 1$</li></ul><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-51-17-d4ceecf2464f2aff4f3445b1cd264984-image-20240129151942395-6b5b70.png" alt></p><ul><li><strong>步长=n</strong>：一般来说，核长宽为$n$且步长为$n$，填充为0时，可以令输出的长宽是输入长宽的n倍。</li></ul><p>​    $输出长宽  =  步长 <em> ( 输入长宽 - 1 )  + 卷积核长宽  -  填充 </em> 2$</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-53-41-6dff5e43d52545955f962f19aa2a2b10-image-20240129153211348-66e586.png" alt></p><ul><li><p>与通过卷积核减少输入元素的常规卷积相反，转置卷积通过卷积核广播输入元素，从而产生形状大于输入的输出。</p></li><li><p>我们可以使用矩阵乘法来实现卷积。转置卷积层能够交换卷积层的正向传播函数和反向传播函数。</p></li></ul><p><strong>全卷积网络</strong>：用于实例分割。全卷积网络模型最基本的设计。全卷积网络先使用卷积神经网络抽取图像特征，然后通过卷积层将通道数变换为类别个数，最后通过转置卷积层将特征图的高和宽变换为输入图像的尺寸。 因此，模型输出与输入图像的高和宽相同，且最终输出通道包含了该空间位置像素的类别预测。</p><p>在图像处理中，有时需要将图像放大，即上采样，此时利用转置卷积实现双线性差值法。即初始化卷积核内部参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 双线性插值法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bilinear_kernel</span>(<span class="params">in_channels, out_channels, kernel_size</span>):</span><br><span class="line">    factor = (kernel_size + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> kernel_size % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">        center = factor - <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        center = factor - <span class="number">0.5</span></span><br><span class="line">    og = (torch.arange(kernel_size).reshape(-<span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">          torch.arange(kernel_size).reshape(<span class="number">1</span>, -<span class="number">1</span>))</span><br><span class="line">    filt = (<span class="number">1</span> - torch.<span class="built_in">abs</span>(og[<span class="number">0</span>] - center) / factor) * \</span><br><span class="line">           (<span class="number">1</span> - torch.<span class="built_in">abs</span>(og[<span class="number">1</span>] - center) / factor)</span><br><span class="line">    weight = torch.zeros((in_channels, out_channels,</span><br><span class="line">                          kernel_size, kernel_size))</span><br><span class="line">    weight[<span class="built_in">range</span>(in_channels), <span class="built_in">range</span>(out_channels), :, :] = filt</span><br><span class="line">    <span class="keyword">return</span> weight</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-54-02-fdd38518f6fdfb2dfb373ec3a511ade5-image-20240129154511955-d1b351.png" alt></p><h3 id="2-目标检测"><a href="#2-目标检测" class="headerlink" title="2. 目标检测"></a>2. 目标检测</h3><h4 id="2-1-标注位置"><a href="#2-1-标注位置" class="headerlink" title="2.1 标注位置"></a>2.1 标注位置</h4><p>四元组标记一个矩形框，可以使用左上右下的x,y或者中心的x,y和长宽，这两种表示来表达一个矩形框在图像内的位置。</p><h4 id="2-2-锚框法"><a href="#2-2-锚框法" class="headerlink" title="2.2 锚框法"></a>2.2 锚框法</h4><p>目标检测算法通常会在输入图像中采样大量的区域，然后判断这些区域中是否包含我们感兴趣的目标，并调整区域边界从而更准确地预测目标的<em>真实边界框</em>（ground-truth bounding box）。 不同的模型使用的区域采样方法可能不同。 这里我们介绍其中的一种方法：以每个像素为中心，生成多个缩放比和宽高比（aspect ratio）不同的边界框。 这些边界框被称为<em>锚框</em>（anchor box）</p><p>我们以每一个像素点为中心生成多个锚框，生成规则如下：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-54-50-422439da98559abbde175341a59a633c-image-20240123173535952-5a7078.png" alt></p><p>最后得到<code>图像高度,图像宽度,以同一像素为中心的锚框的数量,4</code>的四维张量。</p><h4 id="2-3-交并比（IoU）"><a href="#2-3-交并比（IoU）" class="headerlink" title="2.3 交并比（IoU）"></a>2.3 交并比（IoU）</h4><p>我们需要衡量真实边界框与锚框之间的相似度，使用杰卡德系数，等于交集大小除以他们并集的大小。</p><ul><li>我们以图像的每个像素为中心生成不同形状的锚框。</li><li>交并比（IoU）也被称为杰卡德系数，用于衡量两个边界框的相似性。它是相交面积与相并面积的比率。</li><li>在训练集中，我们需要给每个锚框两种类型的标签。一个是与锚框中目标检测的类别，另一个是锚框真实相对于边界框的偏移量。</li><li>预测期间可以使用非极大值抑制（NMS）来移除类似的预测边界框，从而简化输出。</li></ul><p>要解决的问题，每个像素点生成锚框，则锚框过多。</p><h2 id="十四-自然语言处理"><a href="#十四-自然语言处理" class="headerlink" title="十四. 自然语言处理"></a>十四. 自然语言处理</h2><h3 id="1-Word2Vec"><a href="#1-Word2Vec" class="headerlink" title="1.Word2Vec"></a>1.Word2Vec</h3><h4 id="1-1-跳元模型"><a href="#1-1-跳元模型" class="headerlink" title="1.1 跳元模型"></a>1.1 跳元模型</h4><p>目标：对于每一个词，学习到其中心词词向量和上下文词向量，最后该词的词向量一般由中心词词向量表示。</p><p>跳元模型假设一个词可以用来在文本序列中生成其周围的单词。假设上下文词是在给定中心词的情况下独立生成的（即条件独立性）。下述两公式相等：</p><script type="math/tex; mode=display">P(\textrm{"the"},\textrm{"man"},\textrm{"his"},\textrm{"son"}\mid\textrm{"loves"}) = P(\textrm{"the"}\mid\textrm{"loves"})\cdot P(\textrm{"man"}\mid\textrm{"loves"})\cdot P(\textrm{"his"}\mid\textrm{"loves"})\cdot P(\textrm{"son"}\mid\textrm{"loves"}).</script><p>对于其中每一项，即在中心词为loves的条件下生成the的条件概率，我们通过对向量点积的<code>softmax</code>操作来建模，$u$为上下文词向量，$v$为中心词向量。注意这是一种自定义的简化方法。</p><script type="math/tex; mode=display">P(w_o \mid w_c) = \frac{\text{exp}(\mathbf{u}_o^\top \mathbf{v}_c)}{ \sum_{i \in \mathcal{V}} \text{exp}(\mathbf{u}_i^\top \mathbf{v}_c)},</script><p>对于一个文本序列，定义总条件概率如下：</p><script type="math/tex; mode=display">\prod_{t=1}^{T} \prod_{-m \leq j \leq m,\ j \neq 0} P(w^{(t+j)} \mid w^{(t)}),</script><p>训练时最小化负对数（一种乘转加的转化思想），即：</p><script type="math/tex; mode=display">- \sum_{t=1}^{T} \sum_{-m \leq j \leq m,\ j \neq 0} \text{log}\, P(w^{(t+j)} \mid w^{(t)}).</script><h4 id="1-2-连续词袋（CBOW）模型"><a href="#1-2-连续词袋（CBOW）模型" class="headerlink" title="1.2 连续词袋（CBOW）模型"></a>1.2 连续词袋（CBOW）模型</h4><p>连续词袋模型类似于跳元模型，其假设中心词是基于其在文本序列中的周围上下文词生成的。由于连续词袋模型中存在多个上下文词，因此在计算条件概率时对这些上下文词向量进行平均，最后通常使用上下文词向量作为该词的词向量。</p><p>NLP后续章节部分并未完全学习完，这是作者当时沉迷CV导致的。即使站在如今的眼光来看大多词编码方式都已经淘汰，但了解梳理清NLP方向的发展脉络仍然有助于我们继续创新，故本篇读书报告有待后续继续整理完篇~</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 深度学习 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『信息论』信息论——学习笔记1</title>
      <link href="/post/a83ff101.html"/>
      <url>/post/a83ff101.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>课程来自上交计算机学院信息论课程。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>信息论在概率论，计算机科学，人工智能中有大量应用，诸如：决策树中基于最大信息增益进行决策，最常用的交叉熵损失函数，编码器-解码器的概念，Viterbi Algorithm算法。同时信息论与密码学，控制论，通信原理等均密切相连，可以称其为工科里基础中的基础学科，因此系统学习这门课是有必要的。</p><p>通信要解决的根本问题是信道噪声问题，即通信的基本问题是在一点上精确地或近似地再现在另一点上选择的消息。</p><blockquote><p>The foudamental problem of communication is that of reproducing at one point either exactly or approximately a message selected at another point.</p></blockquote><h2 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h2><p>熵：描述随机变量的不确定性</p><script type="math/tex; mode=display">H(X)=-\sum{p(x)logp(x)}</script><p>概率论复习，样本空间$\mathbf{X}$为实验所有可能结果的集合，随机变量$X$是定义在样本空间上的一个函数，在一个样本空间内，允许定义多个随机变量。</p><p>其中，$x$为样本空间的所有可能取值，$X$为随机变量，$p(x)$为概率密度函数</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 信息论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『机器学习系统』OpenMLSYS——阅读笔记2</title>
      <link href="/post/b2db68a7.html"/>
      <url>/post/b2db68a7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="『机器学习系统』OpenMLSYS——阅读笔记2"><a href="#『机器学习系统』OpenMLSYS——阅读笔记2" class="headerlink" title="『机器学习系统』OpenMLSYS——阅读笔记2"></a>『机器学习系统』OpenMLSYS——阅读笔记2</h2><p>❀<strong>目录</strong>❀</p><p><strong><em><a href="https://yangyzzzz.github.io/post/d00a62b9.html">『机器学习系统』OpenMLSYS——阅读笔记1</a></em></strong></p><p><strong><em><a href="https://yangyzzzz.github.io/post/b2db68a7.html">『机器学习系统』OpenMLSYS——阅读笔记2</a></em></strong></p><h2 id="分布式训练"><a href="#分布式训练" class="headerlink" title="分布式训练"></a>分布式训练</h2><p>分布式训练系统主要解决单节点的算例和内存不足的问题。</p><h3 id="并行方法"><a href="#并行方法" class="headerlink" title="并行方法"></a>并行方法</h3><ol><li>数据并行：一个批次内N个数据，使用M个并行设备训练，每个设备需要拷贝一份网络参数，各自计算出梯度后，由集合通信的AllReduce进行梯度聚合</li><li>模型并行：分为算子内并行（一个算子分配到不同的设备上），算子间并行（不同算子分配到不同的设备上）</li><li>混合并行：数据并行+模型并行</li></ol><h3 id="流水线并行"><a href="#流水线并行" class="headerlink" title="流水线并行"></a>流水线并行</h3><ol><li>模型并行的劣势：一个设备在计算时另一个设备会空闲</li><li>流水线改进：将一个小批次进一步拆分为多个<strong>微批次</strong>，如下图，提高并行训练效率。核心：微批次大小<ol><li>过大：每个微批次样本过少，无法充分利用硬件加速</li><li>过小：更长时间的流水线气泡<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240803192034235.png" alt></li></ol></li></ol><h3 id="机器学习的集群架构"><a href="#机器学习的集群架构" class="headerlink" title="机器学习的集群架构"></a>机器学习的集群架构</h3><ol><li><p>计算集群：机器学习模型分布训练的整套设备。多台服务器放置在一个机柜内，由架顶交换机管理，多台架顶交换机间可增加骨干交换机。即通常由树状的拓扑结构构建，叶子节点是服务器，上层是交换机。<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240803192828614.png" alt></p></li><li><p>核心设计需求：跨机柜通信会产生网络带宽超额认购，应将网络通信限制在机柜内</p></li><li><p>训练流程（共有N个模型副本分布在N个设备）：</p><ol><li>各自计算梯度后，N-1个模型副本的梯度同步到主模型中</li><li>主模型计算平均梯度</li><li>将平均梯度广播到其余N-1个副本，避免偏离主模型参数</li></ol></li><li><p>服务器间的网络通信：以前使用以太网，现在使用InfiniBand链路</p></li><li><p>服务器内部的网络通信：异构网络，如上图，两个CPU间通过QuickPathInterconnect（QPI）进行通信，硬件加速器和CPU通过PCle总线通信，但是PCIe带宽较小，往往硬件加速器间实现高速互连，以绕过PCIe</p></li></ol><h3 id="✳集合通信✳"><a href="#✳集合通信✳" class="headerlink" title="✳集合通信✳"></a>✳集合通信✳</h3><ul><li><p>通信模型：参考计算机网络<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240803194957280.png" alt></p></li><li><p><strong>各类通信算子</strong>：</p><ul><li><p><strong>Broadcast</strong>：从编号为$i$的设备发送长度为$l$字节的消息给剩余的$p-1$个设备。</p><ul><li>实现：采用分治的思想，<strong>1传2，2传4…</strong>，使用多设备并行广播，时间复杂度为$(a+b\ast l)\ast \log p$。</li></ul></li><li><p><strong>Reduce</strong>：将不同设备上的计算结果聚合，通常由全部设备共同发起，最终聚合结果存在编号为i的设备上，聚合函数包括加和，乘积，最大值和最小值。</p><ul><li><p>实现：同样可采用分治的思想，即把1到$p/2-1$的聚合结果存到设备1，$p/2$到$p$的聚合结果存到$p/2$，最后把$p/2$的结果发送到1，再聚合，得到最终结果。时间复杂度为$(a+b\ast l)\ast \log p$。</p></li><li><p>分析：这种算法的复杂度并非最低，但是若所有数据同步全部涌入$i$号设备，会导致严重的带宽不足而产生网络拥塞</p></li></ul></li><li><p><strong>AllReduce</strong>：Reduce + Broadcast</p><ul><li>基于AllReduce的梯度平均算法：将网络和算力开销均摊给全部节点。</li><li><p>具体方案：$M$个设备，模型$N$个参数，将$N$个参数分$M$个区，每个区$N/M$个参数，即每个设备作为一个区的主设备，将该区的参数聚合并广播。</p></li><li><p><strong>网络优化：</strong> 全部设备都同时在接收和发送数据，利用起了每个设备的入口（Ingress）和出口（Egress）带宽。</p><p><strong>算力优化：</strong> 全部设备的处理器都参与了梯度相加的计算。因此在AllReduce算法的过程中，可利用的处理器是$M \ast P$，其中M是节点数量，P是单个设备的处理器数量，从而让系统实现计算上的可扩展性。</p><p><strong>负载均衡：</strong> 由于数据分区是平均划分的，因此每次设备分摊到的通信和计算开销是相等的。</p></li></ul></li><li><p><strong>Gather</strong>：将全部设备的数据全部收集到编号为$i$的设备上。</p><ul><li>实现：将其看作一种特殊的Reduce函数，即拼接。采用分治的思想并行收集，但由于数据长度随收集阶段而指数级上升，因此复杂度为$a\ast \log p+(p-1)\ast b\ast l$<br><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240803200708467.png" alt></li></ul></li><li><p><strong>AllGather</strong>：Gather+Boardcast，可使用超立方体算法优化</p></li><li><p><strong>Scatter</strong>：Gather的逆运算，把一个存在于编号为i的设备上，长度为$p\ast l$的链式数据分散到每个设备上。</p><ul><li>实现：分治，数据平均切分为两个子链分散到不同设备中，子问题递归，时间复杂度同Gather。</li></ul></li></ul></li><li><p>集合通信优化技术（模型并行）：</p><ul><li><p>几个概念：节点（服务器），模型（包含多个模型副本），模型副本（包含多个切片）</p></li><li><p>单一节点（服务器）的参数存储：已知节点内部的通信比节点之间的通信更高效，模型本身前向和反向计算时需要在不同切片之间进行的通信远小于不同模型副本梯度平均的通信量。</p><p><em>结论（书上好像有问题）</em>：将单一模型的全部切片存储到同一节点内部。</p></li><li><p>基于AllGather算子的前向计算**：对所有包含模型参数的加速器进行一次AllGather计算。（大致算法）对于某一层，接收上一层的输出，抛弃其余层传过来的数据，用于计算当前层的输出，并传给其余所有层。</p></li><li><p>基于ReduceScatter算子的梯度平均<strong>：在</strong>反向计算<strong>时我们只需要后一层的参数来计算本层的激活值和梯度，只需要再次使用AllGather来完成每个加速器上的梯度计算。在</strong>梯度更新**时，由于每个加速器只需要对应的一部分参数的梯度，因此无需使用AllReduce算子，而可以使用ReduceScatter算子直接把相应的梯度存到编号为i的加速器上。</p></li></ul></li><li><p>集合通信技术（数据并行）：机器学习系统提供两个级别的抽象</p><ul><li><p>与硬件耦合，调用集合通信算子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于pygloo底层接口实现AllReduce算法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ray.remote(<span class="params">num_cpus=<span class="number">1</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gloo_allreduce</span>(<span class="params">rank, world_size</span>):</span><br><span class="line">    context = pygloo.rendezvous.Context(rank, world_size)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Sendbuf = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]], dtype=np.float32)</span><br><span class="line">    recvbuf = np.zeros_like(Sendbuf, dtype=np.float32)</span><br><span class="line">    Sendptr = Sendbuf.ctypes.data</span><br><span class="line">    recvptr = recvbuf.ctypes.data</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 标明发送者和接收者并直接调用AllReduce算法</span></span><br><span class="line">    pygloo.allreduce(context, Sendptr, recvptr,</span><br><span class="line">                    Sendbuf.size, pygloo.glooDataType_t.glooFloat32,</span><br><span class="line">                    pygloo.ReduceOp.SUM, pygloo.allreduceAlgorithm.RING)</span><br><span class="line">    <span class="comment"># @ray.remote(num_cpus=1)：表示这个函数将作为一个 Ray 任务在分布式环境中运行,并且需要分配 1 个 CPU 资源</span></span><br></pre></td></tr></table></figure></li><li><p>偏向神经网络实现，打包到更上层（如pytorch用的<code>Data Parallel</code>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ddp_model = torch.nn.parallel.DistributedDataParallel(model, device_ids=[rank])</span><br></pre></td></tr></table></figure></li></ul></li><li><p>集合通信技术（混合并行）：华为的MindSpore框架（作者收钱了），用户可自行定义各个算子的切分方法，同时框架会为算子间自动插入适当的集合通信算子，如下图所示：算子1数据并行后$Y<em>{i}$分布在不同的设备上，而下一个算子是模型并行，需要$Y$的全量数据，此时需要插入AllGather算子将$Y</em>{i}$收集。<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240804002627213.png" alt></p></li></ul><h3 id="参数服务器系统"><a href="#参数服务器系统" class="headerlink" title="参数服务器系统"></a>参数服务器系统</h3><p>一种与集合通信并列的分布式系统的实现。</p><ul><li><p>系统架构：服务器有两种角色，参数服务器与训练服务器</p><ul><li><p>参数服务器：提供内存资源与通信资源</p></li><li><p>训练服务器：提供计算资源</p></li><li><p>流程：模型参数分配到不同的参数服务器上负责同步，训练服务器拥有完整模型，用本地数据集训练出梯度后推送到各自的参数服务器，参数服务器等待训练服务器都完成梯度推送后，更新参数，后通知训练服务器来拉取最新的参数，开始下一轮迭代。</p></li></ul></li><li><p>异步训练：解决某些节点的“落后者现象”，即正常的AllReduce很可能被个别性能差的节点显著影响整体的训练速度。使用参数服务器，有两种解决办法</p><ul><li><p>参数服务器等到一定的训练服务器的梯度推送后，便更新参数，不用等落后者</p></li><li><p>异步训练：每有训练服务器推送梯度后，立刻用于更新参数，并通知训练服务器立刻拉拉去最新参数。这会导致不同的训练服务器中最新参数不同步，<em>牺牲精度但是显著提高效率</em>。</p></li></ul></li><li><p>数据副本：解决参数服务器故障问题，一份参数在多个机器上拥有副本，区分主副本和从副本，主副本更新后向所有从副本同步。<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240804003254534.png" alt></p></li></ul><h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><ul><li><p>损失函数：最小化<strong>策略损失</strong>和<strong>价值损失</strong>体现了强化学习的两个核心目标:</p><ul><li><p>学习一个最优的行为策略来最大化累积奖励;</p></li><li><p>学习一个准确的价值函数来评估状态或动作的好坏。</p></li></ul></li><li><p><strong>核心组件</strong>：价值网络（函数），策略网络，环境（根据当前状态与动作，转移到下一个状态）<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F11-14-05-56479467e7c982c0cc3438bb9bbedcef-image-20240731192133204-9866a8.png" alt="image-20240731192133204"></p></li></ul><p>该电子书籍仅重点阅读了第一和第二大部分，第三部分拓展篇未能抽出时间阅读，故本读书笔记仅记录至此，未来有时间会把后续内容补充完整。</p><p>特别感谢北京大学董豪老师，虽然您没有回复我的邮件，但正是看到您的招生信息才偶然让我发现了这本小众宝藏好书~😀</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 机器学习系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『机器学习系统』OpenMLSYS——阅读笔记1</title>
      <link href="/post/d00a62b9.html"/>
      <url>/post/d00a62b9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『机器学习系统』OpenMLSYS——阅读笔记1"><a href="#『机器学习系统』OpenMLSYS——阅读笔记1" class="headerlink" title="『机器学习系统』OpenMLSYS——阅读笔记1"></a>『机器学习系统』OpenMLSYS——阅读笔记1</h1><p>❀<strong>目录</strong>❀</p><p><strong><em><a href="https://yangyzzzz.github.io/post/d00a62b9.html">『机器学习系统』OpenMLSYS——阅读笔记1</a></em></strong></p><p><strong><em><a href="https://yangyzzzz.github.io/post/b2db68a7.html">『机器学习系统』OpenMLSYS——阅读笔记2</a></em></strong></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong><em><a href="https://openmlsys.github.io/">OpenMLSYS电子书链接</a></em></strong>。本书阅读于24年暑假，每天上午一章节，随阅读随记录笔记，记录的不详尽或复制粘贴原文之处敬请谅解。By the way，当时正处于没有一个offer的痛苦阶段，已经考虑转行做深度学习系统，进而阅读了这本书。</p><p>平心而论，该书电子版用的和《动手学深度学习》一样的模板，但内容质量差距较大（勿喷）。不过MLSYS近年来才起步并仍在发展，作者愿意总结知识并著作已经不可多得，这仍然是我最推荐入门机器学习系统的好书~</p><h2 id="AI编译器与前端技术"><a href="#AI编译器与前端技术" class="headerlink" title="AI编译器与前端技术"></a>AI编译器与前端技术</h2><h3 id="计算机求导的方法"><a href="#计算机求导的方法" class="headerlink" title="计算机求导的方法"></a>计算机求导的方法</h3><ol><li><p>手动微分：人工计算表达式</p></li><li><p>数值微分：无穷小逼近，会产生<strong>截断误差</strong>；浮点数运算，会产生<strong>舍入误差</strong></p></li><li><p>符号微分：不复用产生的变换结果，存在表达式膨胀问题</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F10-20-32-68303d27e6f9d889d64653877053772f-image-20240726135822824-280f81.png" alt="image-20240726135822824"></p></li><li><p>自动微分（机器学习框架使用）：将计算机程序中的运算操作分解为一个有限的基本操作集合，且集合中基本操作的求导规则均为已知。在完成每一个基本操作的求导后，使用链式法则将结果组合得到整体程序的求导结果。我们将着重介绍自动微分。</p><ul><li>前向自动微分：构建计算图，边前向传播，边时刻计算中间变量对输入的导数。最后得到，<strong>每个输出对单个输入的导数</strong>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F10-20-32-3aeeda16c7e1a269211588497471e914-image-20240726140947894-07507d.png" alt="image-20240726140947894"></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F10-45-06-db941c885728ce0bf2f801f768017cb0-image-20240726140957081-4f35b1.png" alt></p><p>​        当我们对一个函数求导，想要得到的是该函数的任意输出对任意输入的偏导集合，因此经过多个上述步骤，得到一个<strong>雅可比矩阵</strong>。</p><ul><li><p>反向自动微分：先前向传播，记录中间变量与依赖关系，再反向传播计算最终输出y对各个中间变量的导数。最后得到，<strong>单个输出对所有输入的导数</strong>。</p><p>这种模式是机器学习系统中常见的，因此通常采用反向自动微分。反向涉及到对某变量梯度的累加，如下图的V0，在V3计算中依赖，在V2计算中依赖，因此第二个$\bar{V_0}$的计算需要与第一个$\bar{V_0}$的计算相加！</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F10-46-26-a9cbff0d723e2efec8b9c96d7c4ee38f-image-20240726195221932-7c41ef.png" alt></p><h3 id="自动微分的方法——拆成多个原子操作："><a href="#自动微分的方法——拆成多个原子操作：" class="headerlink" title="自动微分的方法——拆成多个原子操作："></a>自动微分的方法——拆成多个原子操作：</h3><ol><li>基本表达式法</li><li>操作符重载（Pytorch）</li><li>代码变换法ST（MindSpore）</li></ol><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F10-46-52-8bf114549fe0898c146f456fce8e2074-image-20240726201849200-836b19.png" alt></p></li></ol><h3 id="静态分析与类型系统"><a href="#静态分析与类型系统" class="headerlink" title="静态分析与类型系统"></a>静态分析与类型系统</h3><p><strong>类型系统</strong>：类型系统用于定义不同的类型，指定类型的操作和类型之间的相互作用，其功能为：正确性，安全性，优化，抽象。python是动态强类型，但由于其解释执行的方式，运行速度往往较慢。若想要生成运行高效的后端代码，后端框架需要优化友好的静态强类型中间表示。需要将Python前端表示转换成等价的静态强类型中间表示，以此给用户同时带来高效的开发效率和运行效率，例如Hindley–Milner（HM）类型系统。</p><p><strong>静态分析</strong>：对中间表示进行处理分析，并且生成一个静态强类型的中间表示，用于后续的编译优化、自动并行以及自动微分等。</p><h2 id="编译器后端与运行时"><a href="#编译器后端与运行时" class="headerlink" title="编译器后端与运行时"></a>编译器后端与运行时</h2><h3 id="计算图优化"><a href="#计算图优化" class="headerlink" title="计算图优化"></a>计算图优化</h3><ul><li><p>通用硬件优化：与特定硬件类型无关，核心是子图的等价变换，在计算图中匹配特定的子图结构，找到目标结构后，通过等价替换方式，将其替换为更优的子图结构。</p><ul><li><p>目的：计算更密集，减少低效内存访问</p></li><li><p>计算密集型算子，访存密集型算子。通常相伴出现，可以合并。</p></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F10-48-30-5638fb9eda0b63011cf7fbddca9efd9b-image-20240801113909677-98f8b2.png" alt></p><ul><li><p>自动算子生成技术：算子拆解，算子聚合，算子重建。</p></li><li><p>特定硬件优化：往往某些硬件不支持一些算子，或有一些额外性质，比如硬件指令的限制，数据排布格式的限制等。</p></li></ul><h3 id="算子选择"><a href="#算子选择" class="headerlink" title="算子选择"></a>算子选择</h3><p>为计算图上的每个算子分配在设备上执行的算子，往往计算图的每一个节点都有一组设备算子与之对应</p><ul><li><p>获取算子信息：数据排布格式 + 计算精度</p><ul><li><p><strong>数据排布格式</strong>：矩阵乘法的第二个矩阵，最好是按列优先存储，如此可通过访问连续内存的方式加快数据访问速度。计算机对张量的存储方式为展平成一维！</p><ol><li><p>默认的数据排布格式（图像）：NCHW, NHWC</p></li><li><p>问题：访问元素时内存不连续，而输入的数据往往大于计算部件一次计算所容纳的最大范围，因此需要切片分批计算，增大访存开销。</p></li><li><p>解决：块布局格式，硬件加速指令</p></li></ol></li><li><p><strong>数据精度</strong>：单精度(float32)，半精度(float16)</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F10-20-34-cb181fb91721b0f93346b7af8b292090-image-20240801120028238-894deb.png" alt="image-20240801120028238"></p></li><li><p>算子信息库：一个硬件上支持的所有算子的集合定义为该硬件的算子信息库。算子选择过程就是从算子信息库中选择最合适算子的过程。</p></li><li><p>选择过程：选择硬件设备，根据排布格式与数据类型选择<strong>合适</strong>的算子。由于不同硬件支持的算子不一，存在算子选择的算子与用户预期的类型不一致的现象，此时会降精度或其他处理。</p></li></ul><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>显存称为Device内存，CPU内存称为Host内存。CPU和硬件加速器的控制器无法直接访问对方的内存。该步骤即为输入输出分配内存地址。</p><ul><li><p><strong>为输入，权重，输出分配内存地址</strong>：输入往往是上一算子的输出，因此可将上一算子的输出地址<strong>共享</strong>到该输入，可避免冗余拷贝与空间占用。因此，需要分配的内存有三种类型：整张图的输入，算子权重，算子的输出</p></li><li><p>内存的管理方式：</p><ul><li><p>内存池：申请一定数量的内存块留作备用，当程序有内存申请需求时，直接从内存池中的内存块中申请，当程序释放该内存块时，内存池会进行回收并用作后续程序内存申请时使用。</p></li><li><p>双游标法分配：一侧分配生命周期较长的权重张量，一侧分配生命周期较短的算子输出张量。通过这种方式，只需要从设备上申请一次足够大的内存，后续算子的内存分配都是通过指针偏移进行分配，减少了直接从设备申请内存的耗时。</p></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F10-51-18-e44a1effada54cc1db56a98e1bfb4c56-image-20240801121904965-c3fa72.png" alt></p><ul><li>内存复用：<ul><li>定义：已使用结束的算子输出的内存可用于后续算子输出的内存分配。</li><li>内存生命周期图：横坐标生命周期，纵坐标所占内存区域。如何分配更多矩形！是NP完全问题！</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F10-53-48-cc7e364e466cfe58515734817002913e-image-20240801122418787-1e6cf0.png" alt></p><ul><li>内存分配优化手段：内存融合（对一些特殊的算子，分配连续的设备地址）；In-Place算子（Pytorch有，一些Bug产生的万恶之源），即原地操作，无需新开地址拷贝一份张量操作，而是直接对原内存地址相应位置操作。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F10-54-07-f6888e526f4a8a882e4a9910a272ffb8-image-20240801123205364-069366.png" alt></p><h3 id="计算调度与执行"><a href="#计算调度与执行" class="headerlink" title="计算调度与执行"></a>计算调度与执行</h3><ul><li><p>单算子调度：运行时算子被逐个执行，无法上下文优化，无法并行计算，不采用！</p></li><li><p>计算图调度：一张计算图可以由运行在不同设备上的算子组成异构计算图</p><ul><li><p>CPU算子：C++语言编写的在Host上执行的算子，性能取决于是否能够充分利用CPU多核心的计算能力。</p></li><li><p>GPU算子：将GPU Kernel诸葛下发到GPU设备上并行加速，AI芯片上具备大量的并行执行单元。</p></li><li><p>NPU算子：支持将部分或整个计算图下沉到芯片中完成计算，计算过程中不与Host发生交互，因此具备较高的计算性能。</p></li><li><p>Python算子：Python解释器解释执行，与CPU算子类似</p></li><li>并发执行：下图明显可并发执行，但需注意一些并发执行会引起副作用<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F10-20-35-df8012f76cf8537660a73236bc676027-image-20240801124528978-805dec.png" alt="image-20240801124528978"></li></ul></li><li><p>交互式执行：框架的运行时根据计算图中算子的依赖关系，按照某种执行序（例如广度优先序）逐个将算子下发到硬件上执行</p><ul><li><p>非异构计算图的执行方式：</p><ul><li><p>串行执行：广度优先</p></li><li><p>并行执行：按依赖关系展开<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F10-56-54-b362232d298accd9bb84cc5700bb7d4e-image-20240801130640291-c3bb45.png" alt></p></li></ul></li><li><p>异构计算图的执行方式：首先将异构计算图切分为多个非异构计算图，进而引申两种执行方式。（通常默认是并行执行）</p><ul><li><p><strong>子图拆分执行</strong>：将切分后的子图分开执行，上一个子图的输出会传输给下一个子图的输入，并且需要将输入数据拷贝到本图device上。<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F10-59-14-3e60cb70de0cf4462b3656eb2068fb6a-image-20240801131109552-055b41.png" alt></p></li><li><p>子图合并执行：将多个子图合并，交接处插入<strong>设备拷贝算子</strong>，以实现不同设备算子数据传输，将整张图形成一个大的整图执行。<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F11-00-17-9a3e5ae7d8bf313226c6019b51fae2aa-image-20240801131118929-b7e8be.png" alt></p></li><li><p>下沉式执行：将整个或部分计算图一次性调度到芯片上以完成全量数据的计算，避免了在计算过程中主机侧和设备侧的交互，因此可以获得更好的整体计算性能。</p></li></ul></li></ul></li></ul><h2 id="硬件加速器"><a href="#硬件加速器" class="headerlink" title="硬件加速器"></a>硬件加速器</h2><ul><li><p>硬件加速器的结构：存储单元（片上缓存）（寄存器文件+共享内存+L1L2缓存）+计算密集型计算单元（标量+向量+张量计算单元）</p></li><li><p>加速器编程：编程接口调用，算子编译器优化</p><ul><li><p>编程接口使能加速器</p><ul><li>算子库层级</li><li>编程原语层级</li><li>指令层级</li></ul></li><li><p>算子编译器使能加速器</p></li><li><p>算子长尾问题：指在深度学习模型中,尽管大多数计算由常见的、常规形式的算子(如卷积、矩阵乘法等)完成,但仍然存在大量种类繁多的非常规算子。这些非常规算子的出现频率相对较低,但它们的总数和种类却在不断增加。</p></li></ul></li></ul><p><strong>矩阵乘法加速的实践</strong>：</p><ul><li><p>最基本：每个输出元素由一个线程计算，共M*N个线程</p></li><li><p><strong>计算强度（计算指令数量/访存指令数量）优化</strong>：</p><ul><li><p>如果在K次循环的内积计算中一次读取矩阵A中的m个元素和矩阵B中的n个元素，那么访存指令为m+n条，而计算指令为2mn条，所以计算强度为$\frac{2mn}{m+n}$，因此可以很容易发现提高和会带来计算强度的提升。</p></li><li><p>实现：使用<strong>宽指令</strong>，一个128位的宽指令一次可以读取4个float数，因此现在可以将C划分为4*4的矩形块，每个线程处理一个矩形块的运算。进一步，一个线程可以处理多个矩形块的运算。</p></li><li><p>缺点：并行度大幅降低<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F11-02-18-5ff2f109fdf56756940d96921387f1a5-image-20240728221919975-d8e0e0.png" alt><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F11-02-59-5ea5eb6b7724a7e5e2d9b3669c34947f-image-20240728221932124-00700c.png" alt></p></li></ul></li><li><p><strong>使用共享内存优化</strong>（优化的核心并不在明面上的复杂度，而是合理利用<strong>并行</strong>与<strong>高速缓存</strong>）：</p><ul><li><p>观察：处理矩阵C同一行的线程x,y需要读取矩阵A中相同的数据。</p></li><li><p>对于每一个线程块，先集合所有线程将所需的矩阵元素读进共享内存，再分别从共享内存读取元素进行乘加法运算。</p></li><li><p>图中表述为：将$K$拆成$tileK$块，每块$\frac{K}{tileK}$个元素。使用外层循环读取每块的元素，使用内层循环计算当前子块的结果。<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F11-03-45-fb9bb687a05446928b0544789962e9d7-image-20240728223826799-bdd177.png" alt></p></li></ul></li><li><p><strong>流水线优化</strong>：</p><ul><li><p>前提：本次循环的整个内层循环过程中不依赖下一次循环的数据。</p></li><li><p>读共享内存的周期仍多于计算所用的周期，可通过一定方式隐藏对共享内存的访问，重新优化流水线降低读取延迟。<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F11-04-14-d9d761d160714ed8d38aebe3545ca3cf-image-20240728223859792-0eadc1.png" alt></p></li><li><p>进一步，读全局内存时同样能做上述优化，从而实现隐藏全局内存读取延迟的目的。<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F10-20-39-7dae9738e8756a0bc5650804dc87b7be-image-20240728225155829-38147f.png" alt="image-20240728225155829"></p></li></ul></li></ul><h2 id="数据处理模块"><a href="#数据处理模块" class="headerlink" title="数据处理模块"></a>数据处理模块</h2><ul><li><p>易用性：基于描述数据集变换的编程抽象提供编程接口与变换算子，数据集创建方式</p></li><li><p>高效性</p><ul><li><p>数据读取：统一文件格式，并行化读取（<code>num_workers</code>）</p></li><li><p>数据计算（预处理）：</p><ul><li><p>底层架构层面：流水线并行，算子并行；异构计算（CPU+GPU），分布式（多服务器数据处理）</p></li><li><p>编译算法层面：AI编译层面的计算图优化，同将多个操作融合或调换顺序实现优化。</p></li></ul></li></ul></li><li><p>保序性：即在<code>shuffle</code>的后续操作中，不能对数据的输出顺序有改变。通过不同进程间的<code>connector</code>队列实现。</p></li></ul><h2 id="模型部署"><a href="#模型部署" class="headerlink" title="模型部署"></a>模型部署</h2><h3 id="训练时模型-➡-推理时模型"><a href="#训练时模型-➡-推理时模型" class="headerlink" title="训练时模型 ➡ 推理时模型"></a>训练时模型 ➡ 推理时模型</h3><ul><li><p>ONNX(Open Neural Network Exchange)神经网络交换协议：将不同框架的模型使用中间语言统一表示</p></li><li><p>推理时优化：推理时一些层的行为改变，且权重参数皆为常数。算子融合，算子替换，算子重排。</p></li></ul><h3 id="✳模型压缩✳"><a href="#✳模型压缩✳" class="headerlink" title="✳模型压缩✳"></a>✳<strong>模型压缩</strong>✳</h3><ul><li><p>模型量化：将权重与激活值从浮点数映射到整数（int8），实现存储上的压缩与推理上的加速，在输出层及某些层需要通过<strong>反量化</strong>将整数映射回浮点数。<strong>需要在模型精度与效率间达到平衡</strong></p><p><strong>QLoRA</strong>: 一种使用量化方案的LoRA，原LLM量化为4位（四位如何表达数值有很大讲究）后，再使用LoRA微调</p></li><li><p>模型稀疏（剪枝）：</p><ul><li><p>动机：过参数化，激活值特征图中能利用的有效信息相对于整张图占比较小</p></li><li><p>方法：将权重与激活值的某些强度较弱的值（绝对值大小）设置为0，0值所占的比例称为模型稀疏度。</p><ul><li><p>结构化稀疏：在通道或者卷积核层面对模型进行剪枝。这种稀疏方式能够得到规则且规模更小的权重矩阵</p></li><li><p>非结构化稀疏：以对权重张量中任意位置的权重进行裁剪</p></li><li><p>稀疏策略：$预训练 —— 稀疏剪枝 —— 微调 / 训练 —— 剪枝 —— 训练 …$<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F11-09-24-35f899f96641079e58f118c2c28e030c-image-20240731150800525-5ee017.png" alt></p></li></ul></li></ul></li><li><p>知识蒸馏（教师-学生神经网络学习算法）：教师网络是训练好的网络，学生网络是待训练网络，通常参数更少。</p><ul><li><p>方法1：同时令学生网络的结果接近真实标签结果与教师神经网络的分类结果<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F11-10-21-729b7d365e123c5feaa0d5f560ce4465-image-20240731151514750-5b7a38.png" alt></p></li><li><p>方法2：仅将教师网络的输出中提取有价值的信息与学生同步远远不够，还可以从中间结果（特征图）中挖掘信息与学生同步。<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F10-20-40-c5210b3a2a08bcc66862bcbec23dc03a-image-20240731152024171-211f2b.png" alt="image-20240731152024171"></p></li></ul></li></ul><h3 id="推理优化"><a href="#推理优化" class="headerlink" title="推理优化"></a>推理优化</h3><ul><li><p>并行计算：矩阵乘，拆成多个线程同步运算</p></li><li><p>算子优化：</p><ul><li><p>硬件汇编指令优化：合理利用硬件寄存器，提升缓存命中率、优化汇编性能</p></li><li><p>算法优化：<strong>卷积的矩阵乘法优化</strong></p><ul><li><p>img2col：卷积的本质仍是矩阵乘法，具体而言，将输入与权重分别做重排，对输入而言，将$1<em>IH</em>IW<em>IC$重排为$(OH</em>OW)<em>(KH</em>KW<em>IC)$，即将与卷积核运算的每个区域展开成一行，根据步长和填充，获得$OH</em>OW$行：<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F10-20-41-5e2246806998a64cc35f6288087cc62d-image-20240731165724176-666844.png" alt="image-20240731165724176"></p><p>对权重而言，将一个卷积核展开为权重矩阵的一列，共$OC$列，最后二者矩阵乘法，得到$OH<em>OW</em>OC$维度的特征图。<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F11-12-21-c9cda5663d1ae02e7ea47486ebe4c7a2-image-20240731170110208-403c7a.png" alt></p></li><li><p>Winograd算法：简化卷积运算，减少非常量乘法运算，增加常量加法与乘法运算，使用中需要取舍。<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F30%2F11-12-59-aa5d63f1c09ad2a6f35ab798d8ab0e47-image-20240731170930345-d30949.png" alt></p></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 机器学习系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
            <tag> 机器学习系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『深度学习』动手学深度学习——阅读笔记1</title>
      <link href="/post/866b08a7.html"/>
      <url>/post/866b08a7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『深度学习』动手学深度学习——阅读笔记1"><a href="#『深度学习』动手学深度学习——阅读笔记1" class="headerlink" title="『深度学习』动手学深度学习——阅读笔记1"></a>『深度学习』动手学深度学习——阅读笔记1</h1><p>❀<strong>目录</strong>❀</p><p><strong><em><a href="https://yangyzzzz.github.io/post/866b08a7.html">『深度学习』动手学深度学习——阅读笔记1</a></em></strong></p><p><strong><em><a href="https://yangyzzzz.github.io/post/52e1e34e.html">『深度学习』动手学深度学习——阅读笔记2</a></em></strong></p><h2 id="零-前言"><a href="#零-前言" class="headerlink" title="零. 前言"></a>零. 前言</h2><p><strong><em><a href="https://zh-v2.d2l.ai/">动手学AI电子书链接</a></em></strong>。本书阅读于24年寒假，每天上午一章节，随阅读随记录笔记，记录的不详尽或复制粘贴原文之处敬请谅解。By the way，这是笔者推荐<strong>深度学习</strong>入门最好的指导书。</p><h2 id="一-引言"><a href="#一-引言" class="headerlink" title="一.引言"></a>一.引言</h2><h3 id="1-四大基石"><a href="#1-四大基石" class="headerlink" title="1. 四大基石"></a>1. 四大基石</h3><ol><li><p>数据</p></li><li><p>模型</p></li><li><p>目标函数</p></li><li><p>优化算法 —— 基于梯度下降</p></li></ol><h3 id="2-机器学习分类"><a href="#2-机器学习分类" class="headerlink" title="2. 机器学习分类"></a>2. 机器学习分类</h3><ol><li>有监督学习(分类，回归，序列学习—时间序列预测），下流任务丰富多样</li><li>无监督学习</li><li>强化学习(环境—动作—奖励 三元组)</li></ol><h2 id="二-数学基础"><a href="#二-数学基础" class="headerlink" title="二. 数学基础"></a>二. 数学基础</h2><h3 id="1-线性代数"><a href="#1-线性代数" class="headerlink" title="1. 线性代数"></a>1. 线性代数</h3><ol><li><p>数据形式</p><ul><li><p>标量</p></li><li><p>向量</p></li><li><p>矩阵</p></li><li><p>张量</p></li></ul></li><li><p>运算</p><ul><li><p>矩阵元素级别运算</p></li><li><p>向量间点积</p></li><li><p>矩阵 * 向量</p></li><li><p>矩阵 * 矩阵</p></li></ul></li><li><p>范数：衡量向量的“大小”</p><ul><li><p>L1</p></li><li><p>L2（欧氏距离）</p></li><li><p>余弦距离</p></li></ul></li></ol><h3 id="2-微分"><a href="#2-微分" class="headerlink" title="2. 微分"></a>2. 微分</h3><p>构建计算图来保存每个标量在反向传播后的梯度，梯度的计算运用偏导和链式法则。</p><p><strong>梯度</strong>：<script type="math/tex">f(x)</script>中对每一个自变量x分值的微分，结果为一个向量</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-07-53-709514277eb9778a29ffe86ed4c6f899-image-20240115220027364-10427f.png" alt="image-20240115220027364"></p><p><strong>链式法则</strong>：见淑芬</p><p><strong>分离计算图</strong>：y.detach() 将y从计算图中分离，将其看为常量，不会在经过y向后传播到其他参数。</p><p>一般而言，函数都是”多对1”的，即向量到标量的映射，向量到向量的映射也可以被拆解为多个向量到标量的映射。</p><p> torch 支持自动微分，详细请参见<code>mlsys</code>部分。</p><h3 id="3-概率"><a href="#3-概率" class="headerlink" title="3. 概率"></a>3. 概率</h3><p>随机变量，条件概率，联合概率，Bayes定理，期望与方差。</p><h2 id="三-线性神经网络"><a href="#三-线性神经网络" class="headerlink" title="三. 线性神经网络"></a>三. 线性神经网络</h2><p>最简单的单层网络结构。</p><h3 id="1-线性回归"><a href="#1-线性回归" class="headerlink" title="1. 线性回归"></a>1. 线性回归</h3><p>拥有解析解，可通过牛顿最小二乘等方法求解，然而更多的深度网络没有解析解，而只能通过梯度下降逼近的方式逼近最小值。</p><h3 id="2-全连接层"><a href="#2-全连接层" class="headerlink" title="2. 全连接层"></a>2. 全连接层</h3><p>最基础的线性模型。</p><h3 id="3-softmax"><a href="#3-softmax" class="headerlink" title="3.  softmax"></a>3.  softmax</h3><p>激活函数，无参数，用于分类，即使不是线性变换，但也是输入经过仿射变换得到，因此也是线性模型。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-56-48-03443e231ee8a7716f80e04fc68bec3d-image-20240116174615937-a78584.png" alt></p><p>在<code>pytorch</code>实现中，我们没有将softmax概率传递到损失函数中， 而是在交叉熵损失函数中传递未规范化的原始预测，在内部计算softmax及其对数， 这是一种聪明方式。</p><h3 id="4-仿射变换的概念"><a href="#4-仿射变换的概念" class="headerlink" title="4. 仿射变换的概念"></a>4. 仿射变换的概念</h3><p>相比之下，仿射变换是一种线性变换，它包括缩放、旋转、平移和切变等操作。在神经网络中，通常所说的仿射变换通常指的是某层的输出是输入的加权和加上偏置项，数学上表示为：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-57-35-f127c12bb5558cbae24f907cae9a35bc-image-20240116190703275-030613.png" alt></p><h2 id="四-多层感知机"><a href="#四-多层感知机" class="headerlink" title="四. 多层感知机"></a>四. 多层感知机</h2><p>深层网络的基本原理与技巧。</p><h3 id="1-训练误差与泛化误差"><a href="#1-训练误差与泛化误差" class="headerlink" title="1. 训练误差与泛化误差"></a>1. 训练误差与泛化误差</h3><p><em>训练误差</em>（training error）是指， 模型在训练数据集上计算得到的误差。 <em>泛化误差</em>（generalization error）是指， 模型应用在同样从原始样本的分布中抽取的无限多数据样本时，模型误差的期望。</p><h3 id="2-欠拟合与过拟合"><a href="#2-欠拟合与过拟合" class="headerlink" title="2. 欠拟合与过拟合"></a>2. 欠拟合与过拟合</h3><p>欠拟合：表现为训练误差和验证误差都很严重， 但它们之间仅有一点差距，意味着模型表达能力不足，无法学习模式，但是我们有理由相信可以用一个更复杂的模型降低训练误差</p><p>（重点）过拟合：模型在训练数据上拟合的比在潜在分布中更接近的现象称作过拟合，即训练误差很低，但是训练误差与泛化误差的差值较大，解决过拟合的方法称为<em>正则化</em></p><h3 id="3-影响模型泛化的三个因素"><a href="#3-影响模型泛化的三个因素" class="headerlink" title="3. 影响模型泛化的三个因素"></a>3. 影响模型泛化的三个因素</h3><ol><li>可调整参数的数量。当可调整参数的数量（有时称为<em>自由度</em>）很大时，模型往往更容易过拟合。</li><li>参数采用的值。当权重的取值范围较大时，模型可能更容易过拟合。</li><li>训练样本的数量。即使模型很简单，也很容易过拟合只包含一两个样本的数据集。而过拟合一个有数百万个样本的数据集则需要一个极其灵活的模型。</li></ol><h3 id="4-正则化技术"><a href="#4-正则化技术" class="headerlink" title="4. 正则化技术"></a>4. 正则化技术</h3><p>在模型训练技术上提高泛化性的技术，经典泛化理论认为，为了缩小训练和测试性能之间的差距，应该以简单的模型为目标。何为简单：</p><ol><li><p>权重衰减法：函数约接近0越简单，即令在损失函数中添加正则惩罚项，令权重尽可能趋于0。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-58-03-04b20b11c2f997d31086a08ba7885a70-image-20240117160415813-9173f2.png" alt></p></li><li><p>暂退法(dropout)：平滑性，越平滑越简单，函数越能对输入的微小变化不敏感越简单。因此每轮会令部分神经元置0。注意在测试时我们使用完整的模型，不使用dropout。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-58-32-14e2ea1e572bd00f378d4136b053e7f5-image-20240117160332773-e443be.png" alt></p></li></ol><h3 id="5-训练过程"><a href="#5-训练过程" class="headerlink" title="5. 训练过程"></a>5. 训练过程</h3><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-58-47-054e71be37b812bd06a5cb0967386fdf-image-20240117162534495-d115d9.png" alt></p><p>在训练神经网络时，在初始化模型参数后， 我们交替使用前向传播和反向传播，利用反向传播给出的梯度来更新模型参数。 注意，反向传播重复利用前向传播中存储的中间值，以避免重复计算。 带来的影响之一是我们需要保留中间值，直到反向传播完成。 这也是训练比单纯的预测需要更多的内存（显存）的原因之一。 此外，这些中间值的大小与网络层的数量和批量的大小大致成正比。 因此，使用更大的批量来训练更深层次的网络更容易导致<em>内存不足</em>（out of memory）错误。</p><h3 id="6-权重初始化"><a href="#6-权重初始化" class="headerlink" title="6. 权重初始化"></a>6. 权重初始化</h3><ul><li>梯度消失和梯度爆炸是深度网络中常见的问题。在参数初始化时需要非常小心，以确保梯度和参数可以得到很好的控制。</li><li>ReLU激活函数缓解了梯度消失问题，这样可以加速收敛。</li></ul><h4 id="6-1-默认初始化-Kaiming-初始化"><a href="#6-1-默认初始化-Kaiming-初始化" class="headerlink" title="6.1 默认初始化 / Kaiming 初始化"></a>6.1 默认初始化 / Kaiming 初始化</h4><p>使用标准正态分布来初始化权重值。</p><h4 id="6-2-Xavier初始化"><a href="#6-2-Xavier初始化" class="headerlink" title="6.2 Xavier初始化"></a>6.2 Xavier初始化</h4><p>仍然假设采样的分布应为零均值，方差$\delta^2$，并且假设在一个不存在非线性的全连接层中，输入$x$也具有零均值和方差$\gamma^2$，我们此时期望输出$o$与输入$x$的均值方差保持一致（最重要的<strong>数值稳定性</strong>）即具有零均值与方差$\gamma^2$，经过数学推导可得$n<em>\mathrm{in} \sigma^2 = 1$。在反向传播中运用相同的推论（此部分较复杂），我们希望梯度的方差也保持不变，因此$n</em>\mathrm{out} \sigma^2 = 1$。因此，折中方案即令$\sigma^2 = \frac{2}{n<em>{in}+n</em>{out}}$。</p><p>注意这并不代表一定是正态分布采样，实际上主流有两种方式采样，一种是正态分布采样，一种是均匀分布采样，等价于值域$U\left(-\sqrt{\frac{6}{n<em>\mathrm{in} + n</em>\mathrm{out}}}, \sqrt{\frac{6}{n<em>\mathrm{in} + n</em>\mathrm{out}}}\right)$。</p><h2 id="五-深度学习计算"><a href="#五-深度学习计算" class="headerlink" title="五. 深度学习计算"></a>五. 深度学习计算</h2><h3 id="1-层和块"><a href="#1-层和块" class="headerlink" title="1. 层和块"></a>1. 层和块</h3><p>块中包含多个层或块，为了复用等操作，均继承自nn.Module。</p><p>顺序块是一种特殊的块，它内部的层链条般顺序相连。</p><p>我们也可以自定义块，在块内部实现任意的数据流动，我们也可以在其中设置不反向传播的参数等。</p><h3 id="2-参数管理"><a href="#2-参数管理" class="headerlink" title="2. 参数管理"></a>2. 参数管理</h3><h4 id="2-1-获取参数"><a href="#2-1-获取参数" class="headerlink" title="2.1 获取参数"></a>2.1 获取参数</h4><p>获取全部参数，无论哪个层次，均可通过下述方法获得当前层次包含的全部参数，因此我们可以粗或细粒度批量操作参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for name, param in net.named_parameters()  # 带名称</span><br><span class="line">for param in net.parameters()  # 不带名称</span><br></pre></td></tr></table></figure><p>网络图如图所示，我们可以通过索引获得相应的参数，如我们访问第一个主要的块中、第二个子块的第一层的偏置项。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rgnet[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>].bias.data</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Sequential(</span><br><span class="line">  (0): Sequential(</span><br><span class="line">    (block 0): Sequential(</span><br><span class="line">      (0): Linear(in_features=4, out_features=8, bias=True)</span><br><span class="line">      (1): ReLU()</span><br><span class="line">      (2): Linear(in_features=8, out_features=4, bias=True)</span><br><span class="line">      (3): ReLU()</span><br><span class="line">    )</span><br><span class="line">    (block 1): Sequential(</span><br><span class="line">      (0): Linear(in_features=4, out_features=8, bias=True)</span><br><span class="line">      (1): ReLU()</span><br><span class="line">      (2): Linear(in_features=8, out_features=4, bias=True)</span><br><span class="line">      (3): ReLU()</span><br><span class="line">    )</span><br><span class="line">    (block 2): Sequential(</span><br><span class="line">      (0): Linear(in_features=4, out_features=8, bias=True)</span><br><span class="line">      (1): ReLU()</span><br><span class="line">      (2): Linear(in_features=8, out_features=4, bias=True)</span><br><span class="line">      (3): ReLU()</span><br><span class="line">    )</span><br><span class="line">    (block 3): Sequential(</span><br><span class="line">      (0): Linear(in_features=4, out_features=8, bias=True)</span><br><span class="line">      (1): ReLU()</span><br><span class="line">      (2): Linear(in_features=8, out_features=4, bias=True)</span><br><span class="line">      (3): ReLU()</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (1): Linear(in_features=4, out_features=1, bias=True)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h4><p>各种类型初始化，torch也会默认初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nn.init.normal_(m.weight, mean=<span class="number">0</span>, std=<span class="number">0.01</span>) nn.init.zeros_(m.bias)</span><br><span class="line">nn.init.constant_(m.weight, <span class="number">1</span>)</span><br><span class="line">nn.init.xavier_uniform_(m.weight)</span><br></pre></td></tr></table></figure><h3 id="3-读写文件"><a href="#3-读写文件" class="headerlink" title="3. 读写文件"></a>3. 读写文件</h3><p><code>state_dict()</code>：权重字典，包含名称(<code>xx.xx.weight/bias</code>)和值(<code>[1., 2., ...]</code>)</p><p>这要求我们先初始化好框架，在往框架中填参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">torch.save(net.state_dict(), &#x27;mlp.params&#x27;)  # 保存权重</span><br><span class="line">clone.load_state_dict(torch.load(&#x27;mlp.params&#x27;))  # 加载权重</span><br></pre></td></tr></table></figure><p>当然我们同样可以保存模型与参数。</p><h3 id="4-GPU"><a href="#4-GPU" class="headerlink" title="4. GPU"></a>4. GPU</h3><p>只要所有的数据和参数都在同一个设备上， 我们就可以有效地学习模型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.device(&#x27;cpu&#x27;), torch.device(&#x27;cuda:1&#x27;)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-59-30-162961a8dfb413d1d1c69f84a4d03101-image-20240119162731561-4f7c18.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x.cpu() <span class="comment"># gpu -&gt; cpu</span></span><br><span class="line">x.to(device)/x.cuda() <span class="comment"># cpu -&gt; gpu</span></span><br></pre></td></tr></table></figure><ul><li>我们可以指定用于存储和计算的设备，例如CPU或GPU。默认情况下，数据在主内存中创建，然后使用CPU进行计算。</li><li>深度学习框架要求计算的所有输入数据都在同一设备上，无论是CPU还是GPU。</li><li>不经意地移动数据可能会显著降低性能。一个典型的错误如下：计算GPU上每个小批量的损失，并在命令行中将其报告给用户（或将其记录在NumPy <code>ndarray</code>中）时，将触发全局解释器锁，从而使所有GPU阻塞。最好是为GPU内部的日志分配内存，并且只移动较大的日志! </li></ul><h2 id="六-卷积神经网络"><a href="#六-卷积神经网络" class="headerlink" title="六. 卷积神经网络"></a>六. 卷积神经网络</h2><p>我们若对图像也采用同样的全连接层，则每个输出值要收到所有输入像素的信息，这样参数开销是巨大的。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-07-55-ccee1874415d610631937a0e9ffec931-image-20240119170233285-456416.png" alt="image-20240119170233285"></p><h3 id="1-计算机视觉的两大特性"><a href="#1-计算机视觉的两大特性" class="headerlink" title="1. 计算机视觉的两大特性"></a>1. 计算机视觉的两大特性</h3><ol><li><em>平移不变性</em>（translation invariance）：不管检测对象出现在图像中的哪个位置，神经网络的前面几层应该对相同的图像区域具有相似的反应，即为“平移不变性”。</li><li><em>局部性</em>（locality）：神经网络的前面几层应该只探索输入图像中的局部区域，而不过度在意图像中相隔较远区域的关系，这就是“局部性”原则。最终，可以聚合这些局部特征，以在整个图像级别进行预测。</li></ol><h3 id="2-卷积层"><a href="#2-卷积层" class="headerlink" title="2. 卷积层"></a>2. 卷积层</h3><h4 id="2-1-平移不变性"><a href="#2-1-平移不变性" class="headerlink" title="2.1  平移不变性"></a>2.1  平移不变性</h4><p>这意味着检测对象随输入的平移，应该仅导致隐藏表示H的平移，即在<code>(i,j)</code>位置的输出像素和在<code>(a, b)</code>位置的输出像素所使用的参数应当是相同的，即参数不依赖于<code>(i,j)</code>的值。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-59-58-d56fd648409f4fbefc88cb0bdd3b5a79-image-20240119170642333-b19046.png" alt></p><h4 id="2-2-局部性"><a href="#2-2-局部性" class="headerlink" title="2.2 局部性"></a>2.2 局部性</h4><p>划定一个范围，卷积核只看范围之内的内容，而忽视之外的内容。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-00-20-ea6b0e4bf441b32718a6357a079e44c9-image-20240119170811852-13a926.png" alt></p><h4 id="2-3-通道"><a href="#2-3-通道" class="headerlink" title="2.3 通道"></a>2.3 通道</h4><p>图象是三维的，隐藏表示也最好用三维向量，换句话说，对于每一个空间位置，我们想要采用一组而不是一个隐藏表示。这样一组隐藏表示可以想象成一些互相堆叠的二维网格。 因此，我们可以把隐藏表示想象为一系列具有二维张量的<em>通道</em>（channel）。 这些通道有时也被称为<em>特征映射</em>（feature maps），因为每个通道都向后续层提供一组空间化的学习特征。</p><p>考虑到输入的第三维度和输出的第三维度，我们的卷积核(卷积层的参数)拥有四个维度。</p><p>其中隐藏表示H中的索引d表示输出通道，而随后的输出将继续以三维张量H作为输入进入下一个卷积层。 所以，该公式可以定义具有多个通道的卷积层，而其中V是该卷积层的权重。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-07-55-5d21528e7551121ddc3fabd6e287f90a-image-20240119171019867-1e13a5.png" alt="image-20240119171019867"></p><h4 id="2-4-归纳偏置"><a href="#2-4-归纳偏置" class="headerlink" title="2.4 归纳偏置"></a>2.4 归纳偏置</h4><p>上述的图像假设均为先验知识，若不符合归纳偏置，则效果可能会很差，即用归纳偏置换更少的参数与运行训练效率。</p><h4 id="2-5-图像卷积"><a href="#2-5-图像卷积" class="headerlink" title="2.5 图像卷积"></a>2.5 图像卷积</h4><p>在卷积神经网络中，对于某一层的任意元素，其<em>感受野</em>（receptive field）是指在前向传播期间可能影响计算的所有元素（来自所有先前层）。</p><p>我们可以从数据中学习卷积核的参数。</p><h4 id="2-6-关键参数，填充和步幅，输入输出通道"><a href="#2-6-关键参数，填充和步幅，输入输出通道" class="headerlink" title="2.6 关键参数，填充和步幅，输入输出通道"></a>2.6 关键参数，填充和步幅，输入输出通道</h4><ul><li><strong>padding</strong>: 一般为保持输入和输出的长宽相同(<code>stride=1</code>)，因此通常填充方式为。做padding的目的是防止边缘信息丢失。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-00-51-17e6c09f9283ef74d579b40ffad0ddda-image-20240119174615738-8637ab.png" alt></p><ul><li><strong>stride</strong>: 用于减小输出的长宽，通常而言，步长为n，我们的输出长宽均除以n。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-01-03-411f5a3435081d43baf42f5aa168599c-image-20240119174811722-8f72f0.png" alt></p><ul><li><strong>in, out</strong>: 输入输出通道，卷积核拥有参数 <script type="math/tex">c_in * c_out * k_h * k_w</script> </li></ul><h4 id="2-7-1x1-卷积核"><a href="#2-7-1x1-卷积核" class="headerlink" title="2.7 1x1 卷积核"></a>2.7 1x1 卷积核</h4><p>作用于同一个位置的不同通道，相当于在通道维度上的全连接层，通常用于调整网络层的通道数量和控制模型复杂性。</p><h3 id="3-池化层"><a href="#3-池化层" class="headerlink" title="3. 池化层"></a>3. 池化层</h3><p>通常当我们处理图像时，我们希望逐渐降低隐藏表示的空间分辨率、聚集信息，这样随着我们在神经网络中层叠的上升，每个神经元对其敏感的感受野（输入）就越大。</p><p>而我们的机器学习任务通常会跟全局图像的问题有关（例如，“图像是否包含一只猫呢？”），所以我们最后一层的神经元应该对整个输入的全局敏感。通过逐渐聚合信息，生成越来越粗糙的映射，最终实现学习全局表示的目标，同时将卷积图层的所有优势保留在中间层。</p><p>池化层没有可学习参数。</p><h4 id="3-1-目的"><a href="#3-1-目的" class="headerlink" title="3.1 目的"></a>3.1 目的</h4><ol><li>降低卷积层对位置的敏感性，相邻位置的值被综合为一个值</li><li>降低对空间降采样表示的敏感性。</li></ol><h4 id="3-2-最大池化和平均池化"><a href="#3-2-最大池化和平均池化" class="headerlink" title="3.2 最大池化和平均池化"></a>3.2 最大池化和平均池化</h4><p>torch默认步长等于窗口大小。</p><ul><li>对于给定输入元素，最大汇聚层会输出该窗口内的最大值，平均汇聚层会输出该窗口内的平均值。</li><li>汇聚层的主要优点之一是减轻卷积层对位置的过度敏感。</li><li>我们可以指定汇聚层的填充和步幅。</li><li>使用最大汇聚层以及大于1的步幅，可减少空间维度（如高度和宽度）。</li><li>汇聚层的输出通道数与输入通道数相同。</li></ul><p><strong>普遍规律</strong>：长宽维度逐渐降低，即全局信息越来越汇总，而通道数逐渐变多，即全局的不同特征被提取的越来越多</p><h3 id="4-LeNet"><a href="#4-LeNet" class="headerlink" title="4. LeNet"></a>4. LeNet</h3><p>卷积神经网络的开山之作，作者杨立昆；深度很浅，以全连接层汇聚。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-01-26-0b43f529afaff80c8c77f5b9108c6985-image-20240119180959946-5f442c.png" alt></p><h2 id="七-现代神经网络"><a href="#七-现代神经网络" class="headerlink" title="七. 现代神经网络"></a>七. 现代神经网络</h2><h3 id="1-AlexNet"><a href="#1-AlexNet" class="headerlink" title="1. AlexNet"></a>1. AlexNet</h3><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-02-41-f538a0d4f09e5aaa69087c5184227cac-image-20240121184021967-b4b6c9.png" alt></p><p>和LeNet比更深了，用的卷积核更大了，且激活函数使用reLU而不是sigmoid。</p><p><strong>relu的优点</strong>：简单，不像sigmoid一般有复杂的求幂运算；正向时梯度为1，有效避免了梯度消失的问题，因此目前设计激活函数时均使用relu及其变种，如leakyrelu。</p><h3 id="2-VGG"><a href="#2-VGG" class="headerlink" title="2. VGG"></a>2. VGG</h3><p>研究人员开始从单个神经元的角度思考问题，发展到整个层，现在又转向块，重复层的模式。</p><p>将多个层堆叠为一个块，一个块通常是可以复用的。</p><p>经典卷积神经网络的基本组成部分是下面的这个序列：</p><ol><li>带填充以保持分辨率的卷积层；</li><li>非线性激活函数，如ReLU；</li><li>汇聚层，如最大汇聚层。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-07-56-6a08c88ee754dc33320c5977fcc63bf2-image-20240121184837606-9f1c66.png" alt="image-20240121184837606"></p><p>原始VGG网络有5个卷积块，其中前两个块各有一个卷积层，后三个块各包含两个卷积层。 第一个模块有64个输出通道，每个后续模块将输出通道数量翻倍，直到该数字达到512。由于该网络使用8个卷积层和3个全连接层，因此它通常被称为VGG-11。</p><p>一般激活函数和池化层由于无需参数，不称作一层。</p><p>卷积参数少，但是运算次数不会太少。</p><h3 id="3-NiN"><a href="#3-NiN" class="headerlink" title="3. NiN"></a>3. NiN</h3><p>目前的设计模式都是通过一系列的卷积层和池化层提取空间结构，然后通过全连接层对特征的表征进行处理。但是在最后使用全连接层会放弃表征的空间结构（即使在深层长宽通常已经很小），因此NiN提出，可以在每个像素的通道上分别使用多层感知机，即<script type="math/tex">1*1</script>的卷积核。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-03-01-a8d922ec58caaeb466a1f9e749d33f0c-image-20240121185710702-cb66cf.png" alt></p><p>最后通过一个全局平均池化层，将每个通道的长和宽下采样到<script type="math/tex">1*1</script>。</p><h3 id="4-含并行连结的网络（GoogLeNet）"><a href="#4-含并行连结的网络（GoogLeNet）" class="headerlink" title="4. 含并行连结的网络（GoogLeNet）"></a>4. 含并行连结的网络（GoogLeNet）</h3><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F18-07-58-5abfe391da4a4fead91860879b3274e1-image-20240121212632646-8afc24.png" alt="image-20240121212632646"></p><p>它们可以用各种滤波器尺寸探索图像，这意味着不同大小的滤波器可以有效地识别不同范围的图像细节。 同时，我们可以为不同的滤波器分配不同数量的参数。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F29%2F19-03-44-5265ca0098df7c1afaa3b1495fe7db5f-image-20240121213106433-ace719.png" alt></p><p>GoogLeNet一共使用9个Inception块和全局平均汇聚层的堆叠来生成其估计值。Inception块之间的最大汇聚层可降低维度。 第一个模块类似于AlexNet和LeNet，Inception块的组合从VGG继承，全局平均汇聚层避免了在最后使用全连接层。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 深度学习 </category>
          
          <category> 深度学习基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『智谱清言』深度学习环境常见问题</title>
      <link href="/post/32f03788.html"/>
      <url>/post/32f03788.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『智谱清言』深度学习环境常见问题"><a href="#『智谱清言』深度学习环境常见问题" class="headerlink" title="『智谱清言』深度学习环境常见问题"></a>『智谱清言』深度学习环境常见问题</h1><p>持续更新</p><h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><p><strong>环境</strong>：Ubuntu 22.0，8*A100，Nvidia-smi CUDA:12.2，安装的CUDA版本为10.1</p><p>之前一直能正常使用CUDA，今天突然无法正常使用GPU，报错如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/home/yangbowen/anaconda3/envs/yangbowen/lib/python3.10/site-packages/torch/cuda/__init__.py:128: UserWarning: CUDA initialization: Unexpected error from cudaGetDeviceCount(). Did you run some cuda functions before calling NumCudaDevices() that might have already set an error? Error 802: system not yet initialized (Triggered internally at ../c10/cuda/CUDAFunctions.cpp:108.)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>一开始以为是CUDA版本不对应，但是这台机器的CUDA是管理员配置好的，且有进程在运行，无法卸载重装。</p><p>经大量查阅资料，发现是不小心使用了 <code>apt update</code> 更新了 <code>nvidia-fabricmanager</code> 的版本，而 <code>nvidia-fabricmanager</code> 必须要和CUDA版本保持一致，解决方案如下：</p><ul><li><code>systemctl status nvidia-fabricamanager</code> 查看当前状态为 failed，确定此处出现问题</li></ul><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F14%2F15-15-15-5f58efd6c44661bddd1df36a443614bf-image-20241014151508230-6bc4c6.png" alt="image-20241014151508230"></p><ul><li>查看版本更新改动，可以发现版本从 535.129.03-1 更新为 535.183.06-0</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/dpkg.log | grep nvidia</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">2024-10-08 15:03:54 status installed nvidia-fabricmanager-535:amd64 535.129.03-1</span></span><br><span class="line"><span class="string">2024-10-14 12:10:19 upgrade nvidia-fabricmanager-535:amd64 535.129.03-1 535.183.06-0ubuntu0.20.04.1</span></span><br><span class="line"><span class="string">&#x27;</span><span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>官网安装对应版本，并重新启动</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载，选择自己的版本</span></span><br><span class="line">wget https://developer.download.nvidia.cn/compute/cuda/repos/&#123;ubuntu2204&#125;/x86_64/nvidia-fabricmanager-&#123;535_535.129.03-1&#125;_amd64.deb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo apt-get install ./nvidia-fabricmanager-535_535.129.0</span><br><span class="line">3-1_amd64.deb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> nvidia-fabricmanager</span><br><span class="line">systemctl start nvidia-fabricmanager</span><br></pre></td></tr></table></figure><ul><li>再次查看状态，并重新<code>import torch</code>，发现已经解决！</li></ul><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F14%2F15-20-10-94d1d1fb5a3f93a95d7505d3d3a7cf2c-image-20241014152010673-14204c.png" alt="image-20241014152010673"></p><h2 id="问题二：ImportError-libGL-so-1-cannot-open-shared-object-file-No-such-file-or-directory"><a href="#问题二：ImportError-libGL-so-1-cannot-open-shared-object-file-No-such-file-or-directory" class="headerlink" title="问题二：ImportError: {libGL.so.1}: cannot open shared object file: No such file or directory"></a>问题二：ImportError: {libGL.so.1}: cannot open shared object file: No such file or directory</h2><p>在Docker内部部署Yolo系列时经常遇见此种问题，这是Docker环境内缺少某些共享库导致的，可以使用如下命令解决。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错 ImportError: libGL.so.1: cannot open shared object file: No such file or directory </span></span><br><span class="line">apt-get install libgl1-mesa-glx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错 ImportError: libgthread-2.0.so.0: cannot open shared object file: No such file or directory</span></span><br><span class="line">apt-get install libglib2.0-0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 深度学习 </category>
          
          <category> MLLM/LLM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 实习 </tag>
            
            <tag> MLLM/LLM </tag>
            
            <tag> 机器学习系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『计算机网络』计算机网络实验——路由协议分析</title>
      <link href="/post/163e301f.html"/>
      <url>/post/163e301f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『计算机网络』计算机网络实验——路由协议分析"><a href="#『计算机网络』计算机网络实验——路由协议分析" class="headerlink" title="『计算机网络』计算机网络实验——路由协议分析"></a>『计算机网络』计算机网络实验——路由协议分析</h1><p>针对套件二的计网实验最难点在于OSPF和BGP协议的理解，简要记录如下。</p><h2 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h2><p>内部：RIP, OSPF</p><p>外部：BGP</p><h2 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h2><h3 id="Peer关系"><a href="#Peer关系" class="headerlink" title="Peer关系"></a>Peer关系</h3><ul><li>邻居状态机：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F21-06-47-3adfd5e11278b0ded5d23b5abc171b5f-image-20240511133938639-bc8c9b.png" alt="image-20240511133938639"></p><ul><li><p>建立邻接关系的过程（注意状态转移都是双方都有的）：</p><ol><li><p><code>Hello</code>报文确定邻居。状态： <code>down - init - 2-way</code></p></li><li><p>比较<code>routerid</code>，确定主从关系 状态：<code>Exstart</code></p></li><li><p>开始交换LSA摘要信息DBD，主方每次seq+1，从方每次传上一个从主方获得seq，以此来确保双方信息交换的正确性与顺序性。状态：<code>Exchange</code></p></li><li><p>交换完毕后，检查新信息是否与自己已有信息冲突，若不冲突则直接<code>Full</code>，冲突则<code>Loading</code>，发送LSR报文请求，对方发送LSU回复，收到回复后发送LSAck收到。双方都无冲突后，变为<code>Full</code>状态，如此建立起<strong>邻接关系</strong>。</p></li></ol></li></ul><h3 id="链路状态LSA"><a href="#链路状态LSA" class="headerlink" title="链路状态LSA"></a>链路状态LSA</h3><ul><li><p>第一类LSA和第二类LSA适用于<strong>同一Area</strong>下：</p><ul><li>四种不同类型的网络：末端网络，PPP，点到多点网络（使用第一类LSA），全连接网络（使用第二类LSA）<ul><li>路由器和交换机连接：Net网段</li><li>路由器和路由器连接：StubNet末端网段</li></ul></li><li>解决全连接网络的N方连接问题：第二类LSA与DR推举<ul><li>OSPF从该网络中选举一台路由器作为DR，负责传递信息，所有路由器都只将路由信息发送给DR，再由DR将信息发送给本网段其他路由器。BDR是备选DR，也与所有路由器建立邻接关系并交换路由信息，在DR失效后立刻成为DR，然后其他路由器重新选举BDR。其余所有路由器DROther不建立邻接关系，仅周期性发送<code>Hello</code>将邻居状态机保持在<code>2-way</code>。</li><li>DR是某个网段的概念，是针对路由器接口而言的。因此在描述全连接网络（以太网）时，仅使用一个一类LSA描述DR，和一个二类LSA描述DR手下的全部信息即可。</li></ul></li></ul></li><li><p>后三类LSA适用于<strong>不同Area</strong>下：</p><ul><li>多个Area包含的路由器称作ABR路由器，但路由器的每一个接口都必须唯一确定属于一个Area。</li><li>第三类LSA：ABR收到内部的一二类LSA时，会据此生成三类LSA，传播到相邻的Area。区域间的路由信息是通过ABR进行交互的，ABR将区域内已计算出的路由封装成第三类LSA发送到另一个区域。</li><li>第四类LSA：第五类LSA（通告外部路由的LSA）不能直接通过ABR传播到其它区域，因此ABR会产生第四类LSA来通告ASBR的存在。</li><li>第五类LSA：由ASBR生成的，用于通告外部路由（External Routes）。当ASBR引入非OSPF协议的路由信息时，它会生成第五类LSA，并将这些信息传播到整个自治系统（AS）内。</li></ul></li></ul><h3 id="路由器类型"><a href="#路由器类型" class="headerlink" title="路由器类型"></a>路由器类型</h3><ul><li><p>区域内路由器IAR：只生成一二类LSA，只保存一个LSDB。</p></li><li><p>区域边界路由器ABR: 该路由器同时属于至少两个区域，必须有一个是骨干区域Area0</p></li><li><p>骨干路由器BBR：至少有一个接口属于Area0(可以是虚拟连接？)，因此包含Area0的所有IAR和接口在Area0的ABR。该路由器为每一个所属的区域都生成第一类和第二类LSA,为每一个所属的区域保存一个LSDB,并根据需要生成Network Summary LSA(Type=3)和ASBR Summary LSA(Type=4)。</p></li><li><p>自治系统边界路由器ASBR：该路由器引入其他路由协议(静态路由和接口直连路由)，并不一定在拓扑结构中位于自治系统边界，可能是区域内路由器，也可能是ABR，只要引入了外部信息就是ASBR，生成第五类LSA。</p></li></ul><p>为解决第三类LSA自环问题，所有Area都要和骨干网络相连，无法物理相连就使用虚连接。</p><h3 id="OSPF路由算法"><a href="#OSPF路由算法" class="headerlink" title="OSPF路由算法"></a>OSPF路由算法</h3><p>在区域内部使用最短路径树（迪杰斯特拉）算法。在一个区域内，各台路由器最后的LSDB都是相同的，将其转换成一张带权的有向图。<strong>图相同，但是每台路由器对应的根节点不同</strong>，将某台路由器作为根节点计算到各路由器的最短距离。</p><ol><li><p>初始化，pred数组(根忽略，其余无)，vis数组(根为1，其余为0)，dis数组(根为0，其余为无穷)</p></li><li><p>每次选最小路径迭代…</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F21-18-46-3a31e449ff683426755943d3dc159c0a-image-20240511150041541-594588.png" alt="image-20240511150041541"></p><h2 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h2><p>用于自治系统间，基于TCP，只传递路由信息，而不计算路由，不暴露AS内部的网络拓扑。这个协议更复杂，无需彻底弄清。</p><h3 id="BGP对等体"><a href="#BGP对等体" class="headerlink" title="BGP对等体"></a>BGP对等体</h3><ul><li><p><strong>概念</strong>：两个建立BGP会话的路由器互为BGP对等体，BGP对等体之间可以交换路由表。根据AS是否同，分为EBGP（不同）和IBGP（同）。</p></li><li><p><strong>建立对等体</strong>：TCP三次握手后，相互发送OPEN报文，参数协商（自身AS号，自身router id）。后续通过keep-alive判断连接是否无问题，使用UPDATE报文通告路由。</p></li></ul><p>虽然BGP是运行于自治系统之间的路由协议，但要实现路由信息的全网传递就需要<strong>在同一个AS的边界路由器之间建立IBGP连接</strong>。</p><h3 id="BGP路由表，状态转移"><a href="#BGP路由表，状态转移" class="headerlink" title="BGP路由表，状态转移"></a>BGP路由表，状态转移</h3><ul><li><p>BGP状态转移图：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F21-06-49-d916d6a6d067578333db14e9d68f02bc-image-20240511155329568-d44a8b.png" alt="image-20240511155329568"><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F21-20-32-8bc028da6de41fbe9969b3fa075a302f-image-20240511155319186-be5593.png" alt="image-20240511155319186"></p></li><li><p><strong>BGP路由表生成</strong>：</p><ul><li><p>network方式：使用network命令可以将当前设备路由表中的路由（非BGP）发布到BGP路由表中并通告给邻居，和OSPF中使用network命令的方式大同小异，只不过在BGP宣告时，只需要宣告网段+掩码数即可，如：<code>network 12.12.0.0 16</code>。</p></li><li><p>Import方式：使用Import命令可以将该路由器学到的路由信息重分发到BGP路由表中，是BGP宣告路由的一种方式，可以引入BGP的路由包括：直连路由、静态路由及动态路由协议学到的路由。其命令格式与在RIP中重分发OSPF相似。</p></li></ul></li><li><p><strong>BGP通告原则</strong>：</p><ul><li><p>从IBGP对等体获得的BGP路由，BGP设备只传递给它的EBGP对等体。</p></li><li><p>从EBGP对等体获得的BGP路由，BGP设备传递给它所有EBGP和IBGP对等体（对等体是IBGP只能传递一跳，对等体是EBGP则不限制）</p></li><li><p>当存在多条到达同一目的地址的有效路由时，BGP设备只将最优路由发布给对等体</p></li><li><p>路由更新时，BGP设备只发送更新的BGP路由</p></li><li><p>所有对等体发送的路由，BGP设备都会接收</p></li><li><p>所有EBGP对等体在传递过程中下一跳改变</p></li><li><p>所有IBGP对等体在传递过程中下一跳不变（需要特别注意）</p></li><li><p>默认EBGP传递时 TTL值为1（需要特别注意）</p></li><li><p>默认IBGP传递时 TTL值为255</p></li></ul></li></ul><ul><li><strong>下一跳问题</strong>：在iBGP中，下一跳通常保持为从eBGP对等体学习到的原始下一跳。因此，iBGP对等体需要能够到达这个下一跳地址，这通常通过内部的IGP（如 OSPF 或 IS-IS）来确保。因此面对一些拓扑网络时，配置内部IGP和手动引入静态路由两种方案至少要选一个，否则会出现“下一跳问题”。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 课内实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『计算机网络』计算机网络理论——期末复习</title>
      <link href="/post/c0060df1.html"/>
      <url>/post/c0060df1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『计算机网络』计算机网络理论复习——期末复习"><a href="#『计算机网络』计算机网络理论复习——期末复习" class="headerlink" title="『计算机网络』计算机网络理论复习——期末复习"></a>『计算机网络』计算机网络理论复习——期末复习</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p><strong>时延</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F19-44-02-1eb61708efd4959c965a620b9558f135-image-20240528171359405-29b205.png" alt="image-20240528171359405"></p></li></ul><p>​    我们通常下载看到的<code>xx Mb/s</code>都是指发送速率，传播速率我们普遍认为光速。</p><ul><li><p><strong>体系结构</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F19-46-08-df44ca14a3760daa07ac0b5ba4c7c184-image-20240528172011733-72b4da.png" alt="image-20240528172011733"></p></li><li><p><strong>实体</strong>：任何可发送或接收信息的硬件或软件进程</p></li><li><p><strong>协议</strong>：控制两个对等实体进行通信的规则的集合</p></li></ul><h2 id="物理层-——-比特流（Bit）"><a href="#物理层-——-比特流（Bit）" class="headerlink" title="物理层 —— 比特流（Bit）"></a>物理层 —— 比特流（Bit）</h2><ul><li>四个特性：机械特性，电气特性，功能特性，过程特性</li><li>码元：数字信号，代表不同离散数值的基本波形</li></ul><ul><li><p><strong>码元速率（波特率）</strong>：单位时间内通过信道的码元个数。</p></li><li><p><strong>数据速率（比特率）</strong>：码元可以携带多比特，这取决于码元离散取值的数量，但信号电平级数较多可能出现串扰。</p></li><li><p>复用技术</p><ul><li>频分复用（FDM）与时分复用（TDM）</li><li>光的波分复用（WDM）</li><li>码分复用（CDM）：码分多址，用于无线通信，一个比特时间划分m个间隔，每个站分配一个唯一的m bit序列，且互相正交。即每个通信使用不同的m比特序列表示0和1，例如 00011011表示0，11100100表示1</li></ul></li><li><p>传输介质</p><ul><li>导引型：双绞线，同轴电缆，光纤</li><li>非导引型：无线电波传播</li></ul></li><li><p>奈奎斯特公式：$带宽 = 最大频率 - 最小频率$</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F19-54-16-6592e0e1e50a4407b9a0558a80f99e12-image-20240528190403061-74c9c5.png" alt="image-20240528190403061"></p></li></ul><ul><li><p>香农公式(考虑信噪比）：</p><p><img src="/post/c0060df1/Users\86166\AppData\Roaming\Typora\typora-user-images\image-20240528190817985.png" alt="image-20240528190817985"></p></li></ul><h2 id="数据链路层-——-帧（Frame）"><a href="#数据链路层-——-帧（Frame）" class="headerlink" title="数据链路层 —— 帧（Frame）"></a>数据链路层 —— 帧（Frame）</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><strong>解决的问题</strong>：如何组装帧，差错控制，流量控制，介质访问控制。</li><li>错误检测<ul><li>奇偶校验</li><li>CRC（循环冗余校验）：CRC的计算，双方约定好一个x位的除数，数据后面补充 x-1 位的 0，然后求余数替换。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F20-01-03-1dc79f4e5a72529d07660c974c819c25-image-20240528200409330-367ac2.png" alt="image-20240528200409330"></p><ul><li><p><strong>错误纠正</strong>：海明码，并不意味着可靠传输。</p></li><li><p><strong>滑动窗口协议</strong>：与TCP原理一致，但是切记这是两个东西。在这里滑动窗口以帧为单位。</p><ul><li>两种出错处理手段：<ul><li>后退N帧：<strong>当某帧出错时，该帧之后的帧全被丢弃，从出错帧开始重新发送</strong></li><li>选择性重传：当接收方发现出错时，发送一个NAK，发送方收到NAK后立即重传对应帧。接收方出错帧之后的帧会被缓冲区保留，待错误帧到来时按顺序上交给网络层。<strong>ACKn代表n和n之前的均接收</strong>！</li></ul></li><li><strong>流量控制</strong>：根据接收方缓存大小，发送ACK报文时携带窗口大小，同TCP。</li></ul></li><li><p>PPP协议：点到点的链路传输，识别帧边界使用：</p><ol><li><p>字符填充：数据中出现同样的字符，需要转义</p></li><li><p><strong>0比特填充</strong>：数据出现每五个连续的1后面必填入一个0，定界符为连续六个1</p></li></ol></li><li><p>介质访问控制协议（Medium Access Control, MAC）</p><ul><li><p>CSMA/CD（Carrier Sense Multiple Access with Collision Detection，载波监听多点访问/碰撞检测）：用于以太网。</p><ul><li><p>载波监听：发送前先听</p></li><li><p>碰撞检测：边发送边听，由于传播时延，单纯靠载波监听不能完全避免碰撞</p></li><li><p>碰撞强化：检测到碰撞后，立即停止发送，并发送干扰信号让所以有用户知道发生了碰撞</p></li><li><p>碰撞退避：碰撞后，等待不固定的时间后，再次监听+发送</p><blockquote><p>设单向传输时延为x，则双方均检测到碰撞最短需要x(中间)，最长需要2x(两端)。</p></blockquote></li><li><p>争用期：最多经过<code>2x</code>时间就能知道是否发生碰撞，<code>2x</code>称作争用期，对于发送速率为<code>y b/s</code>的网络，在争用期可以发送 <code>2xy</code> 个bit，即前<code>2xy</code>未发生碰撞，则不会发生碰撞，因此帧长必须要大于等于<code>2xy bit</code>！</p></li></ul></li><li><p>CSMA/CA（Carrier Sense Multiple Access with Collision Avoidance，载波监听多点访问/碰撞避免）：用于无线网络。</p></li></ul></li></ul><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><ul><li><p>分为LLC和MAC层</p></li><li><p><strong>MAC地址</strong>：48位，全球唯一，在局域网内使用</p></li><li><p>帧格式：和其他层的最大不同 —— 帧在尾部也加了校验和的内容</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F20-12-50-dd45acba1a5b6a86e8213cb0835f2461-image-20240528205123777-67c960.png" alt="image-20240528205123777"></p></li></ul><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><ul><li>每一个网络接口是一个网段（碰撞域），按照自学习算法建立转发表（通过发送时的源mac地址和进入接口建立映射）。</li><li><p>使用STP生成树协议避免广播风暴。</p></li><li><p><strong>VLAN</strong>：将网段分组，构成逻辑上独立的虚拟局域网。帧不会在两个VLAN之间自动转发，包括广播帧，隔离了<strong>广播域</strong>。</p></li></ul><h2 id="网络层-——-数据报（Packet）"><a href="#网络层-——-数据报（Packet）" class="headerlink" title="网络层 —— 数据报（Packet）"></a>网络层 —— 数据报（Packet）</h2><p>网络层主要作用是‌实现两个端系统之间的透明数据传输，负责转发和路由选择等功能。</p><h3 id="IP（Internet-Protocol）协议"><a href="#IP（Internet-Protocol）协议" class="headerlink" title="IP（Internet Protocol）协议"></a>IP（Internet Protocol）协议</h3><p><strong>IP</strong>采用数据报服务，配套使用的有<strong>ARP</strong>(地址解析)，<strong>ICMP</strong>(控制报文)，IGMP(管理协议)。</p><ul><li><p><strong>ARP与RARP</strong>：IP与物理地址相互转换问题，ARP以广播帧的形式在一个局域网内广播，主机和路由器内都有一个ARP缓存表记录IP和MAC的映射关系。主机向同一局域网下另一主机B发送IP包时，先查看缓存，没有就广播ARP寻找后填入mac地址位置。如果目的主机不在局域网内，那么IP包设置的mac地址应该是默认网关的mac地址。</p></li><li><p>IP首部：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F20-17-35-effb359c4da0a72b7371d5b0da1d73fd-image-20240528214041155-4da302.png" alt="image-20240528214041155"></p><ul><li><p>TTL：生存周期，IP包在网络中可通过路由器最大值，每经过一个路由器就减一</p></li><li><p><strong>Protocal</strong>: 标记上层协议是 TCP/UDP/ICMP</p></li><li><p>数据部分不参与校验和Checksum计算</p></li><li><p>有时根据帧最大长度进行IP包分片，分片的包通过标识位标记。计算分片时要考虑IP头占<strong>20字节</strong>。</p><p><img src="/post/c0060df1/Users\86166\AppData\Roaming\Typora\typora-user-images\image-20240528214356666.png" alt="image-20240528214356666"></p></li></ul></li><li><p>划分子网：子网掩码，无分类编址CIDR(彻底抛开网络分类，子网掩码称作网络前缀)</p><ul><li>将目的IP与子网掩码&amp;，即得到对应子网地址</li><li>主机根据自身IP与掩码，判断目的IP与自己在不在一个子网内，若满足等式$ IP<em>{self} \&amp; Mask</em>{self} = IP<em>{dest} \&amp; Mask</em>{self} $ ，代表在一个子网内，走局域网；不满足等式则转发到默认路由器。</li></ul></li><li>构造超网（<strong>路由聚合</strong>）：将多个CIDR地址块聚合成一个大地址块<ul><li>优势：路由表中的一个项目可以表示很多个原来传统分类地址的路由，可以减少路由表中表项个数，并减少路由器间交换的路由信息量。</li></ul></li><li><strong>NAT</strong>：内部网络使用局域网地址时，与互联网通信需要进行地址转换，否则互连网不认识局域地址。</li><li><p><strong>路由表表项</strong>：路由器表项包含路由选择的必要信息，主要内容如下：</p><ol><li><strong>目的 IP 地址</strong>：IP 包的目的地址。</li><li><strong>子网掩码</strong>：表示目的 IP 地址有多少位是网络位。</li><li><strong>网关</strong>：IP 包下一跳的 IP 地址。</li><li><strong>网络接口</strong>：IP 包从哪个路由器接口发送出去。</li><li><strong>度量值</strong>：当有多条到达目的地的不同路径时，度量值越小表示优先级越高。</li></ol></li><li><p><strong>路由表转发过程</strong>：</p><ol><li><p>获得目的IP地址，首先将<strong>直连</strong>网络的网段和子网掩码(视作主机即可)相与，看是否匹配，若匹配则直接交付，否则间接交付转步骤2</p></li><li><p>若路由表有目的地址的路由信息，则直接给对应的下一跳路由器，否则转步骤3</p></li><li><p>对路由表每一行掩码与目的地址相与，匹配则根据路由表找到下一跳端口，不匹配则转步骤4</p></li><li><p>若有默认路由，走默认，若无，则报错</p></li><li><p>在使用CIDR后，查找路由表可能会得到多个匹配结果，选择最长网络前缀匹配，因为地址块小路由更具体！</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F20-17-35-c1ee807887c90d60f3a8685d3d70d25f-image-20240528221038065-7fa236.png" alt="image-20240528221038065"></p></li></ol></li><li><p><strong>ICMP</strong>：封装在IP包内，分差错报告与询问报文</p><p><img src="/post/c0060df1/Users\86166\AppData\Roaming\Typora\typora-user-images\image-20240528221122182.png" alt="image-20240528221122182"></p><ul><li><p>差错报文：分为终点不可达，超时，参数问题，源抑制（拥塞丢弃），重定向（下次发给另外的路由器）</p></li><li><p>询问报文：echo，请求时间</p></li><li><p><code>tracert</code>命令利用超时报文，TTL字段分别设为1，2，3…直至目的主机</p></li><li><code>ping</code>命令利用echo报文</li></ul></li></ul><h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h3><ul><li>静态算法即手动配置路由，不过多考虑。</li><li><p>动态算法包括老三位，距离向量（ospf）算法，链路状态（bgp，rip）算法；进一步按自治系统背景区分，IGP（ospf，rip），BGP（bgp）</p></li><li><p><strong>RIP（Routing Information Protocol）</strong>：</p><p><img src="/post/c0060df1/Users\86166\AppData\Roaming\Typora\typora-user-images\image-20240528221914620.png" alt="image-20240528221914620"></p><ul><li>距离定义：中间经过了多少个路由器，最长为15，16表示不可达。直接相连的距离为0。</li><li>仅和相邻路由器交换信息，交换的信息是当前本路由器知道的全部信息，即本路由器的路由表。</li><li><p>固定间隔时长交换一次。</p></li><li><p>工作流程 —— 使用 <strong>Bellman-Ford</strong>：</p><ol><li><p>收到相邻路由器X的一个RIP报文</p></li><li><p>将报文内全部的下一跳改为X，并把距离字段加一。每个项目内有三个关键信息：目的网络，距离，下一跳X</p></li><li><p>依次将其与自身路由表比较目的地址，若自身路由表无目的地址，则添加到自身路由表，否则转4</p></li><li><p>若自身路由表下一跳也为X，则使用RIP的替换，否则转5</p></li><li><p>若RIP的距离<strong>小于</strong>自身的距离，则添加到自身路由表，否则转6</p></li><li><p>Do nothing</p></li></ol></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F20-32-25-b7977b6f11a46f621417ca0ad5f60b1a-image-20240528222711369-a39fcc.png" alt="image-20240528222711369"></p><ul><li><strong>OSPF</strong>:     <ul><li>使用迪杰斯特拉算法</li><li>使用IP数据报发送</li><li>基本思路：各路由器间交换链路状态(本路由器和哪些路由器相邻，以及链路的度量距离)信息，每个路由器一个数据库，最终收敛为全网的路由器的数据库信息一致，即每个路由器拥有全网的拓扑结构图，并分别计算单源最短路径。</li></ul></li><li><strong>BGP</strong>：和OSPF在计网实验里无恶不作，但是理论应该不会考</li></ul><h2 id="传输层-——-数据段（Segment）"><a href="#传输层-——-数据段（Segment）" class="headerlink" title="传输层 —— 数据段（Segment）"></a>传输层 —— 数据段（Segment）</h2><ul><li>传输层主要作用：实现可靠传输，包括差错控制，顺序控制，拥塞控制等，以及实现应用进程间（端口）的逻辑通信。</li><li>常用协议类型与端口号：<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F20-42-34-dfae136209c62ce0e266e74bec0f2edf-image-20240528230338579-11f352.png" alt="image-20240528230338579"></li></ul><h3 id="UDP（User-DatagramProtocol）"><a href="#UDP（User-DatagramProtocol）" class="headerlink" title="UDP（User DatagramProtocol）"></a>UDP（User DatagramProtocol）</h3><ul><li><p>在ip层的协议类型为<strong>17</strong></p></li><li><p>首部：仅提供了端口和校验机制，使用全部信息（包含伪首部）进行校验</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F20-43-25-4d5b6034fa4fe0d94ee6da1c6d23316e-image-20240528230530951-439f15.png" alt="image-20240528230530951"></p></li></ul><h3 id="TCP（Transmission-Control-Protocol）"><a href="#TCP（Transmission-Control-Protocol）" class="headerlink" title="TCP（Transmission Control Protocol）"></a>TCP（Transmission Control Protocol）</h3><ul><li><p>可靠服务：无差错，不丢失，不重复，按序到达</p></li><li><p>全双工通信，面向字节流</p></li><li><p>首部：IP层的协议字段为<strong>6</strong></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F20-46-07-ffd76392e4a48f78cd6e5d72d114d760-image-20240528231256638-7e27ea.png" alt="image-20240528231256638"></p></li><li><p><strong>滑动窗口</strong>：以字节为单位的滑动窗口</p></li><li><p>发送窗口：对方未应答的情况下，可以连续把窗口内数据发送出去，不建议前沿收缩</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F20-46-41-280ffc92b835e1670a9dbf68937cab0f-image-20240529112836630-864c11.png" alt="image-20240529112836630"></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F20-46-49-90066018370da3093e3255456aa41be2-image-20240529113012521-9cc0fa.png" alt="image-20240529113012521"></p><p>接收窗口内的若没有按顺序收到，则可以先缓存，等31号到了以后统一上交，并将窗口后沿前移。    </p></li></ul><p><img src="/post/c0060df1/Users\86166\AppData\Roaming\Typora\typora-user-images\image-20240529113046934.png" alt="image-20240529113046934"></p><ul><li><p><strong>发送方的缓存与发送窗口的关联</strong>：发送缓存左边缘等于发送窗口左边缘，代表最后被确认的字节，应用进程发送时将数据靠右放进缓存中。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F20-47-52-e3eb91bf9126d8f90ec3b9d4140071c6-image-20240529120548493-ee5850.png" alt="image-20240529120548493"></p></li><li><p><strong>接收方的缓存与接收窗口的关联</strong>：接收窗口左边沿是下一个期望接收的字节（如果都按序到达则来一个左边沿往后推一个），接收窗口的左侧直至接收缓存左侧是已经按序接收但还未被应用层处理完的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F20-47-59-750aedfef111b2b10917242495091c90-image-20240529120138165-6f1925.png" alt="image-20240529120138165"></p><p><strong>区分发送缓存，接收缓存与发送接收窗口</strong>。缓存是和应用层处理速度等相关的，窗口是和传输层传输数据限制相关的。</p></li><li><p>超时重传：校验和+超时重传，加权RTT（动态调整RTT），超时重传时间设置为略大于RTT。RTT为往返时延，一个信号从发送再到收到对方ACK的总时间。</p></li><li><p><strong>流量控制</strong>：控制发送速率，使接收方来得及接收，报文中携带窗口大小字段，告知对方自己接收窗口的剩余大小，$发送方的发送窗口 = min{拥塞窗口，对方接收窗口}$。窗口是以字节为单位统计的，但是发送还是以最大报文段MSS为单位。</p></li><li><p><strong>拥塞控制</strong>：慢启动，拥塞避免，快重传，快恢复</p><ul><li><p>慢启动：试探性地从小到大增大发送窗口。若无拥塞，拥塞窗口增加，有堵塞减少。每经过一个传输轮次(等价于往返时间RTT)拥塞窗口加倍。</p></li><li><p>拥塞避免：阈值比较，每经历一个RTT加一。若出现了拥塞，则阈值改为此时发送方窗口的一半，拥塞窗口重新设置为1。</p></li><li><p>快重传，快恢复：每当接受方收到一个失序报文段，发出重复确认告知发送方。当发送方收到三个重复确认，则阈值减为当前拥塞窗口的一半，拥塞窗口也减半，直接进入拥塞避免阶段。</p></li></ul></li><li><p>可靠传输：校验和，序列号，确认号，超时重传和快速重传</p></li><li><p><strong>三次握手四次挥手</strong></p></li></ul><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><strong>ack：期望对方下条报文的seq值</strong></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F20-50-42-2d83d12224f1b97749c6da508ae2c574-image-20240510204706637-dfb657.png" alt="image-20240510204706637"></p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>连接释放时是双向的，A释放连接代表A没有向B发送的数据，而B发送数据A仍要接收，直至双方都没有要发送的数据时，B再释放连接。因此需要四次。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F20-50-56-7082e5b2f7e11aad0075c0fea8fe978e-image-20240510204912159-e90600.png" alt="image-20240510204912159"></p><ul><li><p>为什么握手要三次，挥手要四次（重中之重）：</p><ul><li>三次握手：要保证<strong>连接是双工的</strong>，<strong>至少</strong>要握手<strong>3</strong> <strong>次</strong>。如果握手 2 次，则只能保证服务器能收到客户端的信息，而不能保证客户端能收到服务器的信息；如果握手 4 次，则多余了。还有其他解释，如避免网络中的僵尸连接占用资源。</li><li>四次挥手：还是因为<strong>连接是双工</strong>的，<strong>前两次</strong>只是保证了客户端发送的数据传输完了，<strong>服务器需要等它发送的数据也传输完</strong>，再断开连接。</li></ul></li><li><p>为什么四次挥手时，客户端在发送ACK后需等待 <strong>2MSL</strong>：因为网络是不可靠的，客户端回复给服务器的<strong>ACK</strong> <strong>可能会丢失</strong>，如果丢失的话，服务器会重新发送 FIN，客户端需要等一会。</p></li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p><strong>为应用程序提供服务</strong>，通过网络套接字接口接入网络。</p><ul><li><p><strong>DNS（Domain Name System）</strong>：基于UDP</p><ul><li><p>树状域名结构，树状域名服务器结构：最后的是顶级域名 .cn 等</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F20-57-02-91cbc777012260bf1b6887e030fe6bbe-image-20240529125658591-7ee4c0.png" alt="image-20240529125658591"></p></li><li><p>流程：</p><ol><li><p>本机向本地域名服务器发送请求</p></li><li><p>本地域名服务器查找缓存/请求根域名服务器后返回：分为迭代法和递归法</p></li></ol></li></ul></li><li><p>FTP（File Transfer Protocol）：</p><ul><li>基于TCP，端口21</li><li>使用2个TCP连接，控制连接（传送请求）和数据连接（传送文件，仅传送时打开）</li></ul></li><li><p>WWW（World Wide Web， 万维网）：</p><ul><li>URL（Uniform Resource Locator，统一资源定位符）：http端口80，https端口443，不区分大小写</li></ul><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F20-59-25-5487a1a122542538b52ae1c3eae875b4-image-20240529130052537-1db824.png" alt="image-20240529130052537"></p><ul><li><p><strong>HTTP（Hyper Text Transfer Protocol，超文本传输协议）</strong>：基于TCP，无状态(服务器不记录客户端访问状态)，<strong>面向正文（text-oriented)</strong> </p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F21-00-03-b4a9354f483723c3aab3f384ece512b4-image-20240529130811659-5749da.png" alt="image-20240529130811659"></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F21-00-17-3ef48e430cb652b0d9e9e9c631b8fc1a-image-20240529130857413-ad4b4d.png" alt="image-20240529130857413"></p></li><li><p>HTTPS（Security）:  使用SSL（secure socket layer）/ TLS提供加密服务</p></li></ul></li><li><p>电子邮件协议：SMTP（发）（Simple Mail Transfer Protocol，简单邮件传输协议）和POP3（收）（Post Office Protocol version 3，邮局协议版本3）</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F20-55-04-b13329a5ef80df91a8a9e7970107186e-image-20240529131353541-3b9d9d.png" alt="image-20240529131353541"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 课内实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『数据库系统』与爱同航——系统实现文档</title>
      <link href="/post/67d293db.html"/>
      <url>/post/67d293db.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『数据库系统』与爱同航——系统实现文档"><a href="#『数据库系统』与爱同航——系统实现文档" class="headerlink" title="『数据库系统』与爱同航——系统实现文档"></a>『数据库系统』与爱同航——系统实现文档</h1><h1 id="系统实现文档"><a href="#系统实现文档" class="headerlink" title="系统实现文档"></a>系统实现文档</h1><h2 id="一、实现环境"><a href="#一、实现环境" class="headerlink" title="一、实现环境"></a>一、实现环境</h2><h3 id="1-1-客户端环境依赖"><a href="#1-1-客户端环境依赖" class="headerlink" title="1.1 客户端环境依赖"></a>1.1 客户端环境依赖</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue3&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;private&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite build&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;preview&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite preview&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eslint . --ext .vue,.js,.jsx,.cjs,.mjs --fix --ignore-path .gitignore&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@element-plus/icons-vue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;axios&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.5.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;element-plus&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.3.14&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mavon-editor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.10.4&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;echarts&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.4.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;pinia&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.1.6&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;undraw-ui&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.9.9&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.3.4&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vue-router&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.2.4&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@vitejs/plugin-vue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.3.4&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eslint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^8.49.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eslint-plugin-vue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^9.17.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vite&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.4.9&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>UI界面主要使用了Element-Plus，制图主要使用了Echarts，前端使用Vite+Vue3的框架进行开发。</p><h3 id="1-2-服务器端环境依赖"><a href="#1-2-服务器端环境依赖" class="headerlink" title="1.2 服务器端环境依赖"></a>1.2 服务器端环境依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot3<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>springboot3<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>17<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.7.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.poi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>poi-ooxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>数据库交互使用Mybatis框架，为锻炼数据库开发能力，<strong>所有数据库交互均通过手写SQL完成，而摒弃了目前流行的直接调打包好接口的形式</strong>。在Springboot3框架的基础上额外使用了一些实用插件，如Lombok，Hutool等。</p><h3 id="1-3-项目技术栈"><a href="#1-3-项目技术栈" class="headerlink" title="1.3 项目技术栈"></a>1.3 项目技术栈</h3><p>本项目基于Vite+Vue3，结合Element-Plus，Echarts作为前端技术栈，使用Springboot3集成Mybatis作为后端技术栈，数据库使用了适合大学生宝宝体制的MySql，并在购买的阿里云服务器内Docker环境下安装以便公共访问，同时我们在展示前将使用阿里云服务器结合Nginx进行代码的托管部署。版本管理工具为Gitee，接口测试软件为PostMan，数据库可视化软件为Navicat15，代码编写软件为Idea，数据库兼网站部署的服务器IP地址为：39.107.136.38，Gitee仓库地址为：<a href="https://gitee.com/database-assignment_1/database-assignment。">https://gitee.com/database-assignment_1/database-assignment。</a></p><h2 id="二、项目文件结构"><a href="#二、项目文件结构" class="headerlink" title="二、项目文件结构"></a>二、项目文件结构</h2><p>后端文件结构：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">src.main:</span> <span class="string">后端资源父级目录</span></span><br><span class="line"><span class="attr">java:</span> <span class="string">JAVA文件包</span></span><br><span class="line"><span class="attr">com.example:</span></span><br><span class="line"><span class="attr">config:</span> <span class="string">存放后端配置跨域请求等文件的文件夹</span></span><br><span class="line"><span class="attr">controller:</span> <span class="string">表现层文件夹，前后端交互的第一层。控制器负责接收请求并将其转发给对应的视图或服务进行处理,</span> <span class="string">负责处理请求的路由和参数验证</span></span><br><span class="line"><span class="attr">service:</span> <span class="string">服务层文件夹，前后端交互的第二层。该层负责处理用户请求的核心逻辑，并调用mapper层接口向数据库发起请求。</span></span><br><span class="line"><span class="attr">mapper:</span> <span class="string">映射层文件夹，前后端交互的第三层，也是直接和数据库打交道的层。该层用于向数据库发送各类请求，并得到返回数据，常配合xml文件共同使用</span></span><br><span class="line"><span class="string">entity：实体类文件夹，是数据库中的表属性的超集，还可能包含用于返回前端的额外信息</span></span><br><span class="line"><span class="attr">front:</span> <span class="string">返回前端的打包类文件夹，用于简化后端操作</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="string">其他资源文件包</span></span><br><span class="line">   <span class="string">application.yaml：</span> <span class="string">后端配置文件，配置数据库，上传文件大小格式等重要信息</span></span><br><span class="line"><span class="attr">mapper:</span> <span class="string">xml映射层文件夹，内含xml文件，处理较为复杂的SQL语句，与JAVA的mapper文件协同使用。</span></span><br></pre></td></tr></table></figure><p>前端文件结构：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">vue3:</span> <span class="string">前端资源父级目录</span></span><br><span class="line"><span class="string">public:存放一些静态文件，供前端网站使用</span></span><br><span class="line"><span class="string">src:前端主要文件目录</span></span><br><span class="line"><span class="string">assets:存放静态文件</span></span><br><span class="line"><span class="string">components:存放前端使用的组件</span></span><br><span class="line"><span class="string">icon:存放图标</span></span><br><span class="line"><span class="string">image:存放图片</span></span><br><span class="line"><span class="string">router:配置前端路由</span></span><br><span class="line"><span class="string">stores:存储多文件使用的功能函数</span></span><br><span class="line"><span class="string">style:存放css文件</span></span><br><span class="line"><span class="string">utils:配置request请求</span></span><br><span class="line"><span class="string">views:存放前端所有的模板文件</span></span><br></pre></td></tr></table></figure><h2 id="三、功能架构"><a href="#三、功能架构" class="headerlink" title="三、功能架构"></a>三、功能架构</h2><p>功能架构示意图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-20-38-a1c83a267d10d437f632a4be8d0b0035-1f9db8283a46676c440420cf0393a5f-13f7a0.png" alt></p><h3 id="3-1-灵魂匹配"><a href="#3-1-灵魂匹配" class="headerlink" title="3.1 灵魂匹配"></a>3.1 灵魂匹配</h3><p><strong>筛选条件:</strong></p><ul><li><p>自定义，自由多选</p></li><li><p>以我的标签为条件</p></li><li><p>清空条件</p></li></ul><p><strong>匹配结果:</strong></p><ul><li><p>包含信息：背景图、头像、昵称、详细信息、标签</p></li><li><p>申请好友：对中意的匹配对象发送好友申请</p></li><li><p>对象切换：不满意当前对象，点击切换下一个</p></li></ul><h3 id="3-2-用户中心"><a href="#3-2-用户中心" class="headerlink" title="3.2 用户中心"></a>3.2 用户中心</h3><p><strong>用户信息</strong></p><ul><li><p>展示信息：包括用户的背景图、头像、昵称、详细信息、标签</p></li><li><p>修改信息、上传图片：用户可以对自己的信息进行修改，支持头像、背景图的上传</p></li><li><p>申请好友/已是好友：用户可以对其他用户进行好友申请</p></li></ul><p><strong>帖子集</strong></p><ul><li><p>展示顺序：按时间排序由新到旧</p></li><li><p>操作：点赞、查看详情</p></li></ul><p><strong>照片墙</strong></p><ul><li>走马灯形式，将用户的所有照片循环播放</li></ul><h3 id="3-3-发布帖子-照片"><a href="#3-3-发布帖子-照片" class="headerlink" title="3.3 发布帖子/照片"></a>3.3 发布帖子/照片</h3><p><strong>新的帖子</strong></p><ul><li><p>文字内容</p></li><li><p>图片内容：支持多张图片的上传</p></li><li><p>查看权限：用户选择是否发布到广场</p></li></ul><p><strong>照片墙更新</strong></p><ul><li><p>原有图片管理</p><ul><li>查看大图：查看图片详情</li><li>删除图片：从原有照片中删去</li></ul></li><li><p>新图片添加</p></li></ul><h3 id="3-4-帖子详情"><a href="#3-4-帖子详情" class="headerlink" title="3.4 帖子详情"></a>3.4 帖子详情</h3><p><strong>帖子内容</strong></p><ul><li><p>发帖人信息</p></li><li><p>帖子文字信息</p></li><li><p>帖子图片信息</p></li></ul><p><strong>对帖子/评论的操作</strong></p><ul><li><p>点赞，点赞数</p></li><li><p>评论，评论数</p></li></ul><p><strong>评论区</strong></p><ul><li><p>支持多级评论</p></li><li><p>支持评论之间互相回复</p></li><li><p>排序：按热度、时间</p></li></ul><h3 id="3-5-消息"><a href="#3-5-消息" class="headerlink" title="3.5 消息"></a>3.5 消息</h3><p><strong>顶部导航栏提醒：</strong></p><ul><li>实时新消息数：以小红点的形式，提醒用户有新消息</li></ul><p><strong>回复我的：</strong></p><ul><li><p>跳转原始内容：点击跳转到回复的对象，支持内容定位，即跳转到网页的对应位置</p></li><li><p>点赞、评论：在消息页即可对回复信息进行操作</p></li></ul><p><strong>收到的赞：</strong></p><ul><li><p>跳转原始内容：点击跳转到回复的对象，支持内容定位，即跳转到网页的对应位置</p></li><li><p>跳转个人主页：点击头像，跳转到点赞者的个人主页</p></li></ul><p><strong>系统通知</strong></p><p><strong>新的朋友</strong></p><ul><li><p>申请信息：来自其他用户的打招呼内容</p></li><li><p>是否通过：用户可选择是否通过其他用户成为好友</p></li></ul><p><strong>申请通过</strong></p><h3 id="3-6-登陆注册"><a href="#3-6-登陆注册" class="headerlink" title="3.6 登陆注册"></a>3.6 登陆注册</h3><ul><li><p>登录：用户根据用户名和密码来进行登录，同时在登录界面中有提供注册的选项。只有通过登录才可以进入网站的界面</p></li><li><p>注册：用户在注册页面填写相关的信息，如果填写的信息合法的话，显示注册成功，用户的信息在数据库保存。</p></li><li><p>兴趣标签选择：在用户注册成功之后，用户进行兴趣标签的选择。兴趣标签是灵魂匹配的部分依据。</p></li></ul><h3 id="3-7-广场"><a href="#3-7-广场" class="headerlink" title="3.7 广场"></a>3.7 广场</h3><ul><li>在广场界面中我们可以看到网站中所有公开的帖子。支持只看好友帖子和看所有帖子的分类。同时支持对帖子进行热度排序和时间排序的选项。</li><li>对每一个帖子，都可以进行点赞操作和评论操作。点击评论操作可以跳转到具体的帖子界面进行评论。</li></ul><h3 id="3-8-聊天"><a href="#3-8-聊天" class="headerlink" title="3.8 聊天"></a>3.8 聊天</h3><ul><li><p>在界面的左侧是好友列表。显示出当前用户的所有好友。同时在好友的姓名旁边显示当前用户和好友的未读信息。</p></li><li><p>右侧是和好友的聊天界面。显示当前用户和好友的所有聊天消息。用户可以和好友在这里发送消息。</p></li><li><p>支持好友亲密度显示，显示当前的亲密度数字和亲密度等级。</p></li></ul><h3 id="3-9-后台数据显示"><a href="#3-9-后台数据显示" class="headerlink" title="3.9 后台数据显示"></a>3.9 后台数据显示</h3><p>如果当前用户是管理员身份，则可以进入后台管理界面。</p><h4 id="3-9-1-主页信息统计"><a href="#3-9-1-主页信息统计" class="headerlink" title="3.9.1 主页信息统计"></a>3.9.1 主页信息统计</h4><ul><li>可以查看网站的访问流量统计</li><li>可以查看当前网站的每一个界面单独的访问流量</li></ul><h4 id="3-9-2-信息管理"><a href="#3-9-2-信息管理" class="headerlink" title="3.9.2 信息管理"></a>3.9.2 信息管理</h4><h5 id="3-9-2-1-基本信息管理"><a href="#3-9-2-1-基本信息管理" class="headerlink" title="3.9.2.1 基本信息管理"></a>3.9.2.1 基本信息管理</h5><ul><li><p>用户信息管理：在这里可以查看每个用户的信息，同时可以编辑用户的信息，以及进入其主页查看等</p></li><li><p>帖子信息管理：在这里可以查看到所有发布的帖子的信息，支持删除和编辑功能</p></li><li><p>图片信息管理：在这里可以查看到网站发布的所有图片的发送人，发送时间和图片的内容。支持删除功能。</p></li><li><p>标签信息管理：在这里可以查看到网站设置的个性标签的所有信息。支持修改标签信息和删除特定标签等。实现了标签的动态更新。</p></li><li><p>匹配交友信息管理：这里主要是针对灵魂匹配的信息统计。这里展示所有的灵魂匹配记录。同时对信息进行处理，统计出灵魂匹配的运行次数，平均成功率，使用次数最多的用户，一次匹配中发送好友申请最多的用户。</p></li><li><p>用户行为追踪：这里统计用户在网站的行为信息。统计出用户的行为比如点赞回复等操作，以及管理员发布公告等记录。</p></li></ul><h5 id="3-9-2-2-可视化数据展示"><a href="#3-9-2-2-可视化数据展示" class="headerlink" title="3.9.2.2 可视化数据展示"></a>3.9.2.2 可视化数据展示</h5><ul><li><p>用户信息可视化：这里以图表等形式展示出用户注册流量统计，用户男女比例，用户星座比例，用户家乡统计，活跃用户统计的功能。</p></li><li><p>帖子信息可视化：这里对帖子和评论的信息进行可视化。展示出帖子的热度排行，评论的热度排行。</p></li><li><p>社交信息可视化：这里统计的是与社交信息有关的消息。统计出用户的最大好友数以及所有用户的平均好友数，以直方图的形式展示。然后是亲密度统计。统计用户和好友的所有亲密度的最高值，以及所有亲密度，用直方图的形式展示。</p></li><li><p>社交网络图：通过统计每个用户的好友状态，展示出社交网络图，展现当前用户的社交关系。</p></li></ul><h4 id="3-9-3-公告管理"><a href="#3-9-3-公告管理" class="headerlink" title="3.9.3 公告管理"></a>3.9.3 公告管理</h4><p>​    管理员可以对所有的公告进行管理，包括编辑和删除的操作，同时管理员也可以在此界面发布公告。可以选择向特定的用户发布公告。</p><h4 id="3-9-4-图片生成（Bonus）"><a href="#3-9-4-图片生成（Bonus）" class="headerlink" title="3.9.4 图片生成（Bonus）"></a>3.9.4 图片生成（Bonus）</h4><p>​    通过对抗生成模型Pix2Pix，用户可以在网站中上传一个建筑物标签图片，模型会生成一张真实世界的图片，目前该功能仅供本地娱乐，后续可用此技术实现用户背景头像的生成与风格迁移。</p><h2 id="四、具体功能介绍"><a href="#四、具体功能介绍" class="headerlink" title="四、具体功能介绍"></a>四、具体功能介绍</h2><h3 id="4-1-个人主页"><a href="#4-1-个人主页" class="headerlink" title="4.1 个人主页"></a>4.1 个人主页</h3><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-18-55-2073d306509c0fe949de4212a58f40ab-1.1-67be88.png" alt="image-20231221160221612"></p><p><strong>信息：</strong></p><ul><li><p>左边：用户信息。从上到下依次为</p><ul><li><p>用户空间背景图</p></li><li><p>用户头像、昵称</p><ul><li>按钮<ul><li>修改信息：若该主页是当前登录用户的个人页面，显示修改信息按钮</li><li>申请/已为好友：若该主页和当前用户不同，两个用户未成为好友时显示申请好友按钮，否则显示已为好友按钮</li></ul></li></ul></li></ul></li></ul><ul><li><p>用户详细信息：如性别、个性签名、籍贯、学号、真实姓名、学院、年级等</p></li><li><p>用户标签：用户的个人标签，反应该用户的性格、爱好、经历等等。</p></li></ul><ul><li><p>右边：用户发布的所有帖子/照片</p><ul><li><p>帖子列表：按时间排序由新到旧，显示该用户发表过的所有帖子。每个帖子包括信息</p><ul><li>发帖信息：发帖人的头像、昵称，发帖时间</li><li>帖子的文字内容</li><li>帖子的图片内容：每三个图片一行</li><li>帖子点赞数、评论数</li></ul></li><li><p>照片墙：以走马灯形式展示，所有图片会自动循环展示。</p></li><li><p>帖子集和照片墙切换按钮</p></li></ul></li></ul><p><strong>功能：</strong></p><p><strong>修改个人信息：</strong></p><ul><li><p>默认输入为原有个人信息</p></li><li><p>学院支持联想输入，即输入学院名称的前几个字自动筛选出对应学院，方便快捷。</p></li><li><p>年级实现多选功能</p></li><li><p>头像和背景图可以点击替换，并在当前页面预览。</p></li><li><p>点击<code>下一页</code>/<code>上一页</code>换页，更改不同的信息。</p></li><li><p>个人标签可以多选，默认为原有标签</p></li><li><p>点击<code>提交修改</code>可以成功修改个人信息，点击<code>取消</code>或对话框外的任意位置可以关闭对话框。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-21-12-a19c712a0205f7a80a616eeab69fd2a4-1.2-cf69bf.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-21-29-ee2f82f6cbeaed661854eca398c13219-1.3-ab49d4.png" alt></p><p><strong>申请好友：</strong></p><p>对于非好友用户，点击<code>添加好友</code>，在弹出的输入框中输入内容，可以向该用户发送一条申请信息；好友用户则显示为<code>已是好友</code>，不能再发送申请信息。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-22-14-a465e08c73a3b88cacd2d482d3474e15-1.3.2-545053.png" alt="1.3.2" style="zoom:50%;"><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-22-04-198078dbc091d3b1d889cd4d1b49dae7-1.3.1-6c7525.png" alt="1.3.1" style="zoom:50%;"></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-18-57-bf37517c2392154f0e8c9d0bd11dc471-1.3.3-314010.png" alt="1.3.3" style="zoom:50%;"></p><p><strong>点赞帖子：</strong></p><p>​    点击<code>点赞</code>，会实时改变点赞状态和点赞数。若当前用户对该帖子点赞过，则显示为红色点赞图标，再次点击会取消点赞，点赞数减一；否则显示为白色点赞图标，点击后变红，点赞数加一。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-23-38-f0d66a3a9b529beb3fcdc434f9a0fb45-1.4-e47f4f.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-23-38-a0323cc5407176c96896700dc7fb72f5-1.5-80e488.png" alt></p><p><strong>查看帖子详情：</strong></p><p>​    点击<code>评论</code>按钮或者帖子图片（如果该帖子有图片内容的话），跳转到帖子详情页。</p><p><strong>帖子集和照片墙切换按钮：</strong></p><p>​    点击切换展示内容，默认为帖子集。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-18-58-77c1075b7f0a725c42d23e200fd993b4-1.6-df2ab4.png" alt="1.6"></p><p><strong>切换照片：</strong></p><p>​    可通过左右按钮或下方的进度条切换查看照片。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-23-58-07d85d4680210c4474e92ce7e4843804-1.7-fbab43.png" alt></p><h3 id="4-2-发布帖子-照片"><a href="#4-2-发布帖子-照片" class="headerlink" title="4.2 发布帖子/照片"></a>4.2 发布帖子/照片</h3><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-24-39-04153f6086693fabefc68c3f9bc84ae7-2.1-4056e3.png" alt></p><p><strong>信息：</strong></p><ul><li>新的帖子：从上到下依次为<ul><li>发表按钮</li><li>文字内容编辑区</li><li>图片内容编辑区</li><li>查看权限设置区</li></ul></li><li>照片墙更新：从上到下依次为<ul><li>发表按钮</li><li>原有图片管理区</li><li>新图片添加区</li></ul></li></ul><p><strong>功能：</strong></p><p><strong>功能切换：</strong></p><p>点击<code>新的帖子</code>/<code>照片墙更新</code>实现功能切换</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-18-59-4b11a9dc87327a6751b305814f00836f-2.2-c878d3.png" alt="2.2"></p><p><strong>原有照片管理：</strong></p><p>鼠标悬停在原有照片上，会出现 <code>放大</code> 和 <code>删除</code> 两个图标，点击触发对应功能。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-18-59-18225db0193045851e4813a9b4397092-2.3-58a911.png" alt="2.3"></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-25-01-1edd2547238bbd96f359bda84c7ea132-2.3.1-a67dc9.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-25-15-b1965012be5d8cbdcf677d98ab7a8c35-2.3.2-356d0b.png" alt></p><p><strong>添加新的图片：</strong></p><p>点击下方的 + 号，选择图片文件上传。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-19-01-1571ed56aa5164b26b045b294a621714-2.4-5250e9.png" alt="2.4"></p><p><strong>新的帖子：</strong></p><p>图片操作类似上述，图片右上角为绿色对钩说明上传成功；文字编辑区默认高度为3行，高度随输入变化，也可以手动调节高度（在红框处）；最下方可设置查看权限；右上角可发表帖子/发布修改后的照片墙。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-19-02-415cd0585898602bf8f616f181209d7c-2.5-e9ec91.png" alt="2.5"></p><h3 id="4-3-消息"><a href="#4-3-消息" class="headerlink" title="4.3 消息"></a>4.3 消息</h3><p><strong>导航栏最右：</strong></p><p>​    以红点形式显示实时消息数目，超过100条消息会显示为99+；若无新消息则不显示红点。</p><p><strong>消息页面：</strong></p><p><strong>A. 左侧为消息中心导航</strong></p><ul><li>分为5大部分，对应不同的消息类型；</li><li>若有新消息，会显示新消息对应条数，用户查看该模块时仍然保持，便于用户了解新消息条数，直到离开该模块才会消失。</li></ul><p><strong>B. 右侧为具体消息内容及操作：</strong></p><ul><li><p>回复我的：回复当前用户发布过的帖子/评论的消息。包括以下内容</p><ul><li>回复者的信息：头像、昵称</li><li>回复的对象：reply:xxx，即当前用户发布过的帖子/评论</li><li>回复的时间</li></ul><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-25-39-14dfd3cb6cc67e576988f36cee5d045f-3.1-8dd6e8.png" alt></p></li><li><p>收到的赞：点赞当前用户发布过的帖子/评论的消息。包括以下内容</p><ul><li>点赞者的信息：头像、昵称</li><li>点赞的对象：like:xxx，即当前用户发布过的帖子/评论</li></ul><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-19-04-d3cf28186c6be5b660682650a260718d-3.2-09ddcc.png" alt="3.2"></p></li><li><p>系统通知：由系统发布的消息。包括消息时间和消息内容</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-26-09-6ca0be4a3fcba5f890a049d2852b3bb5-3.3-ea25c9.png" alt></p></li><li><p>新的朋友：其他用户发来的交友申请</p><ul><li>申请者信息：头像、昵称</li><li>打招呼内容</li><li>时间</li><li>是否已添加该用户为好友</li></ul><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-19-05-139b9121fdb62366ffffa88b1a7074da-3.4-88be2f.png" alt="3.4"></p></li><li><p>申请通过：当前用户向其他用户发过的好友申请，若被其他用户通过，当前用户会收到申请通过提醒。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-26-40-1978c50ecc811151028a695db078fb76-3.5-1aa791.png" alt></p></li></ul><p><strong>功能：</strong></p><p><strong>通用功能：</strong></p><ul><li>点击用户头像跳转到该用户的个人主页</li><li>对单条消息的删除</li><li>对某一类型的所有消息清空</li></ul><p><strong>回复我的：</strong></p><ul><li><p>点击回复内容 <code>reply:xxx</code>，可以跳转到对应位置。</p><ul><li><p>若源内容为一个帖子，跳转到帖子的详情页。</p></li><li><p>若源内容为一个评论，跳转到回复所在的帖子详情页后，滑动到回复所在的位置。</p></li></ul></li></ul><p>  <img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-27-01-40cc873433abb846ff4125c960271a9c-3.6-c70777.png" alt></p><ul><li><p>对每条回复，可以进行点赞和评论，点赞效果实时显示。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-19-08-f88e7f394c968d48f64b40bdc346a165-3.7-103e92.png" alt="3.7"></p></li></ul><p><strong>收到的赞：</strong></p><ul><li>点击源内容 <code>like:xxx</code>，可以跳转到对应位置。</li></ul><p><strong>新的朋友：</strong></p><ul><li><p>若还未成为好友，点击 <code>通过</code> 按钮即可添加为好友</p></li><li><p>若已成为好友，显示为 <code>已通过</code> 按钮，不再进行操作。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-27-23-48d683ee34e0ad926174256f46368562-3.8-e54a2c.png" alt></p></li></ul><h3 id="4-4-帖子详情"><a href="#4-4-帖子详情" class="headerlink" title="4.4 帖子详情"></a>4.4 帖子详情</h3><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-27-58-1270e3d1862a06132c1a9e9c6986e931-4.1-fb8a1f.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-19-09-2432db58054f08426bdcdd58edbe5397-4.2-918368.png" alt="4.2"></p><p><strong>信息：</strong></p><ul><li>发帖者信息：头像、昵称</li><li>帖子信息：发帖时间、帖子的浏览量、点赞数、评论数</li><li>主评论框：显示当前用户的头像、输入评论的内容</li><li>评论区：包括一级评论和多级评论<ul><li>一级评论：直接对帖子进行评论</li><li>多级评论：<ul><li>显示：回复一级评论或回复一级评论下的其他评论，都显示在该一级评论下</li><li>被回复人：若直接回复一级评论，不显示被回复人；否则，在评论内容的最前面显示 @xxx，其中xxx为被回复人的昵称</li></ul></li><li>评论的互动信息：点赞数、评论数 (只在一级评论显示)</li></ul></li></ul><p><strong>功能：</strong></p><p><strong>点赞 帖子/评论</strong></p><p>点击对应位置的<code>点赞图标</code>，会实时改变点赞状态和点赞数。若当前用户对该 帖子/评论 点赞过，则显示为红色点赞图标，再次点击会取消点赞，点赞数减一；否则显示为白色点赞图标，点击后变红，点赞数加一。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-28-21-48fab4daa4a9c2fcaeea080a39aeef46-4.3-91531d.png" alt></p><p><strong>评论 帖子/评论：</strong></p><ul><li><p>帖子：</p><ul><li>点击主评论框，评论框会从灰色变成蓝色，聚焦于此，显示<code>发表评论</code>按钮，即可输入评论内容；</li><li>点击<code>发表评论</code>即可发布；</li><li>点击主评论框外任意位置，评论框会从蓝色变成灰色，取消聚焦，隐藏<code>发表评论</code>按钮</li><li><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-28-37-be7e2d57d2cbf33095b69366bb1402a9-4.4.1-972544.png" alt></li></ul></li><li><p>评论：点击任意评论的 评论图标，即可进行评论；再次点击 评论图标，或点击其他评论的 评论图标，即可关闭当前评论框。</p><ul><li><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-19-11-e66022f6bc6e7a375527356861e63795-4.4.2-a3d5b9.png" alt="4.4.2"></li><li><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-29-30-a7ba80780fa45ee07e1b9b532203c615-4.4.3-bc4020.png" alt></li></ul></li></ul><p><strong>评论排序：</strong></p><p>评论区的一级评论默认按照热度排序，点击右上角按钮，可以切换 按热度排序 或者 按时间排序。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-29-51-ca1f74c3d80a742a70fd198d14ca8231-4.5.1-072d40.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-19-12-ef7fad76b9f7479a523b3adb52bbd19c-4.5.2-db356c.png" alt="4.5.2"></p><h3 id="4-5-灵魂匹配"><a href="#4-5-灵魂匹配" class="headerlink" title="4.5 灵魂匹配"></a>4.5 灵魂匹配</h3><p><strong>信息：</strong></p><ul><li><p>选择标签页：用户可以选择自己感兴趣的标签，灵魂匹配会根据选择的标签来返回匹配列表。</p><ul><li>多个标签种类，每个种类下有多个标签，用户可自由选择</li><li><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-30-09-b02f71085b7b8bdc1a05ed3897ac6258-5.1-510395.png" alt></li></ul></li><li><p>匹配结果页：本次灵魂匹配的结果。</p><ul><li>左侧：对方用户的信息栏</li><li>右侧：对方用户的照片墙</li><li><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-30-22-b41a7471e2519778018b6df8db1b04f7-5.2-1bf16c.png" alt></li></ul></li></ul><p><strong>功能：</strong></p><p><strong>选择标签页：</strong></p><ul><li>多选：通过滑动纵向滚动条和横向滚动条，用户可自由多选标签。</li><li>我的：点击右上方 <code>我的标签</code> 按钮，可以选中所有当前用户的个性标签，以实现同类匹配。</li><li>清空：点击右上方 <code>清空选择</code> 按钮，可以清空当前已选标签，以重新进行选择。</li><li>匹配人数：点击右下角的 <code>- / +</code> 按钮，或直接在输入框中输入数字，可以选择匹配人数。若数字不合法，则不会进入匹配。</li><li>开始匹配：点击开始灵魂匹配，进入匹配结果页。</li></ul><p><strong>匹配结果页：</strong></p><ul><li>添加好友：匹配结果保证匹配到的对象都不是当前用户的好友。点击 <code>添加好友</code> 按钮，编辑申请信息后，即可发送好友申请。</li><li><p>切换照片：以走马灯形式展示，匹配对象的图片会自动循环展示。可通过图片左右小按钮或下方的进度条切换查看照片。</p></li><li><p>切换对象：点击页面左右大按钮，可切换当前匹配对象；一次匹配结果的匹配对象循环显示。</p></li></ul><h3 id="4-6-用户管理"><a href="#4-6-用户管理" class="headerlink" title="4.6 用户管理"></a>4.6 用户管理</h3><h4 id="4-6-1-登陆界面"><a href="#4-6-1-登陆界面" class="headerlink" title="4.6.1 登陆界面"></a>4.6.1 登陆界面</h4><p>登录的界面如下：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-19-14-8ae99dbd661302ceb353da66bfa7f648-154-17033345251092-140e79.jpg" alt="154"></p><p>前端调用login函数完成登录的整体逻辑操作。将当前用户填写的信息返回到后端，如果后端返回登陆成功后则将界面设置到主页。登录界面中可以点击“注册”进入到注册页面.</p><h4 id="4-6-2-注册界面"><a href="#4-6-2-注册界面" class="headerlink" title="4.6.2 注册界面"></a>4.6.2 注册界面</h4><p>注册界面如下：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-30-48-7d841c3c30322952274651821aa015f5-155-01718a.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-19-14-19cacef6583aeae1032aeaf6d9ba4f6c-158-d8a0bf.jpg" alt="158"></p><p> 前两页是用户的注册页面。用户输入表单的信息后，  前端将信息发送到后端，通过后端的返回值和前端的检查判断是否注册成功，如果注册成功就跳转到标签选择界面，如果注册失败就展示对应的弹窗然后跳转到第一页。</p><h4 id="4-6-3-兴趣标签选择"><a href="#4-6-3-兴趣标签选择" class="headerlink" title="4.6.3 兴趣标签选择"></a>4.6.3 兴趣标签选择</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-31-03-a05222f60341ddff6e5eab81870c905b-159-36fd2a.jpg" alt></p><p>进入到标签选择页面后，用户根据自身的兴趣和特性选取自己的标签。</p><h3 id="4-7-广场"><a href="#4-7-广场" class="headerlink" title="4.7 广场"></a>4.7 广场</h3><p>广场的主要功能是展示网站中所有公开的帖子，便于用户进行查看和交互。</p><p>广场的界面如下：</p><p>​    <img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-19-16-9269b8167d140d2214b8712328068844-160-96ceab.jpg" alt="160"></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-19-16-0a85485d039418d64a5148fcf1478be8-161-b20e25.jpg" alt="161"></p><p>广场界面获取当前所有公开的帖子并且展示。同时支持选择功能和筛选功能。选择功能是只看好友和看所有帖子。筛选功能是将帖子按照时间来排序，将贴子按照热度来排序。这里热度的计算逻辑是：<em>HOT  = 点赞量 x 5 + 评论数 x 10</em>。下图为排序的位置。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-31-34-9d818f795771349277d319f809e592da-image-20231223203420240-ebbe98.png" alt></p><h3 id="4-8-聊天"><a href="#4-8-聊天" class="headerlink" title="4.8 聊天"></a>4.8 聊天</h3><p>聊天界面主要用于用户好友列表的展示以及支持用户和好友的聊天功能。界面如下：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-31-48-1af65bcc5acabbe232d400fcc8d52863-163-1ad5b9.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-32-11-bf58434ccfe54a87d731d2ee652cedeb-164-1ce06d.jpg" alt></p><p>左侧是当前用户的好友列表，右侧是用户与选定好友的聊天界面。右面的聊天功能：聊天功能的逻辑是用户点击发送后，后端接收到message并且存储到数据库中，然后前端按照相对较短的频率反复获取数据库中的message，实时的展示两个人之间的聊天功能。下图展示聊天的过程。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-32-38-8b588435ee3d8dcc9feb9b0a7ff1436e-198-a62576.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-32-38-75b51d5194d459f5580406b98ebc66cf-199-4e0a35.jpg" alt></p><p>可以发现消息成功发送。</p><p><strong>未读消息</strong>：我们为好友聊天加入了未读信息的逻辑。当当前用户没有看过好友发的消息时，界面将显示。当用户点击相应的好友时，未读消息的界面将消失。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-19-18-fe6c3a1463e1ff2ae42b2fb54c164874-167-170333532348114-48d97f.jpg" alt="167"></p><p><strong>亲密度展示</strong>：我们针对好友之间的交流情况，给定了好友之间亲密度的概念。好友之间亲密度的公式如下： <em>私聊每条+2，点赞对方的帖子 +5，点赞对方的评论 +3，评论对方的帖子 +10，评论对方的评论 +7</em>。由此我们在chat界面展示与好友的亲密度。用不同的颜色代表不同的亲密度等级。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-33-03-2198d5a996b09b320f09f350ce56f192-168-cedc78.jpg" alt></p><p>具体亲密度等级和颜色的对应关系为</p><div class="table-container"><table><thead><tr><th>亲密度（curIntimacy）</th><th>image</th></tr></thead><tbody><tr><td>curIntimacy &lt; 100</td><td>💛</td></tr><tr><td>100 &lt;= curIntimacy  &lt; 200</td><td>💙</td></tr><tr><td>200 &lt;= curIntimacy &lt; 300</td><td>💜</td></tr><tr><td>300 &lt;= curIntimacy &lt; 400</td><td>🧡</td></tr><tr><td>400 &lt;= curIntimacy &lt; 500</td><td>❤</td></tr><tr><td>500 &lt;= curIntimacy &lt; 600</td><td>💗</td></tr><tr><td>600 &lt;= curIntimacy &lt; 700</td><td>💘</td></tr><tr><td>curIntimacy &gt;= 700</td><td>💕</td></tr></tbody></table></div><p>curIntimacy作为friend的属性被同步更新，在每次点击好友时更新。</p><h3 id="4-9-后端数据显示"><a href="#4-9-后端数据显示" class="headerlink" title="4.9 后端数据显示"></a>4.9 后端数据显示</h3><p>数据展示区域是作为管理员权限，用于数据展示，数据管理，发布公告等功能的后台平台。</p><h4 id="4-9-1-网站数据展示"><a href="#4-9-1-网站数据展示" class="headerlink" title="4.9.1 网站数据展示"></a>4.9.1 网站数据展示</h4><p>主要是展示网站流量等相关内容。具体界面如下：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-19-18-f29ce4887d1ddcf5a71b8564bfff67b7-170-af3629.jpg" alt="170"></p><p>界面记录了网站访问流量统计和每个网页的访问流量信息统计。</p><h4 id="4-9-2-信息管理"><a href="#4-9-2-信息管理" class="headerlink" title="4.9.2 信息管理"></a>4.9.2 信息管理</h4><h5 id="用户信息管理"><a href="#用户信息管理" class="headerlink" title="用户信息管理"></a>用户信息管理</h5><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-33-50-09e1a1b701674cbb00572c741c64a646-173-ba6873.jpg" alt></p><p>该界面展示网站所有用户的信息。同时支持用户的新增，删除，编辑等操作。其中编辑操作的界面如图：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-33-50-c5f70ff5c3712630ce4fe8901f2f723d-174-a6bc9e.jpg" alt></p><p>同时支持用户信息的导入导出功能。可支持导入导出Excel文件的操作。导出的Excel的部分截图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-34-17-7e28db78f935c249e25cc5928ab6e0e0-175-a90292.jpg" alt></p><h5 id="帖子信息管理"><a href="#帖子信息管理" class="headerlink" title="帖子信息管理"></a>帖子信息管理</h5><p>主要进行帖子的管理等操作。页面如下：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-19-20-1ccb8a15c860ac943e4807b6fc407114-176-375f2a.jpg" alt="176"></p><p>帖子支持批量删除和导出功能。导出的excel文件如下：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-35-20-a67889c0635b61cdfd51b7b6f46b2875-177-ea3848.jpg" alt></p><p>同时帖子支持搜索功能。可以根据帖子的内容或者帖子的作者来筛选出相对应的帖子。下面是示例：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-36-10-d7266f6b2c5dddfa2a2d6aa5f9a9292b-178-51daa8.jpg" alt></p><p>支持单个参数和多个参数进行搜索。查看详情按钮会跳转进对应的帖子动态路由。</p><h5 id="图片信息管理"><a href="#图片信息管理" class="headerlink" title="图片信息管理"></a>图片信息管理</h5><p>图片管理主要是展示网站中用户发的所有图片，可以对图片进行操作。界面如下：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-19-21-004833a5a5f4aa7bb26f3d7b1ce49480-180-d3e02a.jpg" alt="180"></p><p>同样的，界面支持图片的删除以及搜索功能。搜索示例如下：</p><p>!<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-36-57-023739cd45ddfeca3884c222137556f3-181-133e28.jpg" alt></p><h5 id="标签信息管理"><a href="#标签信息管理" class="headerlink" title="标签信息管理"></a>标签信息管理</h5><p>标签信息管理的功能是提供对当前兴趣标签的增删查改。界面如下：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-19-22-1fd1d8ae0fc76d52fdcbd9d8194d128a-184-0eb14d.jpg" alt="184"></p><p>​    同样提供标签的搜索功能，新增标签，删除标签，修改标签，导入导出等功能。</p><h5 id="匹配交友信息管理"><a href="#匹配交友信息管理" class="headerlink" title="匹配交友信息管理"></a>匹配交友信息管理</h5><p>这里主要是展示灵魂匹配界面所实现的功能。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-37-23-9696862e0241cd5f1f39e85221d74452-186-ca48fa.jpg" alt></p><p>可以看到，这里记录了网站所有使用灵魂匹配的记录，以及关于灵魂匹配的一些统计数据。</p><h5 id="用户行为追踪"><a href="#用户行为追踪" class="headerlink" title="用户行为追踪"></a>用户行为追踪</h5><p>这里主要是记录用户的行为记录，比如点赞，评论等行为，以及管理员的行为等。同样支持搜索功能。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-37-40-3ae74fc5f8fa3deac51fd9c7595bfe15-187-160647.jpg" alt></p><p><strong>行为类型分为：like,reply,system,success,friend</strong></p><h4 id="4-9-3-可视化数据展示"><a href="#4-9-3-可视化数据展示" class="headerlink" title="4.9.3 可视化数据展示"></a>4.9.3 可视化数据展示</h4><p>这里主要分为用户信息可视化，帖子信息可视化，社交信息可视化。</p><p><strong>用户信息可视化</strong></p><p>我们分别对用户的注册流量，用户的男女比例，用户的星座比例，用户的家乡地，以及活跃用户流量做出可视化统计，通过可视化用户数据我们可以更好地挖掘数据特征，同时分析网站的实时运营情况。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-38-07-be9f2c7157ab0aaec08f84071e75680c-188-f7db3b.jpg" alt></p><p><strong>帖子信息可视化</strong></p><p>我们分别就帖子热度最高前20名与评论热度最高的前20名进行统计排序，并展示出实时热度与对应路由，便于管理员快速查看，可以将其理解为一种“<strong>热搜榜单</strong>”。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-19-24-bf8e72026c9432ebdbad41a78e51bf86-189-5d4922.jpg" alt="189"></p><p><strong>社交信息可视化</strong></p><p>我们就每个人的好友数与好友间的亲密度绘制直方图，直观的查看用户的交友行为，同时我们支持自由调节最小值与直方图间距，进行不同粒度的统计。在图表最上方会展示出一些统计量，比如亲密度最高的两人，我们会实时追踪这些<strong>最值</strong>，如若最后二人因本网站结缘并牵手成功，这将是我们的荣幸。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-38-27-8406378a3ec6649cce3339bb57ddfb3e-202-e117b6.jpg" alt></p><p>同样我们就用户间联系绘制社交网络图，支持鼠标缩放与自由拖动，节点处展示用户姓名，可以更好的查看    好友间联系甚至是一些具有完全图属性的<strong>“小团体”</strong>，又或是一个好友都没有的<strong>”孤家寡人“</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-38-47-4c73f3d8798191c7d9c53ba80b9c3a68-204-c522ac.jpg" alt></p><h4 id="4-9-4-发布管理员公告"><a href="#4-9-4-发布管理员公告" class="headerlink" title="4.9.4 发布管理员公告"></a>4.9.4 发布管理员公告</h4><p>管理员可以在这里选择成员发布管理员公告，同样可以看到当前发布的所有公告，支持删除以及导出等功能。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-39-07-74870440672609b484391087a389bc25-192-832e69.jpg" alt></p><p>同时管理员可以在这里发布公告，支持选择指定人发送或全选所有人发送，在考虑用户人数增多时产生的难以寻找指定目标问题，我们对此也增加了用户名检索功能。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2F2024%2F10%2F12%2F18-19-25-14a6b7c94d865ce6716a03f52db0bf5b-img-6db3d7.png" alt="img.png"></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-19-25-20fb8820a9ceb80c8bd5855b7505c6af-195-eeb0b1.jpg" alt="195"></p><p>发布后可以实时看到公告，支持按照通知时间和接收人数排序。</p><h4 id="4-9-5-背景生成"><a href="#4-9-5-背景生成" class="headerlink" title="4.9.5 背景生成"></a>4.9.5 背景生成</h4><p>我们使用pix2pix对抗网络生成模型，在云服务器上进行部署。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-19-27-aa1abcf28349654acfa9f75bc3ef9201-e0737f24fa387b22d02e4b5872b8092-dfe6e3.png" alt="e0737f24fa387b22d02e4b5872b8092"></p><p>不仅增加了趣味性，也为未来的用户生成自己的背景等场景提供了一种可行的方式。</p><h2 id="五、部分源代码说明"><a href="#五、部分源代码说明" class="headerlink" title="五、部分源代码说明"></a>五、部分源代码说明</h2><h3 id="5-1-聊天功能代码实现"><a href="#5-1-聊天功能代码实现" class="headerlink" title="5.1 聊天功能代码实现"></a>5.1 聊天功能代码实现</h3><p> 那么首先是获取好友列表的代码逻辑。</p><p> 前端代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getFriends</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    request.<span class="title function_">get</span>(<span class="string">&quot;/chat/friend&quot;</span>, &#123;<span class="attr">params</span>: &#123;<span class="attr">uid</span>: <span class="title class_">Id</span>&#125;&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (res.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        friendList.<span class="title function_">splice</span>(<span class="number">0</span>); <span class="comment">// 清空 friendList，确保它是响应式的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> friend <span class="keyword">of</span> res.<span class="property">data</span>) &#123;</span><br><span class="line">          friendList.<span class="title function_">push</span>(friend); <span class="comment">// 逐个添加好友到 friendList</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">resolve</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(&#123;</span><br><span class="line">          <span class="attr">message</span>: <span class="string">&quot;好友列表导入失败&quot;</span>,</span><br><span class="line">          <span class="attr">showClose</span>: <span class="literal">false</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="title function_">reject</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">getFriendsInfo</span><span class="params">(Integer uid)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> chatMapper.getFriendsInfo(uid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sql代码</span></span><br><span class="line"><span class="meta">@Select(&quot;select u.id, u.nickname, u.avatarUrl, f.intimacy from user u inner join friend f on f.userId1 = u.id and f.userId2 = #&#123;uid&#125; or f.userId2 = u.id and f.userId1 = #&#123;uid&#125;&quot;)</span></span><br></pre></td></tr></table></figure><p>然后是右面的聊天功能：聊天功能的逻辑是用户点击发送后，后端接收到message并且存储到数据库中，然后前端按照相对较短的频率反复获取数据库中的message，实时的展示两个人之间的聊天功能。</p><p>具体实现代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">Initial</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">getFriends</span>(); <span class="comment">// 使用 await 等待异步操作完成</span></span><br><span class="line">  curFriendId = friendList[<span class="number">0</span>].<span class="property">id</span>;</span><br><span class="line">  <span class="comment">//curNickName = friendList[0].nickname;</span></span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">getRecords</span>();</span><br><span class="line">  <span class="keyword">await</span> request.<span class="title function_">post</span>(<span class="string">&quot;/chat/readAll?senderId=&quot;</span> + <span class="title class_">Id</span> + <span class="string">&quot;&amp;receiverId=&quot;</span> + curFriendId)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="comment">// 处理响应</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">getUnReadMessage</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">onMounted</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Initial</span>(); <span class="comment">// 使用 await 等待 Initial() 函数执行完毕</span></span><br><span class="line">  <span class="built_in">setInterval</span>(getRecords, <span class="number">500</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">nextTick</span>()</span><br><span class="line">  <span class="title function_">scrollToBottom</span>()</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//获取聊天记录的逻辑</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getRecords</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> prevFriendList = recordList.<span class="property">value</span></span><br><span class="line">  fresh.<span class="property">value</span>++;</span><br><span class="line">  fresh.<span class="property">value</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (isClick) &#123;</span><br><span class="line">    <span class="keyword">await</span> request.<span class="title function_">get</span>(<span class="string">&quot;/chat/getChatRecord&quot;</span>, &#123;<span class="attr">params</span>: &#123;<span class="attr">uid</span>: <span class="title class_">Id</span>, <span class="attr">friendId</span>: curFriendId&#125;&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (res.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        records = res.<span class="property">data</span>;</span><br><span class="line">        recordList.<span class="property">value</span> = res.<span class="property">data</span>[<span class="string">&quot;chats&quot;</span>];</span><br><span class="line">        <span class="comment">// console.log(recordList)</span></span><br><span class="line">        <span class="keyword">if</span> (recordList.<span class="property">value</span>.<span class="property">length</span> !== prevFriendList.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">scrollToBottom</span>();</span><br><span class="line">          &#125;, <span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(&#123;</span><br><span class="line">          <span class="attr">message</span>: <span class="string">&quot;好友列表导入失败&quot;</span>,</span><br><span class="line">          <span class="attr">showClose</span>: <span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (flag.<span class="property">value</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// await nextTick()</span></span><br><span class="line">      <span class="comment">// document.body.offsetHeight;</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">scrollToBottom</span>();</span><br><span class="line">      &#125;, <span class="number">500</span>);</span><br><span class="line">      flag.<span class="property">value</span> = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-广场的选择和筛选帖子功能"><a href="#5-2-广场的选择和筛选帖子功能" class="headerlink" title="5.2  广场的选择和筛选帖子功能"></a>5.2  广场的选择和筛选帖子功能</h3><p>筛选功能是将帖子按照时间来排序，将贴子按照热度来排序。这是两种排序方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sortByTime</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(onBoardList.<span class="property">value</span>);</span><br><span class="line">  onBoardList.<span class="property">value</span>.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> timeA = <span class="keyword">new</span> <span class="title class_">Date</span>(a.<span class="property">time</span>);</span><br><span class="line">    <span class="keyword">const</span> timeB = <span class="keyword">new</span> <span class="title class_">Date</span>(b.<span class="property">time</span>);</span><br><span class="line">    <span class="keyword">return</span> timeB - timeA;</span><br><span class="line">  &#125;);</span><br><span class="line">  fresh1.<span class="property">value</span>--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sortByHot</span>(<span class="params"></span>) &#123;</span><br><span class="line">  onBoardList.<span class="property">value</span>.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value1 = a.<span class="property">clickNum</span> * <span class="number">5</span> + a.<span class="property">commentNum</span> * <span class="number">10</span>;<span class="comment">//算出入读</span></span><br><span class="line">    <span class="keyword">let</span> value2 = b.<span class="property">clickNum</span> * <span class="number">5</span> + b.<span class="property">commentNum</span> * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> value2 - value1;</span><br><span class="line">  &#125;);</span><br><span class="line">  fresh1.<span class="property">value</span>--;<span class="comment">//fresh1用于模板实时响应</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是选择功能。选择功能是只看好友和看所有帖子。代码逻辑如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">changeOnlyFriend</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">getFriends</span>();</span><br><span class="line">  onBoardList.<span class="property">value</span> = [];</span><br><span class="line">  <span class="comment">//console.log(allPosts.value);</span></span><br><span class="line">  <span class="comment">//console.log(friendList);</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> post <span class="keyword">of</span> allPosts.<span class="property">value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">isFriend</span>(post.<span class="property">userId</span>)) &#123;</span><br><span class="line">      onBoardList.<span class="property">value</span>.<span class="title function_">push</span>(post);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fresh1.<span class="property">value</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getFriends</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    request.<span class="title function_">get</span>(<span class="string">&quot;/chat/friend&quot;</span>, &#123; <span class="attr">params</span>: &#123; <span class="attr">uid</span>: userId &#125; &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (res.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        friendList.<span class="title function_">splice</span>(<span class="number">0</span>); <span class="comment">// 清空 friendList，确保它是响应式的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> friend <span class="keyword">of</span> res.<span class="property">data</span>) &#123;</span><br><span class="line">          friendList.<span class="title function_">push</span>(friend); <span class="comment">// 逐个添加好友到 friendList</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">resolve</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(&#123;</span><br><span class="line">          <span class="attr">message</span>: <span class="string">&quot;好友列表导入失败&quot;</span>,</span><br><span class="line">          <span class="attr">showClose</span>: <span class="literal">false</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="title function_">reject</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、系统重要功能实现"><a href="#六、系统重要功能实现" class="headerlink" title="六、系统重要功能实现"></a>六、系统重要功能实现</h2><h3 id="6-1-鉴权实现"><a href="#6-1-鉴权实现" class="headerlink" title="6.1 鉴权实现"></a>6.1 鉴权实现</h3><h4 id="6-1-1-本地保存登录信息"><a href="#6-1-1-本地保存登录信息" class="headerlink" title="6.1.1 本地保存登录信息"></a>6.1.1 本地保存登录信息</h4><p>为了鉴别用户身份，我们采用本地保存 userInfo 作为用户的唯一标识。用户登录后，服务器校验用户身份并返回用户信息；客户端中储存该信息，并在相应的请求中在请求头中附带 userInfo 中的部分信息，以示身份；最终，服务器根据用户身份进而返回数据。<br>除此之外，userInfo 还可以作为标识用户是否登录的载体，因为只有登录过的用户，才会记录不为空的 userInfo。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XXX.vue</span></span><br><span class="line"><span class="comment">//localStorage保存当前登录信息</span></span><br><span class="line"><span class="keyword">const</span> userInfo = res.<span class="property">data</span>;</span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;user&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(userInfo));</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="comment">//全局保存的用户信息</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;user&#x27;</span>)) || <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (user) &#123;</span><br><span class="line">    app.<span class="property">config</span>.<span class="property">globalProperties</span>.<span class="property">$user</span> = user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-1-2-路由守护"><a href="#6-1-2-路由守护" class="headerlink" title="6.1.2 路由守护"></a>6.1.2 路由守护</h4><p>为了防止用户未登录直接通过网址访问个人中心页等等，我们设置网页的全局路由守卫。此处的逻辑采用前置守卫，即在进入每个页面前检测用户是否登录，从而显示给用户正确的内容。</p><p>对于需要用户登录页面，只需在 route 路由文件中设置其 meta 路由元信息，将其中 requireLogin 属性置为 true。触发前置路由时，会首先检测当前页面 requireLogin  属性是否为true，如果为 true，则将未登录用户路由到登录界面，以提醒用户需要先登录才能访问当前页面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="comment">// 添加导航守卫</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isLogin = user!=<span class="literal">null</span><span class="comment">/* 根据您的实际情况获取用户登录状态 */</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;isLogin&quot;</span> + isLogin);</span><br><span class="line">    <span class="keyword">if</span> (to.<span class="property">matched</span>.<span class="title function_">some</span>(<span class="function"><span class="params">record</span> =&gt;</span> record.<span class="property">meta</span>.<span class="property">requireLogin</span>)) &#123;</span><br><span class="line">        <span class="comment">// 如果路由需要身份验证，并且用户未登录，则重定向到登录页面</span></span><br><span class="line">        <span class="keyword">if</span> (isLogin) &#123;</span><br><span class="line">            <span class="title function_">next</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果路由不需要身份验证，则继续正常导航</span></span><br><span class="line">        <span class="title function_">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//rounter.js</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&#x27;/chat&#x27;</span>,</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;chat&quot;</span>,</span><br><span class="line"><span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/match/ChooseTag.vue&#x27;</span>),</span><br><span class="line"><span class="attr">meta</span>: &#123;<span class="attr">title</span>: <span class="string">&quot;选择标签&quot;</span>, <span class="attr">requireLogin</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-推荐算法"><a href="#6-2-推荐算法" class="headerlink" title="6.2 推荐算法"></a>6.2 推荐算法</h3><p>我们提出了带权重的杰卡德相似度算法，可以更好的根据每个标签权重的不同进行灵魂匹配，我们认为存在着一些<strong>与众不同的独特标签，可以是小众爱好，又或者是宗教信仰</strong>，一旦二人匹配到此标签，则应该赋予更大的权重。我们默认起始标签权重皆为1，后续管理员可进行更改。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E7%B3%BB%E7%BB%9F%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%2Fdbhw%E6%96%87%E6%A1%A3.assets%2F2024%2F10%2F12%2F18-39-50-3fc3eb105659a2551a705d3bcc31b2a6-200-401063.jpg" alt></p><p>具体的代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Pair&lt;List&lt;User&gt;, Integer&gt; <span class="title function_">match</span><span class="params">(Integer uid, List&lt;Integer&gt; labelIds, Integer num)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.getUserById(uid).get(<span class="number">0</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">targetSex</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (user.getSex()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;男&quot;</span>: &#123;</span><br><span class="line">                targetSex = <span class="string">&quot;女&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;女&quot;</span>: &#123;</span><br><span class="line">                targetSex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;兄弟你什么性别&quot;</span>);</span><br><span class="line">                targetSex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到候选者</span></span><br><span class="line">        List&lt;Integer&gt; friends = friendMapper.getUserAllFriendId(uid);</span><br><span class="line">        List&lt;User&gt; targetUsers = userMapper.getUsersBySex(friends, uid, targetSex);</span><br><span class="line">        List&lt;Label&gt; labels = labelMapper.getLabels(); <span class="comment">// 得到所有标签</span></span><br><span class="line">        HashMap&lt;Integer, Float&gt; label2weight = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Label label : labels) &#123;</span><br><span class="line">            label2weight.put(label.getId(), label.getWeight());</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(labelIds);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为候选者打分</span></span><br><span class="line">        <span class="keyword">for</span> (User targetUser : targetUsers) &#123;</span><br><span class="line">            List&lt;Integer&gt; targetLabelIds = labelMapper.getUserLabelList(targetUser.getId());</span><br><span class="line">            <span class="comment">// 度量两个集合的相似度</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">divide</span> <span class="operator">=</span> <span class="number">0</span>, divided = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 受杰卡德相似系数的启发(交集 / 并集)，我们提出了自己的相似度计算方法，我们(管理员)为每个标签赋予权重(0~1)，在此基础上计算(并集 * 各项权重 / 交集 * 各项权重)</span></span><br><span class="line">            Set&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(targetLabelIds);</span><br><span class="line">            Set&lt;Integer&gt; combine = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); <span class="comment">// 并集</span></span><br><span class="line">            combine.addAll(set2);</span><br><span class="line">            combine.addAll(set1);</span><br><span class="line">            Set&lt;Integer&gt; intersection = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); <span class="comment">// 交集</span></span><br><span class="line">            <span class="keyword">for</span> (Integer integer : set1) &#123;</span><br><span class="line">                <span class="keyword">if</span> (set2.contains(integer)) &#123;</span><br><span class="line">                    intersection.add(integer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Integer i : intersection) &#123;</span><br><span class="line">                divided += label2weight.get(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Integer i : combine) &#123;</span><br><span class="line">                divide += label2weight.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (divide != <span class="number">0</span>) &#123;</span><br><span class="line">                targetUser.setScore(divided / divide);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                targetUser.setScore(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 降序排序</span></span><br><span class="line">        Collections.sort(targetUsers);</span><br><span class="line"></span><br><span class="line">        num = targetUsers.size() &gt; num ? num : targetUsers.size();</span><br><span class="line">        targetUsers = targetUsers.subList(<span class="number">0</span>, num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得照片集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            targetUsers.get(i).setImageBoardUrls(imageBoardMapper.getImageBoardUrlsByUid(targetUsers.get(i).getId()));</span><br><span class="line">        &#125;</span><br><span class="line">        matchMapper.addSoulMatch(uid, num);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">matchId</span> <span class="operator">=</span> matchMapper.getCurMatchId();</span><br><span class="line">        <span class="keyword">return</span> Pair.of(targetUsers, matchId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-文件上传"><a href="#6-3-文件上传" class="headerlink" title="6.3 文件上传"></a>6.3 文件上传</h3><p>我们的文件上传方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line"><span class="keyword">public</span> RestBean <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestParam</span> MultipartFile file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 设置保存路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileUploadPath</span> <span class="operator">=</span> <span class="string">&quot;vue3\\public\\image\\&quot;</span>;</span><br><span class="line">    <span class="comment">// MultipartFile  多媒体文件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">originalFileName</span> <span class="operator">=</span> file.getOriginalFilename();</span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> FileUtil.extName(originalFileName);</span><br><span class="line">    <span class="comment">// 为文件重命名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> IdUtil.fastSimpleUUID();</span><br><span class="line">    <span class="type">String</span> <span class="variable">fileUUID</span> <span class="operator">=</span> uuid + <span class="string">&quot;.&quot;</span> + type;</span><br><span class="line">    <span class="type">File</span> <span class="variable">uploadFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(fileUploadPath + fileUUID);</span><br><span class="line">    <span class="comment">//先上传文件到磁盘</span></span><br><span class="line">    FileUtils.copyInputStreamToFile(file.getInputStream(), uploadFile);</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;/public/image/&quot;</span> + fileUUID;</span><br><span class="line">    <span class="comment">// 返回给前端 on-success 方法中</span></span><br><span class="line">    <span class="keyword">return</span> RestBean.success(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码实现了文件上传的功能。它接收上传的文件，将文件保存到指定路径下，并返回文件的URL给前端。    目前由于需求原因，我们的网站只使用了图片上传，但是通过这个方法可以实现文件上传以及视频上传的功能。</p><h3 id="6-4-动态路由匹配"><a href="#6-4-动态路由匹配" class="headerlink" title="6.4 动态路由匹配"></a>6.4 动态路由匹配</h3><p>我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，在个人主页页面，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 <code>vue-router</code> 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">path</span>: <span class="string">&#x27;/personal&amp;uid:userId&#x27;</span>,</span><br><span class="line"><span class="attr">name</span>: <span class="string">&quot;PersonalPage&quot;</span>,</span><br><span class="line"><span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/user/PersonalPage.vue&#x27;</span>),</span><br><span class="line"><span class="attr">meta</span>: &#123;<span class="attr">title</span>: <span class="string">&quot;个人主页&quot;</span>, <span class="attr">requireLogin</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，访问id为1和id为5的用户主页，只需访问 <code>/personal&amp;uid1</code> 和 <code>/personal&amp;uid5</code> 即可。</p><p>需要注意的是，同一路由的不同参数不会引起界面的刷新，导致虽然切换到了 <code>/personal&amp;uid5</code> ，界面仍然显示 id 为1的用户信息。我们采用监视参数变化的方式，及时刷新页面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routeParams = <span class="title function_">ref</span>(router.<span class="property">currentRoute</span>.<span class="property">value</span>.<span class="property">params</span>);</span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    routeParams.<span class="property">value</span> = router.<span class="property">currentRoute</span>.<span class="property">value</span>.<span class="property">params</span>;</span><br><span class="line">    <span class="comment">// 在这里可以处理参数变化时的逻辑</span></span><br><span class="line">    <span class="keyword">if</span>(routeParams.<span class="property">value</span>.<span class="property">userId</span> !== userId) &#123;</span><br><span class="line">        <span class="comment">// 例如，你可以在这里触发重新加载数据的操作</span></span><br><span class="line">        location.<span class="title function_">reload</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &#123; <span class="attr">deep</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p>对于具体的 <code>/personal&amp;uid1</code> 和 <code>/personal&amp;uid5</code> 都可以匹配到这个路由， 对应的值都会设置到 $route.params 中，可以直接取出来使用，从而加载对应的用户信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userId = router.<span class="property">currentRoute</span>.<span class="property">value</span>.<span class="property">params</span>.<span class="property">userId</span>;</span><br></pre></td></tr></table></figure><h3 id="6-5-触发器"><a href="#6-5-触发器" class="headerlink" title="6.5.触发器"></a>6.5.触发器</h3><p>为简化开发者逻辑，并充分利用数据库系统，我们使用了触发器和函数等功能，进一步优化数据库设计。</p><p>在给帖子点赞/撤销赞时更新帖子的点赞量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> addPostLikeNum</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> like2post</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@likenum</span> :<span class="operator">=</span> (<span class="keyword">SELECT</span> likeNum <span class="keyword">from</span> post <span class="keyword">WHERE</span> id <span class="operator">=</span> new.postId); </span><br><span class="line"><span class="keyword">UPDATE</span> post <span class="keyword">SET</span> likeNum <span class="operator">=</span> <span class="variable">@likenum</span> <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> i</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> delPostLikeNum</span><br><span class="line">BEFORE <span class="keyword">DELETE</span> <span class="keyword">ON</span> like2post</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@likenum</span> :<span class="operator">=</span> (<span class="keyword">SELECT</span> likeNum <span class="keyword">from</span> post <span class="keyword">WHERE</span> id <span class="operator">=</span> old.postId); </span><br><span class="line"><span class="keyword">UPDATE</span> post <span class="keyword">SET</span> likeNum <span class="operator">=</span> <span class="variable">@likenum</span> <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> old.postId;</span><br><span class="line">ENDd <span class="operator">=</span> new.postId;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>在给评论点赞/撤销赞时更新评论的点赞量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> addCommentLikeNum</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> like2comment</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@likenum</span> :<span class="operator">=</span> (<span class="keyword">SELECT</span> likeNum <span class="keyword">from</span> `comment` <span class="keyword">WHERE</span> id <span class="operator">=</span> new.commentId); </span><br><span class="line"><span class="keyword">UPDATE</span> `comment` <span class="keyword">SET</span> likeNum <span class="operator">=</span> <span class="variable">@likenum</span> <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> new.commentId;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> delCommentLikeNum</span><br><span class="line">BEFORE <span class="keyword">DELETE</span> <span class="keyword">ON</span> like2comment</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@likenum</span> :<span class="operator">=</span> (<span class="keyword">SELECT</span> likeNum <span class="keyword">from</span> `comment` <span class="keyword">WHERE</span> id <span class="operator">=</span> old.commentId); </span><br><span class="line"><span class="keyword">UPDATE</span> `comment` <span class="keyword">SET</span> likeNum <span class="operator">=</span> <span class="variable">@likenum</span> <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> old.commentId;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>帖子下发表/删除评论更新帖子的评论量:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> addCommentNum</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> `comment`</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@commentnum</span> :<span class="operator">=</span> (<span class="keyword">SELECT</span> commentNum <span class="keyword">from</span> post <span class="keyword">WHERE</span> id <span class="operator">=</span> new.replyPostId);</span><br><span class="line">IF new.replyCommentId <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span></span><br><span class="line"> <span class="keyword">UPDATE</span> post <span class="keyword">SET</span> commentNum <span class="operator">=</span> <span class="variable">@commentnum</span> <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> new.replyPostId;</span><br><span class="line"><span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> delCommentNum</span><br><span class="line">BEFORE <span class="keyword">DELETE</span> <span class="keyword">ON</span> `comment`</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@commentnum</span> :<span class="operator">=</span> (<span class="keyword">SELECT</span> commentNum <span class="keyword">from</span> post <span class="keyword">WHERE</span> id <span class="operator">=</span> old.replyPostId);</span><br><span class="line">IF old.replyCommentId <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span></span><br><span class="line"> <span class="keyword">UPDATE</span> post <span class="keyword">SET</span> commentNum <span class="operator">=</span> <span class="variable">@commentnum</span> <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> old.replyPostId;</span><br><span class="line"><span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>评论下增加评论时更新评论的评论量:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> addCommentNum2Comment</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> `comment`</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@commentnum</span> :<span class="operator">=</span> (<span class="keyword">SELECT</span> commentNum <span class="keyword">from</span> `comment` <span class="keyword">WHERE</span> new.replyCommentId <span class="keyword">is</span></span><br><span class="line"><span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">and</span> id <span class="operator">=</span> new.replyCommentId);</span><br><span class="line">IF <span class="variable">@commentnum</span> <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span></span><br><span class="line"> <span class="keyword">UPDATE</span> `comment` <span class="keyword">SET</span> commentNum <span class="operator">=</span> <span class="variable">@commentnum</span> <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span></span><br><span class="line">new.replyCommentId;</span><br><span class="line"><span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p><strong>YuKi</strong>：</p><p>与爱同航从第四周开始起步，一直到十六周堂堂完结，这一路上有太多的心血，太多的收获和感动。在这将近三个月的时间中，与爱同航从立项开始到如今已经长成了参天大树，而我们三个也在开发网站的过程中收获了知识。</p><p>那么与爱同航是怎么诞生的呢？我还记得是一天晚上闲逛，杨博文跟我说，要不咱数据库做一个恋爱交友网站，解决一下我的个人问题，我一想这挺好啊，既做了作业又有了女朋友，这不是一举两得吗。于是欣然应允。所以与爱同航是带着大家的期望和一点小小的私心诞生的。</p><p>于是每周约研讨室的日子开始了。让我印象比较深的是第一次开会<strong>大家分析需求和设计表</strong>。大家调研了多种恋爱软件，列出我们的需求，并且根据数据库表的格式进行优化，并且最终生成了设计文档。而我觉得这是我们开发过程目标比较明确的原因。万事开头难，一定要从开头就设计好。</p><p>我们的核心机制是<strong>灵魂匹配功能</strong>，大家为了这个功能也做了很多的调研，最终决定了根据兴趣标签，使用带权重的杰卡德相似度算法来进行推荐，做出了很好的效果。</p><p>与爱同航是我们我们三个人第一次一起开发的网站，我们都对此投入了足够的热诚，我相信，在我们的心里与爱同航已经不是作为一个作业存在了，而是个人生涯中的一个里程碑和记忆中浓墨重彩的一笔。</p><p>最后非常感谢刘瑞老师的教导和助教的帮助。以一首诗作结吧：<strong>新故相推书画卷，丹青妙手向翠峰</strong>。希望与爱同航帮助更多的人获得幸福！</p><p><strong>Yang</strong>：</p><p>从9.12号建群，到12.24号我在进行最后的系统文档审查，这一路走来的确经历了太多，我们应当算启动的较早的组，在第四周很多人没组好队时我们就已经勾搭上了，然而还是开发到了ddl前的最后一天。</p><p>开发过程中，由于和开发组的另外二位都是一起并肩作战过的老熟人了，因此彼此交流比较顺畅，想法思路也比较一致，我们花的最多的时间是在<strong>前期准备</strong>上，从为整活提出恋爱交友网站开始，到认真起来去分析功能，设计数据库，再到进行开发时间规划安排，将功能和数据库整理成文档，再到购买服务器配置开发环境，编写接口文档，这一切的一切已经接近于实际的开发流程，事实同样证明，<strong>好的准备是成功的一半</strong>，在后续的开发过程中，除了大家第一次写Vue代码时遇到的细小问题，几乎没有出现过其他问题。在提交时我也会一同附上所有文档。</p><p>本网站的功能类似大多数交友网站，在其基础上增加了自己的创新，无论如何，本网站共计JAVA(3800)+CSS(600)+JS(500)+Vue(9200)+Xml(300)约1万5千行源码，加上各类设计报告与文档，Gitee上共提交200余次，主楼研讨室每月每人都会约满，可以说它占据了我们大三上的大部分时间(和编译五五开吧)，投入了彼此最宝贵的心血，诚然该网站还有许多值得优化之处，但对于一份数据库大作业而言，我对最后成果满意到无以复加。</p><p>要说经历此次开发我收获最大的是什么，那便是团队合作中交流的重要性，以前在六系都是一个人(和jkm)单打独斗，借由数据库课程第一次亲身参与了团队开发，也理解了计算机人不只是需要Coding能力，交流能力也同样关键。最后感谢苗姐与宇骏的辛苦付出，<strong>旅途总有终点</strong>，希望我们还有下次合作的机会，respect了家人们。</p><p>在后续我们会将网站部署到公网，希望（也许）能够帮助大家找到真爱。</p><p><strong>MorningTxT</strong>：</p><p>从9.24在gitee上成立仓库，到10.29开始正式的登录注册页面编写，再到12.23微调结束、彻底收尾，数据库大作业也像过山车一样，进度忽快忽慢，方向忽上忽下，然而柳暗花明，过山车也终于平稳落地。</p><p>以评论区的开发为例。虽然在最初就已经确定了需要实现二级评论功能，但真正实践起来，却是一波三折。第一次我先是自己手搓了一个丑丑的评论区，但因为没有参考，各大网站的实现方法八仙过海，令我在排版布局和实际功能实现的时候也顾左顾右，进度缓慢。某一天突发奇想，直接在百度上搜索vue3中的评论区实现，找到了一个名为 Undraw UI 的组件库，其中完美地实现了评论区的丰富功能，令人大喜过望，我们立即将其投入到自己的网站中使用。然而好景不长，先是发现由于该组件集成度太高，数据的输入输出高度规范化，列表套列表的复杂结构给后端同学带来了不小的压力；中间又发现了该组件的 bug ，在QQ群中给开发者提供反馈；后是在消息功能的实现中，发现该组件无法获得 回复/点赞 对应的原评论，而这是实现消息功能的基石。于是开始第三遍的评论区重写，以 Undraw UI 的排版布局为参考，实现了点击聚焦评论框、点击弹出评论框、回复对象昵称高亮、最新/最热排序等特色功能。在此之后，还经历了评论换行符的错误显示等小小风波。不过努力终有回报，在消息界面跳转到原内容的实现上，通过给每条评论增加锚点的方式，成功实现了对应位置的跳转滑动，成果喜人。</p><p>相较于其他组的手忙脚乱，我很高兴能和两位有热情、负责任、有能力的优秀同学一起合作，齐心合作、深入讨论、互相勉励，将学期初的宏伟蓝图落地为美观使用的具体项目，经历了一次愉快的团队开发。</p><p>在此，由衷地感谢组内每一个成员，没有他们的辛苦付出，也没有我们今天的成功；也感谢老师和助教的大力支持，我们希望能得到你们的认可，为本课程画上一个完美的句号。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 前后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『数据库系统』与爱同航——系统设计文档</title>
      <link href="/post/5146ab18.html"/>
      <url>/post/5146ab18.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『数据库系统』与爱同航——系统设计文档"><a href="#『数据库系统』与爱同航——系统设计文档" class="headerlink" title="『数据库系统』与爱同航——系统设计文档"></a>『数据库系统』与爱同航——系统设计文档</h1><h2 id="一-需求分析"><a href="#一-需求分析" class="headerlink" title="一. 需求分析"></a>一. 需求分析</h2><h3 id="1-1-需求描述"><a href="#1-1-需求描述" class="headerlink" title="1.1 需求描述"></a>1.1 需求描述</h3><h4 id="1-1-1-背景调研"><a href="#1-1-1-背景调研" class="headerlink" title="1.1.1 背景调研"></a>1.1.1 背景调研</h4><p>大学生进入大学以后，随着心理和生理的逐渐成熟，加之大学学习，生活压力减小，课余时间相对增多，大学生们会开始春心萌动，对异性产生爱慕之情，据统计相当大部分的大学生在大学最想得到的便是一场甜甜的恋爱，却由于各种阻碍的屡屡碰壁，使大家纷纷变成了“看破红尘，专心学术”的卷卷怪，这些阻碍包括但不限于，兴趣爱好不合，性格不合，聊不到一起去，人品不行，被渣男/渣女伤害，甚至有人“出师未捷身先死”，永远嘴上说着想找一个志同道合的恋人，却又永远由于各种原因跨不出最关键的第一步。</p><p>无论如何，整体大学生的恋爱情况稳中向好，无需我们过度担心。回归到日夜陪伴我们的母校，北京航天航空大学，一所纯正的理工科大学，一间纯正的人才加工厂。一进入到你航就仿佛徜徉在了知识的海洋，在如此情况下，大学生的恋爱问题日益突出，据开发组人员就六系计算机学院众人的恋爱经历与态度统计，有<strong>68</strong>%的人从未谈过恋爱，有23%的人正在谈恋爱，其余人并不愿意透露更多信息，猜测是受到过情伤；而进一步对68%并未谈过恋爱的同学进行调查，<strong>87</strong>%的同学对爱情充满着向往，进一步探寻原因，其中<strong>37</strong>%的同学认为在六系难以接触更多的异性而自身并未积极行动，<strong>27</strong>%的同学的伴侣要求较高，难以找到兴趣相投三观相投的伴侣，<strong>20</strong>%的同学认为在六系压力过大，更无从谈起恋爱，其余部分人还存在诸如认为自己交际能力差，容貌焦虑等等因自身原因而不敢开启一段恋爱的情况；另外13%未谈过恋爱的同学似乎对爱情并无渴望，看似清心寡欲，然而这类人同样将是我们的受众群体。</p><p>即使六系同学们并不能完全代表北航的整体情况，但仍具备不小参考价值。我们认为一个面向北航在校大学生的安全，自由，便捷的在线恋爱交友平台值得被开发并加以推广。</p><h3 id="1-1-2-用户画像"><a href="#1-1-2-用户画像" class="headerlink" title="1.1.2 用户画像"></a>1.1.2 用户画像</h3><p>本网站将<strong>自由</strong>作为核心主旨，我们的用户身份仅划分两类，一是使用网站进行各项活动的<strong>普通用户</strong>，二是网站的<strong>运维管理人员(下称管理员)</strong>。</p><h4 id="1-1-3-用户需求"><a href="#1-1-3-用户需求" class="headerlink" title="1.1.3 用户需求"></a>1.1.3 用户需求</h4><p>根据总结，我们对于北航用户的用户需求整理有下：</p><ol><li>能够接触到较多志同道合的异性</li><li>能够频繁进行沟通(忽略微信，qq等交友软件)</li><li>能够全方位展示自己，发表自己关于恋爱或其他事情的想法观点，并被青睐你的人发现</li><li>拥有足够的社交属性</li><li>希望存在命中注定的缘分，来与另一半梦幻相遇</li></ol><h4 id="1-1-4-其他需求"><a href="#1-1-4-其他需求" class="headerlink" title="1.1.4 其他需求"></a>1.1.4 其他需求</h4><p>同样，对于一个完整的网站，仅考虑用户需求过于片面，我们同样需要针对网站开发，维护，管理层面进行考量，总结其他需求如下。</p><ol><li>网站安全性需要得到保证，即使我们并未过多涉及敏感信息</li><li>网站管理员能够查看各类统计信息</li><li>网站管理员需要对用户相关数据信息进行管理，审查，删除等操作</li><li>用户之间的交互需要被及时通知</li><li>其他功能应与大多社交平台保持一致</li></ol><h4 id="1-1-5-设计理想"><a href="#1-1-5-设计理想" class="headerlink" title="1.1.5 设计理想"></a>1.1.5 设计理想</h4><p>我们与爱同行开发组鼓励同学们在大学在学习之余积极参与社交活动，积极勇敢追求中意的对象，使自己的大学生活留下一抹青春靓丽的痕迹。我们同样对北航当下情况深表惋惜，并励志对北航六系乃至全北航的恋爱环境做出变化，为北航同学搭建出一个安全、健康、方便的在线恋爱交友平台，以促进交友和校园内的恋爱文化，满足大学生的社交需求。</p><p>在设计过程中，我们参考了微博，抖音，B站等社交网站，Soul，青藤之恋，陌陌等恋爱交友网站，并加以融会贯通进我们的平台，希望我们的恋爱交友平台能够得到大家的使用与信赖。</p><p>制作组成员Yang，morningTxT，Yukiemi致上。</p><h3 id="1-2-数据流图"><a href="#1-2-数据流图" class="headerlink" title="1.2 数据流图"></a>1.2 数据流图</h3><h4 id="1-2-1-用户注册登录数据流图"><a href="#1-2-1-用户注册登录数据流图" class="headerlink" title="1.2.1 用户注册登录数据流图"></a>1.2.1 用户注册登录数据流图</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2FBlog%2F2024%2F10%2F12%2F18-07-24-5563911626bcf19bc88ed6a4f2998094-img_16-6b4aad.png" alt></p><h4 id="1-2-2-用户维护个人信息数据流图"><a href="#1-2-2-用户维护个人信息数据流图" class="headerlink" title="1.2.2 用户维护个人信息数据流图"></a>1.2.2 用户维护个人信息数据流图</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2FBlog%2F2024%2F10%2F12%2F18-07-38-81da27f5e92218aa3637838cce1dc912-img_22-35e490.png" alt></p><h4 id="1-2-3-用户间私密交友数据流图"><a href="#1-2-3-用户间私密交友数据流图" class="headerlink" title="1.2.3 用户间私密交友数据流图"></a>1.2.3 用户间私密交友数据流图</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2FBlog%2F2024%2F10%2F12%2F18-07-55-adf699923141b12c2a22a465a5e33d54-img_19-273ea2.png" alt></p><h4 id="1-2-4-用户间公共社交数据流图"><a href="#1-2-4-用户间公共社交数据流图" class="headerlink" title="1.2.4 用户间公共社交数据流图"></a>1.2.4 用户间公共社交数据流图</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2FBlog%2F2024%2F10%2F12%2F18-05-41-2142ba31df44e43d6a9a7ccb867454d4-img_23-290d27.png" alt="img_23.png"></p><h4 id="1-2-5-网站管理数据流图"><a href="#1-2-5-网站管理数据流图" class="headerlink" title="1.2.5 网站管理数据流图"></a>1.2.5 网站管理数据流图</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2FBlog%2F2024%2F10%2F12%2F18-08-33-3577655ddbe2eba20e953f140fafa0f1-img_17-32663e.png" alt></p><h4 id="1-2-6-网站整体数据流图"><a href="#1-2-6-网站整体数据流图" class="headerlink" title="1.2.6 网站整体数据流图"></a>1.2.6 网站整体数据流图</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2FBlog%2F2024%2F10%2F12%2F18-05-41-f88e75ebb2434624aff28e79e279bb5d-img_24-ad4c52.png" alt="img_24.png"></p><h3 id="1-3-数据元素表-附建表SQL"><a href="#1-3-数据元素表-附建表SQL" class="headerlink" title="1.3 数据元素表(附建表SQL)"></a>1.3 数据元素表(附建表SQL)</h3><p>共计15张表，为简便起见，我们每张表的主码皆为一个自增id，后续会建立其他候选码的索引。</p><h4 id="1-3-1-用户个人信息"><a href="#1-3-1-用户个人信息" class="headerlink" title="1.3.1 用户个人信息"></a>1.3.1 用户个人信息</h4><p><strong>User</strong>: 用户基本信息</p><div class="table-container"><table><thead><tr><th>字段名称</th><th>数据类型</th><th>可否为空</th><th>默认</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>NO</td><td>无</td><td>主键id</td></tr><tr><td>username</td><td>varchar(50)</td><td>NO</td><td>无</td><td>姓名</td></tr><tr><td>studentId</td><td>varchar(50)</td><td>NO</td><td>无</td><td>学号</td></tr><tr><td>password</td><td>varchar(50)</td><td>NO</td><td>无</td><td>密码</td></tr><tr><td>time</td><td>datetime</td><td>NO</td><td>NOW</td><td>注册时间</td></tr><tr><td>major</td><td>varchar(50)</td><td>NO</td><td>无</td><td>专业名</td></tr><tr><td>nickname</td><td>varchar(50)</td><td>NO</td><td>无</td><td>昵称</td></tr><tr><td>avatarurl</td><td>varchar(255)</td><td>NO(设置默认头像)</td><td>无</td><td>头像链接</td></tr><tr><td>backgroundUrl</td><td>varchar(255)</td><td>NO(设置默认背景)</td><td>无</td><td>背景链接</td></tr><tr><td>sex</td><td>varchar(2)</td><td>NO</td><td>无</td><td>性别</td></tr><tr><td>signature</td><td>varchar(50)</td><td>YES</td><td>无</td><td>个性签名</td></tr><tr><td>address</td><td>varchar(50)</td><td>NO</td><td>无</td><td>家乡</td></tr><tr><td>birthday</td><td>timestamp</td><td>NO</td><td>无</td><td>生日</td></tr><tr><td>role</td><td>varchar(10)</td><td>NO</td><td>普通用户</td><td>角色</td></tr></tbody></table></div><p>创建表SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;用户id&#x27;</span>,</span><br><span class="line">    `username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户姓名&#x27;</span>,</span><br><span class="line">    `password` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户密码&#x27;</span>,</span><br><span class="line">    `major` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户专业&#x27;</span>,</span><br><span class="line">    `studentId` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line">    `nickname` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;昵称&#x27;</span>,</span><br><span class="line">    `avatarUrl` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;头像Url&#x27;</span>,</span><br><span class="line">    `backgroundUrl` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;空间背景Url&#x27;</span>,</span><br><span class="line">    `sex` <span class="type">varchar</span>(<span class="number">2</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">    `signature` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;个性签名&#x27;</span>,</span><br><span class="line">    `address` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;地址，精确到省&#x27;</span>,</span><br><span class="line">    `grade` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;年级&#x27;</span>,</span><br><span class="line">    `birthday` <span class="type">timestamp</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;出生日期&#x27;</span>,</span><br><span class="line">    `role` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="string">&#x27;普通用户&#x27;</span> COMMENT <span class="string">&#x27;用户权限&#x27;</span>,</span><br><span class="line">    `<span class="type">time</span>` datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;注册时间&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">    ) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">152</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p><strong>Label</strong>: 用户标签</p><div class="table-container"><table><thead><tr><th>字段名称</th><th>数据类型</th><th>可否为空</th><th>默认</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>NO</td><td>无</td><td>主键id</td></tr><tr><td>type</td><td>varchar(50)</td><td>NO</td><td>无</td><td>标签类别</td></tr><tr><td>name</td><td>varchar(50)</td><td>NO</td><td>无</td><td>标签名称</td></tr><tr><td>weight</td><td>double</td><td>NO</td><td>无</td><td>标签权重</td></tr></tbody></table></div><p>创建表SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `label` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">    `type` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;标签类型&#x27;</span>,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;标签名称&#x27;</span>,</span><br><span class="line">    `weight` <span class="keyword">double</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">    ) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">93</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p><strong>Label2User</strong>: 用户与标签间关系</p><div class="table-container"><table><thead><tr><th>字段名称</th><th>数据类型</th><th>可否为空</th><th>默认</th><th>说明</th><th>外键</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>NO</td><td>无</td><td>主键id</td><td></td></tr><tr><td>userId</td><td>int</td><td>NO</td><td>无</td><td>用户id</td><td>user.id</td></tr><tr><td>labelId</td><td>int</td><td>NO</td><td>无</td><td>标签id</td><td>label.id</td></tr></tbody></table></div><p>创建表SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `label2user` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">    `userId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;uid&#x27;</span>,</span><br><span class="line">    `labelId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;lid&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">    KEY `fk_1` (`userId`),</span><br><span class="line">    KEY `fk_2` (`labelId`),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_1` <span class="keyword">FOREIGN</span> KEY (`userId`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_2` <span class="keyword">FOREIGN</span> KEY (`labelId`) <span class="keyword">REFERENCES</span> `label` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span></span><br><span class="line">    ) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">40</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p><strong>ImageBoard</strong>: 用户照片墙(图片与用户间联系)</p><div class="table-container"><table><thead><tr><th>字段名称</th><th>数据类型</th><th>可否为空</th><th>默认</th><th>说明</th><th>外键</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>NO</td><td>无</td><td>主键id</td><td></td></tr><tr><td>userId</td><td>int</td><td>NO</td><td>无</td><td>用户id</td><td>user.id</td></tr><tr><td>imgUrl</td><td>varchar(255)</td><td>NO</td><td>无</td><td>图片链接</td><td></td></tr><tr><td>time</td><td>datetime</td><td>NO</td><td>NOW</td><td>上传时间</td></tr></tbody></table></div><p>创建表SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `imageboard` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `userId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `imgUrl` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `<span class="type">time</span>` datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;根据当前时间戳更新？&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `f1` (`userId`),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `f1` <span class="keyword">FOREIGN</span> KEY (`userId`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>` (`id`)</span><br><span class="line">    ) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">18</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-用户交互信息"><a href="#1-3-2-用户交互信息" class="headerlink" title="1.3.2 用户交互信息"></a>1.3.2 用户交互信息</h4><p><strong>Post</strong>: 帖子信息</p><div class="table-container"><table><thead><tr><th>字段名称</th><th>数据类型</th><th>可否为空</th><th>默认</th><th>说明</th><th>外键</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>NO</td><td>无</td><td>主键id</td><td></td></tr><tr><td>time</td><td>datetime</td><td>NO</td><td>NOW</td><td>发帖时间</td><td></td></tr><tr><td>type</td><td>tinyint</td><td>NO</td><td>无</td><td>类型(公开至广场/仅个人空间可见)</td><td></td></tr><tr><td>content</td><td>varchar(10000)</td><td>NO</td><td>无</td><td>内容</td><td></td></tr><tr><td>top</td><td>tinyint</td><td>NO</td><td>0</td><td>是否个人空间内置顶</td><td></td></tr><tr><td>userId</td><td>int</td><td>NO</td><td>无</td><td>发表用户id</td><td>user.id</td></tr><tr><td>likeNum</td><td>int</td><td>NO</td><td>0</td><td>点赞量</td><td></td></tr><tr><td>clickNum</td><td>int</td><td>NO</td><td>0</td><td>访问量</td><td></td></tr><tr><td>commentNum</td><td>int</td><td>NO</td><td>0</td><td>一级评论量</td></tr></tbody></table></div><p>创建表SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `post` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;帖子Id&#x27;</span>,</span><br><span class="line">    `<span class="type">time</span>` datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;发帖时间&#x27;</span>,</span><br><span class="line">    `content` <span class="type">varchar</span>(<span class="number">10000</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `type` tinyint(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `likeNum` <span class="type">int</span>(<span class="number">11</span>) unsigned zerofill <span class="keyword">DEFAULT</span> <span class="string">&#x27;00000000000&#x27;</span> COMMENT <span class="string">&#x27;点赞数&#x27;</span>,</span><br><span class="line">    `clickNum` <span class="type">int</span>(<span class="number">11</span>) unsigned zerofill <span class="keyword">DEFAULT</span> <span class="string">&#x27;00000000000&#x27;</span> COMMENT <span class="string">&#x27;访问数&#x27;</span>,</span><br><span class="line">    `top` tinyint(<span class="number">1</span>) unsigned zerofill <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;1代表置顶 0代表不置顶&#x27;</span>,</span><br><span class="line">    `userId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户Id&#x27;</span>,</span><br><span class="line">    `commentNum` <span class="type">int</span>(<span class="number">11</span>) unsigned zerofill <span class="keyword">DEFAULT</span> <span class="string">&#x27;00000000000&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `user_id` (`userId`),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `user_id` <span class="keyword">FOREIGN</span> KEY (`userId`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">NO</span> ACTION</span><br><span class="line">    ) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">27</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p><strong>Comment</strong>: 评论信息</p><div class="table-container"><table><thead><tr><th>字段名称</th><th>数据类型</th><th>可否为空</th><th>默认</th><th>说明</th><th>外键</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>NO</td><td>无</td><td>主键id</td><td></td></tr><tr><td>time</td><td>datetime</td><td>NO</td><td>NOW</td><td>评论时间</td><td></td></tr><tr><td>userId</td><td>int</td><td>NO</td><td>无</td><td>评论用户id</td><td>user.id</td></tr><tr><td>replyCommentId</td><td>int</td><td>YES</td><td>无</td><td>评论的评论id</td><td>comment.id</td></tr><tr><td>replyPostId</td><td>int</td><td>NO</td><td>无</td><td>评论的帖子id</td><td>post.id</td></tr><tr><td>showId</td><td>int</td><td>YES</td><td>无</td><td>展示在哪条评论下</td><td>comment.id</td></tr><tr><td>content</td><td>varchar(255)</td><td>NO</td><td>无</td><td>评论内容</td><td></td></tr><tr><td>likeNum</td><td>int</td><td>NO</td><td>0</td><td>点赞量</td><td></td></tr><tr><td>commentNum</td><td>int</td><td>NO</td><td>0</td><td>评论量</td></tr></tbody></table></div><p>创建表SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `comment` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `userId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `<span class="type">time</span>` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `replyCommentId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `replyPostId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `content` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `likeNum` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    `showId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `commentNum` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `fk_11` (`userId`),</span><br><span class="line">    KEY `fk_21` (`replyCommentId`),</span><br><span class="line">    KEY `fk_31` (`replyPostId`),</span><br><span class="line">    KEY `fk_4` (`showId`),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_11` <span class="keyword">FOREIGN</span> KEY (`userId`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_21` <span class="keyword">FOREIGN</span> KEY (`replyCommentId`) <span class="keyword">REFERENCES</span> `comment` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_31` <span class="keyword">FOREIGN</span> KEY (`replyPostId`) <span class="keyword">REFERENCES</span> `post` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_4` <span class="keyword">FOREIGN</span> KEY (`showId`) <span class="keyword">REFERENCES</span> `comment` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span></span><br><span class="line">    ) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">141</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p><strong>Image2Post</strong>: 帖子图片信息</p><div class="table-container"><table><thead><tr><th>字段名称</th><th>数据类型</th><th>可否为空</th><th>默认</th><th>说明</th><th>外键</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>NO</td><td>无</td><td>主键id</td><td></td></tr><tr><td>postId</td><td>int</td><td>NO</td><td>无</td><td>帖子id</td><td>post.id</td></tr><tr><td>imgUrl</td><td>varchar(255)</td><td>NO</td><td>无</td><td>图片链接</td></tr></tbody></table></div><p>创建表SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `image2post` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `postId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `imgUrl` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `fk_post` (`postId`),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_post` <span class="keyword">FOREIGN</span> KEY (`postId`) <span class="keyword">REFERENCES</span> `post` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span></span><br><span class="line">    ) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">22</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p><strong>Like2Post</strong>: 帖子与点赞间关系</p><div class="table-container"><table><thead><tr><th>字段名称</th><th>数据类型</th><th>可否为空</th><th>默认</th><th>说明</th><th>外键</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>NO</td><td>无</td><td>主键id</td><td></td></tr><tr><td>postId</td><td>int</td><td>NO</td><td>无</td><td>帖子id</td><td>post.id</td></tr><tr><td>userId</td><td>int</td><td>NO</td><td>无</td><td>用户id</td><td>user.id</td></tr></tbody></table></div><p>创建表SQL:</p><pre><code>CREATE TABLE `like2post` (    `id` int(11) NOT NULL AUTO_INCREMENT,    `postId` int(11) DEFAULT NULL,    `userId` int(11) DEFAULT NULL,    PRIMARY KEY (`id`),    KEY `fk_like2post_1` (`userId`),    KEY `fk_like2post_2` (`postId`),    CONSTRAINT `fk_like2post_1` FOREIGN KEY (`userId`) REFERENCES `user` (`id`) ON DELETE SET NULL ON UPDATE SET NULL,    CONSTRAINT `fk_like2post_2` FOREIGN KEY (`postId`) REFERENCES `post` (`id`) ON DELETE SET NULL ON UPDATE SET NULL    ) ENGINE=InnoDB AUTO_INCREMENT=464 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;</code></pre><p><strong>Like2Comment</strong>: 评论与点赞间关系</p><div class="table-container"><table><thead><tr><th>字段名称</th><th>数据类型</th><th>可否为空</th><th>默认</th><th>说明</th><th>外键</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>NO</td><td>无</td><td>主键id</td><td></td></tr><tr><td>commentId</td><td>int</td><td>NO</td><td>无</td><td>评论id</td><td>comment.id</td></tr><tr><td>userId</td><td>int</td><td>NO</td><td>无</td><td>用户id</td><td>user.id</td></tr></tbody></table></div><p>创建表SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `like2comment` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `commentId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `userId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `fk_like2comment_1` (`commentId`),</span><br><span class="line">    KEY `fk_like2comment_2` (`userId`),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_like2comment_1` <span class="keyword">FOREIGN</span> KEY (`commentId`) <span class="keyword">REFERENCES</span> `comment` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_like2comment_2` <span class="keyword">FOREIGN</span> KEY (`userId`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span></span><br><span class="line">    ) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">186</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p><strong>Friend</strong>: 好友信息</p><div class="table-container"><table><thead><tr><th>字段名称</th><th>数据类型</th><th>可否为空</th><th>默认</th><th>说明</th><th>外键</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>NO</td><td>无</td><td>主键id</td><td></td></tr><tr><td>userId1</td><td>int</td><td>NO</td><td>无</td><td>好友一方id</td><td>user.id</td></tr><tr><td>userId2</td><td>int</td><td>NO</td><td>无</td><td>好友另一方id</td><td>user.id</td></tr><tr><td>intimacy</td><td>int</td><td>NO</td><td>0</td><td>好友亲密度</td><td></td></tr><tr><td>time</td><td>datetime</td><td>NO</td><td>NOW</td><td>成为好友时间</td><td></td></tr><tr><td>soulMatchId</td><td>int</td><td>YES</td><td>无</td><td>灵魂匹配id</td><td>soulMatch.id</td></tr></tbody></table></div><p>创建表SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `friend` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `userId1` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `userId2` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `intimacy` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    `<span class="type">time</span>` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;双方成为好友的时间&#x27;</span>,</span><br><span class="line">    `soulMatchId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `fk_friend_1` (`userId1`),</span><br><span class="line">    KEY `fk_friend_2` (`userId2`),</span><br><span class="line">    KEY `fk_friend_3` (`soulMatchId`),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_friend_1` <span class="keyword">FOREIGN</span> KEY (`userId1`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_friend_2` <span class="keyword">FOREIGN</span> KEY (`userId2`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_friend_3` <span class="keyword">FOREIGN</span> KEY (`soulMatchId`) <span class="keyword">REFERENCES</span> `soulmatch` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span></span><br><span class="line">    ) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">24</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p><strong>Chat</strong>: 好友间聊天信息</p><div class="table-container"><table><thead><tr><th>字段名称</th><th>数据类型</th><th>可否为空</th><th>默认</th><th>说明</th><th>外键</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>NO</td><td>无</td><td>主键id</td><td></td></tr><tr><td>senderId</td><td>int</td><td>NO</td><td>无</td><td>发送者id</td><td>user.id</td></tr><tr><td>receiverId</td><td>int</td><td>NO</td><td>无</td><td>接收者id</td><td>user.id</td></tr><tr><td>content</td><td>varchar(255)</td><td>NO</td><td>无</td><td>聊天内容</td><td></td></tr><tr><td>time</td><td>datetime</td><td>NO</td><td>NOW</td><td>发送消息时间</td><td></td></tr><tr><td>read</td><td>tinyint</td><td>NO</td><td>0</td><td>是否已读</td></tr></tbody></table></div><p>创建表SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `chat` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `<span class="type">time</span>` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `senderId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `receiverId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `content` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `read` tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `fk_chat_1` (`senderId`),</span><br><span class="line">    KEY `fk_chat_2` (`receiverId`),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_chat_1` <span class="keyword">FOREIGN</span> KEY (`senderId`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_chat_2` <span class="keyword">FOREIGN</span> KEY (`receiverId`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span></span><br><span class="line">    ) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">127</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p><strong>SoulMatch</strong>: 灵魂匹配信息(<strong>核心机制</strong>)</p><div class="table-container"><table><thead><tr><th>字段名称</th><th>数据类型</th><th>可否为空</th><th>默认</th><th>说明</th><th>外键</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>NO</td><td>无</td><td>主键id</td><td></td></tr><tr><td>userId</td><td>int</td><td>NO</td><td>无</td><td>用户id</td><td>user.id</td></tr><tr><td>matchNum</td><td>int</td><td>NO</td><td>无</td><td>匹配数量</td><td></td></tr><tr><td>sendApplicationNum</td><td>int</td><td>NO</td><td>0</td><td>发送请求数量</td><td></td></tr><tr><td>successNum</td><td>int</td><td>NO</td><td>0</td><td>成功添加好友数量</td><td></td></tr><tr><td>time</td><td>datetime</td><td>NO</td><td>NOW</td><td>发起时间</td></tr></tbody></table></div><p>创建表SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `soulmatch` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `userId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `matchNum` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `sendApplicationNum` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    `successNum` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    `<span class="type">time</span>` datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `fk_soul_1` (`userId`),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_soul_1` <span class="keyword">FOREIGN</span> KEY (`userId`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span></span><br><span class="line">    ) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">38</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><h4 id="1-3-3-全方位覆盖通知信息"><a href="#1-3-3-全方位覆盖通知信息" class="headerlink" title="1.3.3 全方位覆盖通知信息"></a>1.3.3 全方位覆盖通知信息</h4><p><strong>Notice</strong>: 涵盖各类型的通知信息，包括添加好友信息(friend)，成功添加好友信息(success)，收到回复信息(reply)，收到点赞信息(like)，管理员通告信息(system)。</p><div class="table-container"><table><thead><tr><th>字段名称</th><th>数据类型</th><th>可否为空</th><th>默认</th><th>说明</th><th>外键</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>NO</td><td>无</td><td>主键id</td><td></td></tr><tr><td>type</td><td>varchar(20)</td><td>NO</td><td>无</td><td>通知类型</td><td></td></tr><tr><td>time</td><td>datetime</td><td>NO</td><td>NOW</td><td>发送消息时间</td><td></td></tr><tr><td>read</td><td>tinyint</td><td>NO</td><td>0</td><td>是否已读</td><td></td></tr><tr><td>message</td><td>varchar(255)</td><td>NO</td><td>无</td><td>通知内容</td><td></td></tr><tr><td>isDelete</td><td>tinyint</td><td>NO</td><td>0</td><td>是否假删除</td><td></td></tr><tr><td>receiverId</td><td>int</td><td>NO</td><td>无</td><td>接收方用户id</td><td>user.id</td></tr><tr><td>senderId</td><td>int</td><td>NO</td><td>无</td><td>发送方用户id</td><td>user.id</td></tr><tr><td>replyPostId</td><td>int</td><td>YES</td><td>无</td><td>被回复/评论的帖子id</td><td>post.id</td></tr><tr><td>replyCommentId</td><td>int</td><td>YES</td><td>无</td><td>被回复/评论的评论id</td><td>comment.id</td></tr><tr><td>senderCommentId</td><td>int</td><td>YES</td><td>无</td><td>回复/评论的评论id</td><td>comment.id</td></tr><tr><td>managerAnnouncementId</td><td>int</td><td>YES</td><td>无</td><td>管理员通告id</td><td>managerAnnouncement.id</td></tr><tr><td>managerAnnouncementId</td><td>int</td><td>YES</td><td>无</td><td>灵魂匹配事件id</td><td>soulMatch.id</td></tr></tbody></table></div><p><strong>注</strong>: 本实体将多种通知类型糅合进一张表中，根据通知类型使用不同的外键描述，如此做减少了思考难度与设计难度，但增大了表的存储空间。</p><p>创建表SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `notice` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `type` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;好友 or 点赞 or 评论 or 管理员公告&#x27;</span>,</span><br><span class="line">    `<span class="type">time</span>` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `receiverId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;接收者user&#x27;</span>,</span><br><span class="line">    `senderId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `read` tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    `replyPostId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `message` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;通知信息&#x27;</span>,</span><br><span class="line">    `replyCommentId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `senderCommentId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `managerAnnouncementId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `isDelete` tinyint(<span class="number">1</span>) unsigned <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    `soulMatchId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `fk_notice_1` (`senderId`),</span><br><span class="line">    KEY `fk_notice_2` (`receiverId`),</span><br><span class="line">    KEY `fk_notice_3` (`replyPostId`),</span><br><span class="line">    KEY `fk_notice_4` (`replyCommentId`),</span><br><span class="line">    KEY `fk_notice_5` (`senderCommentId`),</span><br><span class="line">    KEY `fk_notice_6` (`managerAnnouncementId`),</span><br><span class="line">    KEY `fk_notice_7` (`soulMatchId`),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_notice_1` <span class="keyword">FOREIGN</span> KEY (`senderId`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_notice_2` <span class="keyword">FOREIGN</span> KEY (`receiverId`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_notice_3` <span class="keyword">FOREIGN</span> KEY (`replyPostId`) <span class="keyword">REFERENCES</span> `post` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_notice_4` <span class="keyword">FOREIGN</span> KEY (`replyCommentId`) <span class="keyword">REFERENCES</span> `comment` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_notice_5` <span class="keyword">FOREIGN</span> KEY (`senderCommentId`) <span class="keyword">REFERENCES</span> `comment` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_notice_6` <span class="keyword">FOREIGN</span> KEY (`managerAnnouncementId`) <span class="keyword">REFERENCES</span> `managerannouncement` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_notice_7` <span class="keyword">FOREIGN</span> KEY (`soulMatchId`) <span class="keyword">REFERENCES</span> `soulmatch` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span></span><br><span class="line">    ) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">494</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><p><strong>ManagerAnnouncement</strong>: 管理员公告信息</p><div class="table-container"><table><thead><tr><th>字段名称</th><th>数据类型</th><th>可否为空</th><th>默认</th><th>说明</th><th>外键</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>NO</td><td>无</td><td>主键id</td><td></td></tr><tr><td>time</td><td>datetime</td><td>NO</td><td>NOW</td><td>公告时间</td><td></td></tr><tr><td>userId</td><td>int</td><td>NO</td><td>无</td><td>管理员id</td><td>user.id</td></tr><tr><td>message</td><td>varchar(255)</td><td>NO</td><td>无</td><td>通告内容</td><td></td></tr><tr><td>receiverNum</td><td>int</td><td>NO</td><td>无</td><td>接收人数</td><td></td></tr><tr><td>type</td><td>varchar(20)</td><td>NO</td><td>无</td><td>通告类型(部分人/所有人)</td></tr></tbody></table></div><p>创建表SQL:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `managerannouncement` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `<span class="type">time</span>` datetime <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    `userId` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `message` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `receiverNum` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `type` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `fk_ma_1` (`userId`),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_ma_1` <span class="keyword">FOREIGN</span> KEY (`userId`) <span class="keyword">REFERENCES</span> `<span class="keyword">user</span>` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">SET</span> <span class="keyword">NULL</span></span><br><span class="line">    ) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">12</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure><h4 id="1-3-4-访问量记录信息"><a href="#1-3-4-访问量记录信息" class="headerlink" title="1.3.4 访问量记录信息"></a>1.3.4 访问量记录信息</h4><p><strong>Access</strong>: 记录各页面访问量信息</p><div class="table-container"><table><thead><tr><th>字段名称</th><th>数据类型</th><th>可否为空</th><th>默认</th><th>说明</th><th>外键</th></tr></thead><tbody><tr><td>id</td><td>int</td><td>NO</td><td>无</td><td>主键id</td><td></td></tr><tr><td>userId</td><td>int</td><td>NO</td><td>无</td><td>用户id</td><td>user.id</td></tr><tr><td>time</td><td>datetime</td><td>NO</td><td>NOW</td><td>发送消息时间</td><td></td></tr><tr><td>pageName</td><td>varchar(50)</td><td>NO</td><td>无</td><td>页面名称</td></tr></tbody></table></div><p>创建表SQL:</p><pre><code>CREATE TABLE `access` (    `id` int(11) NOT NULL AUTO_INCREMENT,    `userId` int(11) DEFAULT NULL,    `time` datetime DEFAULT NULL,    `pageName` varchar(50) COLLATE utf8mb4_unicode_ci DEFAULT NULL,    PRIMARY KEY (`id`),    KEY `fk_access_1` (`userId`),    CONSTRAINT `fk_access_1` FOREIGN KEY (`userId`) REFERENCES `user` (`id`) ON DELETE SET NULL ON UPDATE SET NULL    ) ENGINE=InnoDB AUTO_INCREMENT=991 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;</code></pre><h2 id="二-数据库概念模式设计"><a href="#二-数据库概念模式设计" class="headerlink" title="二. 数据库概念模式设计"></a>二. 数据库概念模式设计</h2><h3 id="2-1-实体ER图"><a href="#2-1-实体ER图" class="headerlink" title="2.1 实体ER图"></a>2.1 实体ER图</h3><p>我们共划分十个实体。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2FBlog%2F2024%2F10%2F12%2F18-10-26-7087338ac74e4dce94b436f7795d6035-img_3-f51c02.png" alt><br><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2FBlog%2F2024%2F10%2F12%2F18-10-43-d185058ef9466ebaf8fb6f08259b43f9-img_4-77c731.png" alt><br><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2FBlog%2F2024%2F10%2F12%2F19-33-09-aa51358055e6e2e21d9c5ba480e694e3-img_5-110dbb.png" alt><br><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2FBlog%2F2024%2F10%2F12%2F18-05-44-72d393e1428a315f8eb2988f66c826a5-img_6-c080c0.png" alt="img_6.png"></p><h3 id="2-2-模块关系ER图"><a href="#2-2-模块关系ER图" class="headerlink" title="2.2 模块关系ER图"></a>2.2 模块关系ER图</h3><p>我们将系统功能划分为四个模块：用户个人信息模块，用户与用户间交互模块(进一步拆分为私密交友模块与公共社交模块)，管理员管理模块。</p><h4 id="2-2-1-用户个人信息模块ER图"><a href="#2-2-1-用户个人信息模块ER图" class="headerlink" title="2.2.1 用户个人信息模块ER图"></a>2.2.1 用户个人信息模块ER图</h4><p>为美观起见，不再展示用户全部属性。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2FBlog%2F2024%2F10%2F12%2F18-11-12-0b33d9d6ce23cb77f7dbbfe721feed54-img_7-401f0b.png" alt></p><h4 id="2-2-2-私密交友模块ER图"><a href="#2-2-2-私密交友模块ER图" class="headerlink" title="2.2.2 私密交友模块ER图"></a>2.2.2 私密交友模块ER图</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2FBlog%2F2024%2F10%2F12%2F18-11-50-91ad893445f01e64006c9ab943cd4eb8-img_11-b0a361.png" alt></p><h4 id="2-2-3-公共社交模块ER图"><a href="#2-2-3-公共社交模块ER图" class="headerlink" title="2.2.3 公共社交模块ER图"></a>2.2.3 公共社交模块ER图</h4><p>为美观起见，不再展示帖子所有属性</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2FBlog%2F2024%2F10%2F12%2F18-12-04-bd7aad6e8d68d1c46cb2f988133218da-img_14-7727bb.png" alt></p><h4 id="2-2-4-管理员管理模块ER图"><a href="#2-2-4-管理员管理模块ER图" class="headerlink" title="2.2.4 管理员管理模块ER图"></a>2.2.4 管理员管理模块ER图</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2FBlog%2F2024%2F10%2F12%2F18-05-45-c1fff819adc4ea5693d6328220fc0e34-img_12-d9f60a.png" alt="img_12.png"></p><h4 id="2-2-5-模块总结"><a href="#2-2-5-模块总结" class="headerlink" title="2.2.5 模块总结"></a>2.2.5 模块总结</h4><p><strong>通知</strong>贯穿各模块，是最为复杂的机制，依赖于通知机制我们实现了用户间实时的可见的交互。通知的种类繁多，依赖外键较为复杂，ER图中无法全面展现，我们会在后续分析物理模型时进一步叙述，<br>总的来说，我们可以把通知机制理解为，<strong>一个用户向另一个用户发送了一条信息</strong>，其重点在于两个用户之间的关系。</p><h3 id="2-3-系统整体ER图"><a href="#2-3-系统整体ER图" class="headerlink" title="2.3 系统整体ER图"></a>2.3 系统整体ER图</h3><p>由于过于庞大复杂，为美观起见，省略了部分属性。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F20%E7%BB%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%A7%E4%BD%9C%E4%B8%9A%2FBlog%2F2024%2F10%2F12%2F18-12-20-0e6366b28b78257f3b81395d19566a95-img_13-d8fbe5.png" alt></p><h2 id="三-数据库逻辑模式设计"><a href="#三-数据库逻辑模式设计" class="headerlink" title="三. 数据库逻辑模式设计"></a>三. 数据库逻辑模式设计</h2><h3 id="3-1-数据库关系模式"><a href="#3-1-数据库关系模式" class="headerlink" title="3.1 数据库关系模式"></a>3.1 数据库关系模式</h3><p>关系模式可以形式化表⽰为 $ R(U, D, DOM, F) $ 。$ U $ 为组成该关系的属性名，$ D $为 $ U $ 中属性所来⾃的域，<br>$ DOM $ 指的是属性与域的映射，$ F $ 指的是属性间的依赖关系集合。以下约定 $ I $ 表⽰int型，$ F $ 表⽰浮点数，$ S $ 为任意字符组成的字符串，$ T $ 表⽰时间，$ B $ 表⽰布尔值，由于上述已给出每个属性的类型，下文不对域再进行讨论。主码以下划线标识。</p><p>以下是由ER图推导并加以外键优化后最终得到的关系模式。</p><h4 id="3-1-1-实体-包含1对1，1对多关系"><a href="#3-1-1-实体-包含1对1，1对多关系" class="headerlink" title="3.1.1 实体(包含1对1，1对多关系)"></a>3.1.1 实体(包含1对1，1对多关系)</h4><p>一对一的关系将关系耦合进任意一方，一对多的关系将关系耦合进多的一方</p><ol><li><p><code>User</code>:<br>user({<u>id</u>，username，studentId，password，time，major，nickname，avatarUrl，backgroundUrl，sex，signature，address，birthday，role}，D，Dom，F)</p><p> <strong>F</strong>={id-&gt;其他属性，studentId-&gt;其他属性，(username，password)-&gt;其他属性}</p><p> <strong>外码</strong>：无</p><p> <strong>候选码</strong>: id，studentId，(username，password)</p></li><li><p><code>Label</code>:<br>label({<u>id</u>，type，name， weight}，D，Dom，F)</p><p> <strong>F</strong>={id-&gt;其他属性，(type，name)-&gt;其他属性}</p><p> <strong>外码</strong>：无</p><p> <strong>候选码</strong>: id，(type，name)</p></li><li><p><code>ImageBoard</code>:<br>imageboard({<u>id</u>，userId，imgUrl，time}，D，Dom，F)</p><p><strong>F</strong>={id-&gt;其他属性，imgUrl-&gt;其他属性}</p><p><strong>外码</strong>：userId(user.id)</p><p><strong>候选码</strong>: id，imgUrl</p></li><li><p><code>Post</code>:<br>post({<u>id</u>，time，type，content，top，userId，likeNum，clickNum，commentNum}，D，Dom，F)</p><p><strong>F</strong>={id-&gt;其他属性}</p><p><strong>外码</strong>：userId(user.id)</p><p><strong>候选码</strong>: id</p></li><li><p><code>Comment</code>:<br>comment({<u>id</u>，time，userId，replyCommentId，replyPostId，showId，content，likeNum，commentNum}，D，Dom，F)</p><p><strong>F</strong>={id-&gt;其他属性}</p><p><strong>当replyCommentId存在时存在 replyCommentId-&gt;replyPostId，但是由于replyCommentId可以为空，此时不存在函数依赖 replyCommentId-&gt;replyPostId。</strong></p><p><strong>外码</strong>：userId(user.id)</p><p><strong>候选码</strong>: id</p></li><li><p><code>Image2Post</code>:<br>image2post({<u>id</u>，postId，imgUrl}，D，Dom，F)</p><p><strong>F</strong>={id-&gt;其他属性，imgUrl-&gt;其他属性}</p><p><strong>外码</strong>：postId(post.id)</p><p><strong>候选码</strong>: id，imgUrl</p></li><li><p><code>Chat</code>:<br>chat({<u>id</u>，senderId，receiverId，content，time，read}，D，Dom，F)</p><p><strong>F</strong>={id-&gt;其他属性}</p><p><strong>外码</strong>：senderId(user.id)，receiverId(user.id)</p><p><strong>候选码</strong>: id</p></li><li><p><code>SoulMatch</code>:<br>soulMatch({<u>id</u>，userId，matchNum，sendApplicationNum，successNum，time}，D，Dom，F)</p><p><strong>F</strong>={id-&gt;其他属性}</p><p><strong>外码</strong>：userId(user.id)</p><p><strong>候选码</strong>: id</p></li><li><p><code>Notice</code>:<br>notice({<u>id</u>，type，time，read，message，isDelete，receiverId，senderId，replyPostId，replyCommentId，senderCommentId，managerAnnouncementId，soulMatchId}，D，Dom，F)</p><p><strong>F</strong>={id-&gt;其他属性}</p><p>此表中由于涉及过多类型的通知而存在大量外键，senderId和receiverId是必须的外键，其余外键皆可以为空。或许会认为<strong>replyPostId/replyCommentId-&gt;receiverId，senderCommentId/managerAnnouncementId-&gt;senderId</strong>，然而在左侧外键为空时右侧外键不唯一，因此这些并不是函数依赖。</p><p><strong>外码</strong>：senderId，receiverId(user.id)，replyCommentId，senderCommentId(comment.id)，replyPostId(post.id)，managerAnnouncementId(managerannouncement.id)，soulmatchId(soulmatch.id)</p><p><strong>候选码</strong>: id</p></li><li><p><code>ManagerAnnouncement</code>:<br>managerAnnouncement({<u>id</u>，time，userId，message，receiverNum，type}，D，Dom，F)</p><p><strong>F</strong>={id-&gt;其他属性}</p><p><strong>外码</strong>： userId(user.id)</p><p><strong>候选码</strong>: id</p></li></ol><h4 id="3-1-2-多对多关系"><a href="#3-1-2-多对多关系" class="headerlink" title="3.1.2 多对多关系"></a>3.1.2 多对多关系</h4><ol><li><p><code>Label2User</code>:<br>label2user({<u>id</u>，userId，labelId}，D，Dom，F)</p><p><strong>F</strong>={id-&gt;其他属性，(userId，labelId)-&gt;其他属性}</p><p><strong>外码</strong>： userId(user.id)，labelId(label.id)</p><p><strong>候选码</strong>: id，(userId，labelId)</p></li><li><p><code>Like2Post</code>:<br>like2post({<u>id</u>，postId，userId}，D，Dom，F)</p><p><strong>F</strong>={id-&gt;其他属性，(postId，userId)-&gt;其他属性}</p><p><strong>外码</strong>：userId(user.id)，postId(post.id)</p><p><strong>候选码</strong>: id，(userId，postId)</p></li><li><p><code>Like2Comment</code>:<br>like2comment({<u>id</u>，commentId，userId}，D，Dom，F)</p><p><strong>F</strong>={id-&gt;其他属性，(commentId，userId)-&gt;其他属性}</p><p><strong>外码</strong>：userId(user.id)，commentId(comment.id)</p><p><strong>候选码</strong>: id，(userId，commentId)</p></li><li><p><code>Friend</code>:<br>friend({<u>id</u>，userId1，userId2，intimacy，time，soulMatchId}，D，Dom，F)</p><p><strong>F</strong>={id-&gt;其他属性，(userId1，userId2)-&gt;其他属性}</p><p><strong>外码</strong>：userId1(user.id)，userId2(user.id)</p><p><strong>候选码</strong>: id，(userId1，userId2)</p></li><li><p><code>Access</code>:<br>access({<u>id</u>，userId，time，pageName}，D，Dom，F)</p><p><strong>F</strong>={id-&gt;其他属性}</p><p><strong>由于我们假定一个用户在同一时间可以多次访问同一界面，因此仅有id作为候选码</strong></p><p><strong>外码</strong>：userId(user.id)</p><p><strong>候选码</strong>: id</p></li></ol><h3 id="3-2-关系模式范式等级的判定"><a href="#3-2-关系模式范式等级的判定" class="headerlink" title="3.2 关系模式范式等级的判定"></a>3.2 关系模式范式等级的判定</h3><p>分别对上述表进行范式等级判断，我们仅检查到BCNF范式，将未达到3NF的表规范到3NF。</p><h4 id="3-2-1-实体等级判定"><a href="#3-2-1-实体等级判定" class="headerlink" title="3.2.1 实体等级判定"></a>3.2.1 实体等级判定</h4><ol><li><code>User</code>: 仅存在三组候选码产生的依赖，满足对于所有函数依赖 $ X -&gt; Y $，X都是码，因此user属于$ BCNF $，自然属于$ 3NF $。</li><li><code>Label</code>: 仅存在两组候选码产生的依赖，满足对于所有函数依赖 $ X -&gt; Y $，X都是码，因此label属于$ BCNF $，自然属于$ 3NF $。</li><li><code>ImageBoard</code>: 仅存在两组候选码产生的依赖，满足对于所有函数依赖 $ X -&gt; Y $，X都是码，因此label属于$ BCNF $，自然属于$ 3NF $。</li><li><code>Post</code>: 所有函数依赖的左端均为主码，因此post属于$ BCNF $，自然属于$ 3NF $。</li><li><code>Comment</code>: 所有函数依赖的左端均为主码，因此comment属于$ BCNF $，自然属于$ 3NF $。</li><li><code>Image2Post</code>: 仅存在两组候选码产生的依赖，满足对于所有函数依赖 $ X -&gt; Y $，X都是码，因此image2post属于$ BCNF $，自然属于$ 3NF $。</li><li><code>Chat</code>: 所有函数依赖的左端均为主码，因此chat属于$ BCNF $，自然属于$ 3NF $。</li><li><code>SoulMatch</code>: 所有函数依赖的左端均为主码，因此soulmatch属于$ BCNF $，自然属于$ 3NF $。 </li><li><code>Notice</code>: 所有函数依赖的左端均为主码，因此notice属于$ BCNF $，自然属于$ 3NF $。</li><li><code>ManagerAnnouncement:</code> 所有函数依赖的左端均为主码，因此managerannouncement属于$ BCNF $，自然属于$ 3NF $。</li></ol><h4 id="3-2-2-多对多关系等级判定"><a href="#3-2-2-多对多关系等级判定" class="headerlink" title="3.2.2 多对多关系等级判定"></a>3.2.2 多对多关系等级判定</h4><ol><li><code>Label2User</code>: 仅存在两组候选码产生的依赖，满足对于所有函数依赖 $ X -&gt; Y $，X都是码，因此label2user属于$ BCNF $，自然属于$ 3NF $。 </li><li><code>Like2Post</code>: 仅存在两组候选码产生的依赖，满足对于所有函数依赖 $ X -&gt; Y $，X都是码，因此like2post属于$ BCNF $，自然属于$ 3NF $。</li><li><code>Like2Comment</code>: 仅存在两组候选码产生的依赖，满足对于所有函数依赖 $ X -&gt; Y $，X都是码，因此like2comment属于$ BCNF $，自然属于$ 3NF $。</li><li><code>Friend</code>: 仅存在两组候选码产生的依赖，满足对于所有函数依赖 $ X -&gt; Y $，X都是码，因此friend属于$ BCNF $，自然属于$ 3NF $。</li><li><code>Access</code>: 所有函数依赖的左端均为主码，因此notice属于$ BCNF $，自然属于$ 3NF $。</li></ol><h4 id="3-2-3-总结"><a href="#3-2-3-总结" class="headerlink" title="3.2.3 总结"></a>3.2.3 总结</h4><p>我们的所有表均满足$BCNF$范式，自然全部满足$3NF$范式，具备了较成熟专业的数据库表设计能力。</p><h3 id="3-3-数据库设计优化"><a href="#3-3-数据库设计优化" class="headerlink" title="3.3 数据库设计优化"></a>3.3 数据库设计优化</h3><p>为提高数据库增删改查的效率，以及简化开发人员的操作，我们对数据库的一些方面做出了优化。</p><h4 id="3-3-1-建立更多索引"><a href="#3-3-1-建立更多索引" class="headerlink" title="3.3.1 建立更多索引"></a>3.3.1 建立更多索引</h4><p>数据库中有两类索引在创建时便会建好，分别为主键的索引与外键的索引。除此之外，对于表中其他候选码，又或是一些频繁查询的属性，我们也可以建立起索引增快查询速度。</p><p>如用户表中，我们还可以建立起学号的唯一索引与用户名密码的一般索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_studentId <span class="keyword">ON</span> <span class="keyword">user</span>(studentId);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX index_username <span class="keyword">ON</span> <span class="keyword">user</span>(username);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX index_password <span class="keyword">ON</span> <span class="keyword">user</span>(password);</span><br></pre></td></tr></table></figure><p>以及一些多对多的关系中，我们经常给定一端求取与之对应的多条数据，我们可以在两端都建立起一般索引，如在like2post表中，对userId和postId分别建立索引，这样在查找指定用户点赞过哪些帖子和指定帖子被哪些用户点赞过时都可大幅提高效率。一般而言这类索引在设置外键时已自动设置，无需手动操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KEY `fk_like2post_1` (`userId`)</span><br><span class="line">KEY `fk_like2post_2` (`postId`)</span><br></pre></td></tr></table></figure><h4 id="3-3-2-优化查询语句"><a href="#3-3-2-优化查询语句" class="headerlink" title="3.3.2 优化查询语句"></a>3.3.2 优化查询语句</h4><p>我们在后端编写SQL时时刻注重优化查询语句，减少数据的访问与查询次数。</p><ul><li>避免使用SELECT <em>: 只选择需要的列，而不是使用SELECT </em>，避免冗余的数据传输。</li><li>优化连接操作：我们在执行连接操作时，要确保连接的字段中存在索引，同时注意要选择合适的连接类型，区分内连接与外连接的不同，避免逻辑错误。</li><li>减少嵌套子查询：在相关子查询中，对于主查询的每一行结果，子查询都需要被执行一次，加之子查询伴随着临时表的生成，大大降低了查询效率。我们尽可能使用连表操作替换子查询操作，或尝试拆分成多条SQL语句。</li></ul><h4 id="3-3-3-创建视图"><a href="#3-3-3-创建视图" class="headerlink" title="3.3.3 创建视图"></a>3.3.3 创建视图</h4><p>视图是实体表的映射，一般而言作用有二，一是展示出不同的外模式供不同角色的开发者使用，提高数据库安全性，在此不过多区分；二是简化复杂查询，如果我们经常需要执行复杂的查询，可以通过创建一个视图来隐藏这些复杂性，无需每次都编写复杂的SQL语句。</p><p>针对一些频繁查询的连表操作我们创建了视图，例如统计用户的好友数量时，涉及到连表和复杂的SQL，我们改为创建视图易于查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> user2friendnum <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">COALESCE</span>(f1.friend_count, <span class="number">0</span>) <span class="operator">+</span> <span class="built_in">COALESCE</span>(f2.friend_count, <span class="number">0</span>) <span class="keyword">AS</span> total_friend_count</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    `<span class="keyword">user</span>` u</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        userId1,</span><br><span class="line">        <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> friend_count</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        friend</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">        userId1</span><br><span class="line">) f1 <span class="keyword">ON</span> u.id <span class="operator">=</span> f1.userId1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        userId2,</span><br><span class="line">        <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> friend_count</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        friend</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">        userId2</span><br><span class="line">) f2 <span class="keyword">ON</span> u.id <span class="operator">=</span> f2.userId2;</span><br></pre></td></tr></table></figure><p>统计用户使用灵魂匹配次数时:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> user2soulmatch <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> userId, <span class="built_in">count</span>(userId) <span class="keyword">AS</span> useTime </span><br><span class="line"><span class="keyword">FROM</span> soulmatch </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> userId</span><br></pre></td></tr></table></figure><h4 id="3-3-4-使用触发器与函数"><a href="#3-3-4-使用触发器与函数" class="headerlink" title="3.3.4 使用触发器与函数"></a>3.3.4 使用触发器与函数</h4><p>我们的表之间联动较多，在执行某项任务时可能同时涉及多个表的更新，为简化开发者逻辑，并充分利用数据库系统，我们使用了触发器和函数等功能，进一步优化数据库设计。</p><p>在给帖子点赞/撤销赞时更新帖子的点赞量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> addPostLikeNum</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> like2post</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@likenum</span> :<span class="operator">=</span> (<span class="keyword">SELECT</span> likeNum <span class="keyword">from</span> post <span class="keyword">WHERE</span> id <span class="operator">=</span> new.postId); </span><br><span class="line"><span class="keyword">UPDATE</span> post <span class="keyword">SET</span> likeNum <span class="operator">=</span> <span class="variable">@likenum</span> <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> delPostLikeNum</span><br><span class="line">BEFORE <span class="keyword">DELETE</span> <span class="keyword">ON</span> like2post</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@likenum</span> :<span class="operator">=</span> (<span class="keyword">SELECT</span> likeNum <span class="keyword">from</span> post <span class="keyword">WHERE</span> id <span class="operator">=</span> old.postId); </span><br><span class="line"><span class="keyword">UPDATE</span> post <span class="keyword">SET</span> likeNum <span class="operator">=</span> <span class="variable">@likenum</span> <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> old.postId;</span><br><span class="line">ENDd <span class="operator">=</span> new.postId;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>在给评论点赞/撤销赞时更新评论的点赞量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> addCommentLikeNum</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> like2comment</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@likenum</span> :<span class="operator">=</span> (<span class="keyword">SELECT</span> likeNum <span class="keyword">from</span> `comment` <span class="keyword">WHERE</span> id <span class="operator">=</span> new.commentId); </span><br><span class="line"><span class="keyword">UPDATE</span> `comment` <span class="keyword">SET</span> likeNum <span class="operator">=</span> <span class="variable">@likenum</span> <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> new.commentId;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> delCommentLikeNum</span><br><span class="line">BEFORE <span class="keyword">DELETE</span> <span class="keyword">ON</span> like2comment</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@likenum</span> :<span class="operator">=</span> (<span class="keyword">SELECT</span> likeNum <span class="keyword">from</span> `comment` <span class="keyword">WHERE</span> id <span class="operator">=</span> old.commentId); </span><br><span class="line"><span class="keyword">UPDATE</span> `comment` <span class="keyword">SET</span> likeNum <span class="operator">=</span> <span class="variable">@likenum</span> <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> old.commentId;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>帖子下发表/删除评论更新帖子的评论量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> addCommentNum</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> `comment`</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@commentnum</span> :<span class="operator">=</span> (<span class="keyword">SELECT</span> commentNum <span class="keyword">from</span> post <span class="keyword">WHERE</span> id <span class="operator">=</span> new.replyPostId);</span><br><span class="line">IF new.replyCommentId <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span></span><br><span class="line">    <span class="keyword">UPDATE</span> post <span class="keyword">SET</span> commentNum <span class="operator">=</span> <span class="variable">@commentnum</span> <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> new.replyPostId;</span><br><span class="line"><span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> delCommentNum</span><br><span class="line">BEFORE <span class="keyword">DELETE</span> <span class="keyword">ON</span> `comment`</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@commentnum</span> :<span class="operator">=</span> (<span class="keyword">SELECT</span> commentNum <span class="keyword">from</span> post <span class="keyword">WHERE</span> id <span class="operator">=</span> old.replyPostId);</span><br><span class="line">IF old.replyCommentId <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span></span><br><span class="line">    <span class="keyword">UPDATE</span> post <span class="keyword">SET</span> commentNum <span class="operator">=</span> <span class="variable">@commentnum</span> <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> old.replyPostId;</span><br><span class="line"><span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>评论下增加评论时更新评论的评论量:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> addCommentNum2Comment</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> `comment`</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@commentnum</span> :<span class="operator">=</span> (<span class="keyword">SELECT</span> commentNum <span class="keyword">from</span> `comment` <span class="keyword">WHERE</span> new.replyCommentId <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">and</span> id <span class="operator">=</span> new.replyCommentId);</span><br><span class="line">IF <span class="variable">@commentnum</span> <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span></span><br><span class="line">    <span class="keyword">UPDATE</span> `comment` <span class="keyword">SET</span> commentNum <span class="operator">=</span> <span class="variable">@commentnum</span> <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> new.replyCommentId;</span><br><span class="line"><span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h4 id="3-3-5-严格约束加入数据库的数据"><a href="#3-3-5-严格约束加入数据库的数据" class="headerlink" title="3.3.5 严格约束加入数据库的数据"></a>3.3.5 严格约束加入数据库的数据</h4><p>我们通过数据库建表时设置的外键约束(参见上文)和索引UNIQUE约束搭配前后端表单检查的方式，避免脏数据污染数据库，为开发人员造成不必要的麻烦。</p><p>同时在后续工作中可考虑使用触发器拦截更新，插入，删除请求，实现更加灵活更加便捷的约束。</p><h4 id="3-3-6-数据库日志"><a href="#3-3-6-数据库日志" class="headerlink" title="3.3.6 数据库日志"></a>3.3.6 数据库日志</h4><p>我们考虑开启数据库普通日志，来记录追踪用户的各项行为，便于对用户形象的统计刻画。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_output <span class="operator">=</span> <span class="string">&#x27;TABLE&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log_file <span class="operator">=</span> <span class="string">&#x27;log&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log_table <span class="operator">=</span> dbhomework.log;</span><br></pre></td></tr></table></figure><p>然而开启日志后伴随着占用存储空间变多同时执行效率降低，使我们不得不放弃了这个想法，进而转为综合各个表间信息来统合用户行为数据。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 数据库系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库系统 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> 前后端开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『编译技术』SysY-Mips编译器设计——实验总结</title>
      <link href="/post/dffb4f71.html"/>
      <url>/post/dffb4f71.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『编译技术』SysY-Mips编译器设计——实验总结"><a href="#『编译技术』SysY-Mips编译器设计——实验总结" class="headerlink" title="『编译技术』SysY-Mips编译器设计——实验总结"></a>『编译技术』SysY-Mips编译器设计——实验总结</h1><p><strong>章节目录</strong></p><ul><li><strong><em><a href="https://yangyzzzz.github.io/post/80c7e14a.html">『编译技术』SysY-Mips编译器设计——总体设计概述</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/c6d56501.html">『编译技术』SysY-Mips编译器设计——词法分析</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/898866d1.html">『编译技术』SysY-Mips编译器设计——语法分析</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/eebe4e1.html">『编译技术』SysY-Mips编译器设计——语义分析(符号表管理与错误处理)</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/810d8044.html">『编译技术』SysY-Mips编译器设计——中间代码LLVM生成</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/a0d75678.html">『编译技术』SysY-Mips编译器设计——目标代码Mips生成</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/867e51bf.html">『编译技术』SysY-Mips编译器设计——中端代码优化</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/9f6855b5.html">『编译技术』SysY-Mips编译器设计——后端代码优化</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/dffb4f71.html">『编译技术』SysY-Mips编译器设计——实验总结</a></em></strong></li></ul><h2 id="实验得分"><a href="#实验得分" class="headerlink" title="实验得分"></a>实验得分</h2><p>最终八个点得分如下所示，排名除第六个点外均位于20名附近，而第六个点来到50+。第六个点较为反常，出现了分配给其的寄存器越多，cycle反而越高的情况，mem执行较多，猜测是使用了较深的递归而产生了大量寄存器传参冲突。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%2Fblog%2F2024%2F10%2F12%2F17-18-15-23b33e4c97bc24ae988950f1d82cf07d-img_14-c7c9e1.png" alt="img_14.png"></p><h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><p>总而言之，从一个月前正式着手进行优化，再到如今优化后代码来到1w+行，即使循环外提等关键优化未来得及细细琢磨，排名似乎也不是很理想，这场优化之路至此也将走向终点。</p><p>这是一次充满艰辛的苦痛旅程，也是一次锻炼自己的绝佳机会，我收获到了不只是编译优化方面还有图论算法等等的知识，也练就了自己去看懂伪代码，看不懂就自己造算法的见山开山，见水渡水的执着心态，最后再次感谢坚持一路走来的自己，感谢这学期和我一同讨论编译的朋友们，也感谢课程组和老师们，感谢他们为我们带来了不逊色于coos的编译实验。纵使心中万般不舍，也不得不为这学期的努力画上句号，编译再见噜，下一次接触编译就是作为助教帮助大家了！</p><p>最后我想说编译在我心中不愧是oo的promax升级版，最后的最后献上我的巨巨巨型类图，从左至右依次为前端架构，中端架构，后端架构。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%2Fblog%2F2024%2F10%2F12%2F17-18-15-310ca3a2adddefb320f6c8e550efebce-img_15-73155f.png" alt="img_15.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 编译技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『编译技术』SysY-Mips编译器设计——后端代码优化</title>
      <link href="/post/9f6855b5.html"/>
      <url>/post/9f6855b5.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『编译技术』SysY-Mips编译器设计——后端代码优化"><a href="#『编译技术』SysY-Mips编译器设计——后端代码优化" class="headerlink" title="『编译技术』SysY-Mips编译器设计——后端代码优化"></a>『编译技术』SysY-Mips编译器设计——后端代码优化</h1><p><strong>章节目录</strong></p><ul><li><strong><em><a href="https://yangyzzzz.github.io/post/80c7e14a.html">『编译技术』SysY-Mips编译器设计——总体设计概述</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/c6d56501.html">『编译技术』SysY-Mips编译器设计——词法分析</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/898866d1.html">『编译技术』SysY-Mips编译器设计——语法分析</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/eebe4e1.html">『编译技术』SysY-Mips编译器设计——语义分析(符号表管理与错误处理)</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/810d8044.html">『编译技术』SysY-Mips编译器设计——中间代码LLVM生成</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/a0d75678.html">『编译技术』SysY-Mips编译器设计——目标代码Mips生成</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/867e51bf.html">『编译技术』SysY-Mips编译器设计——中端代码优化</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/9f6855b5.html">『编译技术』SysY-Mips编译器设计——后端代码优化</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/dffb4f71.html">『编译技术』SysY-Mips编译器设计——实验总结</a></em></strong></li></ul><h2 id="零-前言"><a href="#零-前言" class="headerlink" title="零. 前言"></a>零. 前言</h2><p>本部分任务为对Mips后端代码做出代码优化，主要是配合中端优化的后端消PHI和图着色寄存器分配。实际上，后端优化更多涉及特定的体系结构，这里实现的仅仅是冰山一角。</p><h2 id="一-后端消PHI"><a href="#一-后端消PHI" class="headerlink" title="一. 后端消PHI"></a>一. 后端消PHI</h2><p>这一步说是优化，然而是LLVM经历过mem2reg优化后不得不做的一步。</p><p>消PHI即将<code>PHI</code>指令消去，换句话说，<code>PHI</code>指令的<code>Value</code>值应该保留，但后面的数据流应当通过<code>Move</code>指令消去。LLVM具备规则，对于基本块<code>B</code>，若其有多个前驱的基本块$B<em>{1}, B</em>{2}…$且$B$中存在<code>phi</code>指令，我们可以在$B_{i}\rightarrow B$之间添加新的基本块$B’$ ，新添加的基本块内只有一种指令，即<code>move</code>指令。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%2Fblog%2F2024%2F10%2F12%2F16-54-09-e7f27025670f1f413dce282ced5d41c4-img_3-e103fa.png" alt="img_3.png"></p><p>参照教程内思路，首先遍历全部基本块，找到入口存在<code>phi</code>指令基本块<code>B</code>(存在<code>phi</code>指令意味着其一定有两个及以上前驱节点)，遍历其每个前驱节点$B<em>i$，若其拥有超过一个后继节点，则$(B</em>{i}, B)$称作一对关键边，在这之间创建一新基本块$B’$，若$B<em>{i}$仅有$B$一个后继节点，则后续在$B</em>{i}$结尾进行。</p><p>创建好基本块后，遍历$B$中所有<code>phi</code>指令，对于 <code>%x = phi((%b1 %v1), (...))</code>，找到其前驱基本块<code>b1</code>对应的<code>Move</code>指令插入位置，可能是新基本块或基本块末尾，插入指令 <code>%x = move %v1</code>，对于<code>phi</code>内其他数据流同样操作即可。</p><p>如此我们通过加入大量<code>move</code>指令，完成了对LLVM的消PHI工作，在后续我们会尝试将<code>move</code>合并以缩减多余的<code>move</code>指令。</p><p><strong>注：move是自己定义的假指令，对标mips里的move，其中保存两个Value记为target与source。</strong></p><h2 id="二-图着色寄存器分配（核心）"><a href="#二-图着色寄存器分配（核心）" class="headerlink" title="二. 图着色寄存器分配（核心）"></a>二. 图着色寄存器分配（核心）</h2><p>mips优化中最核心的一步，经历消PHI后，我们便可以着手生成mips代码。生成时进行图着色寄存器分配优化。</p><p>在之前的阶段当中我们都假定了有无限个寄存器作为虚拟变量，而实际上mips后端的寄存器有限，经过大量摸索后寄存器分配如下：</p><ul><li><p><code>zero, at</code>不参与分配；</p></li><li><p><code>v0, v1</code>用作机动寄存器，即使用后立即释放，不会引起任何冲突，用于承接立即数与在超过两个操作数的指令中进行中间计算，同时v1还被设置用来存放图着色后溢出的节点，并立即存入内存中，这两个寄存器不参与分配；</p></li><li><p><code>sp,fp,ra,gp</code>寄存器用于维护堆栈，全局变量，返回地址等，不可分配；</p></li><li><p><code>a0~a3</code>用作函数传前四个参数，不参与分配；</p><p>实际上，这四个寄存器有过考量，最终实践证明传参非常需要用来中间过渡的寄存器，否则由于传参寄存器冲突导致访存开销过大！</p></li><li><p>其余20个寄存器参与图着色寄存器分配。</p></li></ul><h3 id="1-计算活跃变量"><a href="#1-计算活跃变量" class="headerlink" title="1. 计算活跃变量"></a>1. 计算活跃变量</h3><p>应用在课内学过的计算活跃变量的方法，我们以基本块为单位计算出每个基本块内全部指令<code>in</code>和<code>out</code>集。计算方法为一个基本块中由下至上由<code>out</code>倒推<code>in</code>，而基本块内最后一条指令的<code>out</code>集由其后继节点们第一条指令的<code>in</code>集的并集决定，如此迭代计算，直至每条指令的<code>in</code>和<code>out</code>集合不再变化。为减少迭代次数，可以考虑从出口节点开始遍历。如此我们计算出了多个活跃变量集合，也即是<strong>变量冲突的多个时刻</strong>。</p><p>具体而言针对每一条指令，<code>in</code>集等于<code>out</code>集加上该指令的操作数节点，再减去该指令节点，如下图算法所示：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%2Fblog%2F2024%2F10%2F12%2F17-05-00-ff7332fe349f399fbb5201c718bb40ae-img_11-e139e1.png" alt></p><h3 id="2-构造冲突图Build"><a href="#2-构造冲突图Build" class="headerlink" title="2. 构造冲突图Build"></a>2. 构造冲突图Build</h3><p>接下来开始图着色寄存器分配，整体算法如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%2Fblog%2F2024%2F10%2F12%2F17-05-35-f5c987ca78b2618fce9ad60f66f6ae9d-img_8-aac3d8.png" alt></p><p>一个活跃变量集合里包含的元素两两冲突，彼此间都会形成一条无向边，我们在<code>Value</code>类内记录每个节点的邻接矩阵，遍历所有的活跃变量集合，得到冲突图，同时需要记录下<code>move</code>指令的两个节点，在后续可尝试合并。</p><p>冲突图代表着节点之间的冲突关系，存在边的两节点无法共用同一寄存器，我们进行启发式的图着色算法来为每个节点分配寄存器，最终目的为<strong>在生成mips之前，每个虚拟变量被分配到了有且仅有一个唯一的寄存器</strong>。</p><h3 id="3-简化Simplify"><a href="#3-简化Simplify" class="headerlink" title="3. 简化Simplify"></a>3. 简化Simplify</h3><p>我们删除冲突图中度数小于$K(20)$的点，简化冲突图，将其入栈，产生更多的图着色机会，因简化步骤而入栈的节点<strong>一定可以分配到寄存器</strong>。</p><h3 id="4-合并Coalesce"><a href="#4-合并Coalesce" class="headerlink" title="4. 合并Coalesce"></a>4. 合并Coalesce</h3><p><code>move</code>指令的两端节点本质相同，可进行保守式的合并，若合并后的度数总和小于K，则进行合并, 即二节点共用同一寄存器，将被合并的点彻底移除冲突图(需要记录下合并的点，为后续分配寄存器时能够得到合并点分配的寄存器)，同时注意维护现有图的邻接边关系；若合并后总度数大于K，则我们不进行合并，因为合并后可能会产生新的溢出节点，得不偿失。</p><h3 id="5-冻结Freeze"><a href="#5-冻结Freeze" class="headerlink" title="5. 冻结Freeze"></a>5. 冻结Freeze</h3><p>反复执行简化和合并的步骤，直至图中节点无法改变。</p><h3 id="6-溢出Spill"><a href="#6-溢出Spill" class="headerlink" title="6. 溢出Spill"></a>6. 溢出Spill</h3><p>无法合并与简化时，将度数大于等于K的结点标注为不可分配寄存器，然后从冲突图中去除，将其入栈，因溢出步骤而入栈的节点<strong>不一定能分配到寄存器</strong>。溢出节点后简化了冲突图，会暴露出更多的合并和简化机会，如此反复，直至冲突图为空。</p><h3 id="7-选择Select"><a href="#7-选择Select" class="headerlink" title="7. 选择Select"></a>7. 选择Select</h3><p>当冲突图为空时，开始从栈中挨个取结点，重新生成冲突图，为在简化步骤时入栈的结点分配寄存器，将溢出步骤时入栈的结点置入不可分配的集合。</p><p>最后尝试将不可分配寄存器集合的结点取出尝试为其分配寄存器(由于<code>move</code>等原因可能存在为其分配寄存器的可能)，若当真无法分配，则进行标记，将其转化为活跃范围较小的变量，并进行重新开始。</p><h3 id="8-重新开始Restart"><a href="#8-重新开始Restart" class="headerlink" title="8. 重新开始Restart"></a>8. 重新开始Restart</h3><p>如果无法进行着色的集合不为空，那么则需要改写程序，为这些变量在内存当中分配空间，并且在每次使用需要将其从内存当中取出。</p><p>这一步骤是最关键的一步，也是笔者改造最多的一步，关键在于如何理解教程中这段话：</p><blockquote><p>每次修改需要存进内存当中，这种情况下，溢出的临时变量会转变为几个活跃范围很小的新的临时变量，这个时候需要重新进行活跃分析、寄存器分配，直到没有溢出和简化为止（通常只需要迭代一两次）。</p></blockquote><p>冲突图中的节点有两种可能，一种是指令节点，另一种是函数的形参节点，假设某节点是溢出的节点，意味着<strong>该节点应当在出现后立刻存入内存中，将其从活跃变量流中杀死，而使用到该变量节点时从对应地址中取出，再使用</strong>。</p><p><strong>出现</strong>：若节点是函数形参，则在函数最开始便已经出现，因此也在函数最开始添加指令，若为前四个参数则将对应的<code>A</code>寄存器存入内存，若为后续形参，则我们会在调用函数时处理将形参存入内存的过程，而并非在函数头执行；若节点是指令节点，则在其被赋值的时刻出现，我们需要在下一条紧接<code>Store</code>指令，将其存入内存当中。</p><p>而为溢出节点分配寄存器本人采取了两种方式：</p><ol><li>对溢出节点作标记后重新开始：该节点被使用时不再纳入活跃变量集合中，而与之绑定的<code>store</code>指令的操作数(也就是该溢出节点)仍需要纳入活跃变量集合，此时我们将该溢出节点活跃范围缩小，进而重新进行图着色分配，直至再无溢出节点。</li><li><strong>将溢出节点寄存器设置为机动寄存器V1</strong>：由于溢出节点在<code>store</code>后寄存器会立刻释放，不如使用机动寄存器进行转存，如此确保一趟图着色便可分配完毕，避免了重新开始的步骤，最后采用第二种方法，正确性无误。</li></ol><hr><p>以下是coding时一些随笔：</p><ol><li>从哪取：偏移量如何设置，偏移量来自两个地方，一个是数组的声明，一个是我们放不下的虚拟变量，先装我们的虚拟变量，翻译mips时实时填入二维数组。</li><li>全局变量该如何记录，需不需要应急寄存器，全局变量符号出现在<code>Load</code>(无需缓冲)和<code>GTR</code>处(涉及计算，需要缓冲)，使用V1作为缓冲即可。</li><li>最后每一个变量都会被分配一个绝对不会产生冲突的寄存器，生成Mips时直接对照寄存器无脑灌入即可。</li><li>问题：即使有限次迭代可以保证分配好寄存器，但仍然存在死循环的可能性，当一个变量<code>V</code>无法分配寄存器，而将其转换在前面<code>load</code>出来时，由于<code>load</code>也需要一个寄存器承接，因此即使<code>V</code>不作为活跃变量在寄存器内流向更前面的定义处，而在当前处(<code>load</code>的<code>out</code>)处仍存在冲突的可能性，这时需要<strong>重新开始</strong>。</li></ol><h3 id="9-经过图着色寄存器分配后的结果"><a href="#9-经过图着色寄存器分配后的结果" class="headerlink" title="9. 经过图着色寄存器分配后的结果"></a>9. 经过图着色寄存器分配后的结果</h3><p>每一条指令<code>Value</code> 都唯一确定分配好了一个寄存器，而使用的<code>Value</code>除常数外有两种情况。</p><ol><li>在寄存器里；</li><li>由于寄存器冲突而存在内存中，此时备注好了相对于FP的偏移，使用机动寄存器取出即可。</li></ol><p>接下来按照指令类型翻译为mips即可，相较于优化前，这一步是轻松许多的！</p><h3 id="10-生成mips"><a href="#10-生成mips" class="headerlink" title="10. 生成mips"></a>10. 生成mips</h3><p>整体较为eazy，有两个重点：</p><ul><li><p>对溢出节点的处理：溢出节点的处理方式正是做优化前对于无寄存器可分配的<code>Value</code>的处理方式。秉持上述原则，在处理地址问题便没有歧义了。</p></li><li><p>对函数传参的处理：由于图着色后，形参和实参都分配好了寄存器，无可避免的会出现传递的当前形参的寄存器后续的实参还要用到，此时无法直接<code>move</code>的情况，此时需要一些算法来规避影响，最为简单的方法是用一块内存空间作为缓冲，实参先存入内存中，形参再从内存中调取。然而这会产生大量存取内存指令，违背了我们优化的初衷，因此这也是为何要令<code>$A0~$A3</code>作为传参缓冲寄存器的理由。</p></li></ul><h2 id="三-乘除法优化"><a href="#三-乘除法优化" class="headerlink" title="三. 乘除法优化"></a>三. 乘除法优化</h2><h3 id="1-乘法优化"><a href="#1-乘法优化" class="headerlink" title="1. 乘法优化"></a>1. 乘法优化</h3><p>特判乘数是否为2的倍数，若是2的倍数可改为左移指令。</p><h3 id="2-除法优化"><a href="#2-除法优化" class="headerlink" title="2. 除法优化"></a>2. 除法优化</h3><p>除法优化即将除法改造为乘法和右移指令。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%2Fblog%2F2024%2F10%2F12%2F16-54-09-d24b76821a0a768099b147faed44a848-img_12-b1e4a7.png" alt="img_12.png"></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%2Fblog%2F2024%2F10%2F12%2F16-54-09-7b49fb9c635e4f905a68e34361f6c309-img_13-9b40e8.png" alt="img_13.png"></p><p>上述公式需要满足：</p><ol><li>被除数为正数</li><li>除数为常数且为正数</li></ol><p>根据不等式计算出乘数<code>m</code>和右移量<code>l</code>，由于我们需要保证被除数为正数且生成指令时无从得知被除数的正负，于是尝试人为构造了<code>if</code>语句并创建了两个新基本块用于被除数正数和负数的情况。</p><h3 id="3-取模优化"><a href="#3-取模优化" class="headerlink" title="3. 取模优化"></a>3. 取模优化</h3><p>使用恒等式将取模转化为乘除操作即可(<code>a % b = a - a / b * a</code>)。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 编译技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『编译技术』SysY-Mips编译器设计——中端代码优化</title>
      <link href="/post/867e51bf.html"/>
      <url>/post/867e51bf.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『编译技术』SysY-Mips编译器设计——中端代码优化"><a href="#『编译技术』SysY-Mips编译器设计——中端代码优化" class="headerlink" title="『编译技术』SysY-Mips编译器设计——中端代码优化"></a>『编译技术』SysY-Mips编译器设计——中端代码优化</h1><p><strong>章节目录</strong></p><ul><li><strong><em><a href="https://yangyzzzz.github.io/post/80c7e14a.html">『编译技术』SysY-Mips编译器设计——总体设计概述</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/c6d56501.html">『编译技术』SysY-Mips编译器设计——词法分析</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/898866d1.html">『编译技术』SysY-Mips编译器设计——语法分析</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/eebe4e1.html">『编译技术』SysY-Mips编译器设计——语义分析(符号表管理与错误处理)</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/810d8044.html">『编译技术』SysY-Mips编译器设计——中间代码LLVM生成</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/a0d75678.html">『编译技术』SysY-Mips编译器设计——目标代码Mips生成</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/867e51bf.html">『编译技术』SysY-Mips编译器设计——中端代码优化</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/9f6855b5.html">『编译技术』SysY-Mips编译器设计——后端代码优化</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/dffb4f71.html">『编译技术』SysY-Mips编译器设计——实验总结</a></em></strong></li></ul><h2 id="零-前言"><a href="#零-前言" class="headerlink" title="零. 前言"></a>零. 前言</h2><p>本部分任务为对LLVM中间代码做出代码优化，实际上大量的优化都集中于此。不要指望看这份文档就能看明白优化，因为笔者整理时也看不明白了。</p><h2 id="一-Mem2Reg"><a href="#一-Mem2Reg" class="headerlink" title="一. Mem2Reg"></a>一. Mem2Reg</h2><h3 id="0-何为Mem2Reg？"><a href="#0-何为Mem2Reg？" class="headerlink" title="0. 何为Mem2Reg？"></a>0. 何为Mem2Reg？</h3><p><strong>在sysY中定义的变量称作原始变量，而在LLVM中的一个个变量我会称作虚拟变量(后续很有可能会统称为变量…但实际不一样)，定义和赋值的概念不再区分</strong>。</p><p>本优化不考虑全局变量和数组，仅针对单值<code>int</code>和指针(本质上是一字节的值)进行优化。我们最初的LLVM已经是SSA单赋值形式，而mem2reg这步，对于用LLVM为中间代码的我来说，应当是对原先的LLVM打散再重构的过程。</p><p>首先要明确，最初的LLVM是单赋值且单使用(除去<code>Alloc</code>指令)，一个原始变量被拆成过多的虚拟变量，因为我们使用的每一个原始变量都是从内存中<code>LOAD</code>取出，即一个虚拟变量被单赋值的同时也仅被使用了一次。</p><p>我们现在要依据每个原始变量的<code>def-use</code>链(一个变量的生命周期，从被定义，到被使用，到再次被定义结束) 改造成单赋值多使用的形式，同样是将原始变量拆成多个虚拟变量，但是仅在定义时拆。通过这第一步，我们便可以消去一部分的访存指令。但由此会引发一个重大的问题，借用教程的图图。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%2Fblog%2F2024%2F10%2F12%2F16-19-51-a52672cbc083b84f1bf7c2159250bb26-img_9-d0fdec.png" alt></p><p>在分支汇总处，一个原始变量的取值会取决于数据从哪条分支上流入，上图AB块中的两个<code>y</code>我们称作<code>y1</code>和<code>y2</code>，print块中的<code>y</code>并非定义而是使用，那么它的取值便成了未知数，我们用<code>y3 = phi [A, y1], [B, y2]</code> 这条指令对<code>y</code>进行一次定义，<code>y3</code>成为此时<code>y</code>的唯一取值。</p><p>接下来的工作便是以<strong>基本块</strong>为最小单位找到插入<code>phi</code>指令的位置，进而找到哪些变量需要使用<code>phi</code>指令的返回值。核心目标是<strong>使得每一个原始变量在代码的任何地点有唯一的虚拟变量取值</strong>。</p><h3 id="1-计算基本块前驱与后继结点"><a href="#1-计算基本块前驱与后继结点" class="headerlink" title="1. 计算基本块前驱与后继结点"></a>1. 计算基本块前驱与后继结点</h3><p>依据基本块跳转指令来记录每一个基本块的前驱和后继基本块们就可以，记录基本块前驱与后继。进入节点无前驱，退出节点(最后一条为return语句的基本块)无后继。</p><h3 id="2-计算被支配节点（支配集合）"><a href="#2-计算被支配节点（支配集合）" class="headerlink" title="2. 计算被支配节点（支配集合）"></a>2. 计算被支配节点（支配集合）</h3><p>首先定义如下:</p><ol><li><p>支配（dominate）：如果CFG（Control Flow Graph）中从起始节点到基本块<code>y</code>的所有路径都经过了基本块<code>x</code>，我们说<code>x</code>支配<code>y</code>，按照这个定义，每一个节点都支配自己。</p></li><li><p>严格支配(strict dominate)：如果<code>x</code>支配<code>y</code>，且<code>x</code>不等于<code>y</code>，那么<code>x</code>严格支配<code>y</code>。</p></li><li><p>直接支配者（immediate dominator, idom）：严格支配<code>n</code>，且不严格支配任何严格支配 <code>n</code> 的节点的节点(直观理解就是所有严格支配n的节点中离<code>n</code>最近的那一个)，我们称其为<code>n</code>的直接支配者。</p></li></ol><p>接下来我们计算每个节点被哪些节点支配。<strong>Lengauer-Tarjan</strong>算法较为复杂，我们采用<strong>迭代数据流算法</strong>，流程如下:</p><ol><li>将起始节点设为<code>r</code>，初始化为仅被自己支配</li><li>其余起始支配节点初始化皆为被全部节点支配。每个基本块保存一个<code>HashMap&lt;BasicBlock, Boolean&gt;</code>用作记录被支配关系。</li><li>每次迭代取前驱结点的被支配集合的交集与自身的并，直至集合无变化，此时得到各节点支配关系，注意这不是支配树。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%2Fblog%2F2024%2F10%2F12%2F16-25-39-dd072775f32b3b7a90be4bce257b8933-img-d8c8f4.png" alt></p><p>所谓<code>a</code>严格支配<code>b</code>，对符号<code>x</code>而言，即<code>b</code>中的第一次定义<code>x</code>之前的值完全由<code>a</code>的最后一次定义来决定，不存在任何歧义。因此显然自己无法严格支配自己。</p><h3 id="3-计算直接支配者"><a href="#3-计算直接支配者" class="headerlink" title="3. 计算直接支配者"></a>3. 计算直接支配者</h3><p>根据定义(严格支配<code>n</code>，且不严格支配任何严格支配 <code>n</code> 的节点的节点)计算，我们已经求得支配 <code>n</code> 结点的全部节点，只需要遍历一遍即可找到藏在其中的直接支配节点。</p><p>每个节点的直接支配者是其父节点，根据此关系我们构造出了<strong>支配树</strong>。</p><h3 id="4-计算支配边界"><a href="#4-计算支配边界" class="headerlink" title="4. 计算支配边界"></a>4. 计算支配边界</h3><p>首先明确为何计算支配边界，一个节点的支配边界代表着支配范围的边界，在该节点对变量的定义会在边界处会产生歧义(即这个定义只是多个取值的可能一种取值)，因此我们需要计算支配边界来找到插<code>phi</code>的位置。</p><p>我们已经求得每个节点的直接支配者，采用如图算法。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%2Fblog%2F2024%2F10%2F12%2F16-17-12-b5f837e26fd005a0fb4f8a5fa3fb4b5d-img_1-282e4b.png" alt="img_1.png"></p><p>简单解释该算法，我们遍历有向图中每一条边(<code>a</code>指向<code>b</code>)，从两个节点最近的位置，即一条边开始，逐渐沿<code>a</code>的直接支配者往上，直至<code>a</code>能够直接支配<code>b</code>，在此之前的遍历到的所有节点，其支配边界都该包含<code>b</code>。</p><p>注意，<strong>自己可以是自己的支配边界</strong>，考虑 <code>0 --&gt; 1 --&gt; 2 --&gt; 1</code>，即出现回边时，自己基本块的定义也可能不由自己决定。</p><h3 id="5-插入phi节点"><a href="#5-插入phi节点" class="headerlink" title="5. 插入phi节点"></a>5. 插入phi节点</h3><p>核心算法如图：我们得到了支配边界后，此时以原始变量作为最小单位，记录下原始变量在哪些基本块中被定义过(此时需要与符号表配合，见改造符号表一节)，进而找到基本块集合的支配边界，由于我们要在支配边界上插入定义的<code>phi</code>指令，支配边界也便成了定义的基本块，因此需要将支配边界也纳入基本块集合中，同时记录支配边界们，直至找到<strong>闭包</strong>，定义基本块集合不再变化。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%2Fblog%2F2024%2F10%2F12%2F16-33-01-2d5f05e724c833b755a16cbf33d9654d-img_2-c31c24.png" alt></p><p>这时我们求得了待插phi的支配边界集合，但是要明确的是，<strong>经过上述算法得到的是可能插入<code>phi</code>的位置，并非一定插入</strong>，由于我们的文法支持各处定义，在一个基本块插入<code>phi</code>值时可能出现该变量未被定义的情况，这是不应该的，因此在得到插入<code>phi</code>的基本块集合后，需再次判断该变量在该基本块是否存在定义。<strong>这一条限制是我们SysY文法的限制，而非一般算法中给出</strong>。</p><p>在重命名前，即使<code>Phi</code>指令未被填全，但是该指令的<code>Value</code>(即该变量在基本块中的新定义)已然存在。新增的<code>Phi</code>填充完毕，意味着此时变量定义已然完备，一个变量在任何位置都具备了变量唯一性，重命名只需要做两件事，计算<code>Phi</code>指令流入的<code>Value</code>，为一开始找不到定义的假标签找到属于它的<code>Value</code>。</p><p>证明：插入phi后，若在当前基本块x仍找不到定义，则其真正的定义一定在直接支配者y中：</p><p>当前基本块找不到定义，说明当前基本块未定义，且未插phi，说明该基本块未被当作支配边界，则该基本块定义唯一来自其直接支配者y。</p><h3 id="6-重命名phi"><a href="#6-重命名phi" class="headerlink" title="6. 重命名phi"></a>6. 重命名phi</h3><p>我们由第三步可得知节点的父节点，根据父节点推出每个节点的子节点，构建支配树，为接下来DFS做准备。</p><p>我们需要DFS支配树，基本块<code>a</code>是基本块<code>b</code>的直接支配者并不意味着基本块<code>b</code>中的变量由<code>a</code>中的变量直接决定，而是由<code>a</code>中的变量和将<code>b</code>作为支配边界的基本块们中的变量共同决定。</p><p>重命名需要三步：</p><ol><li>需要判断当前插入的<code>phi</code>的合理性，即是否沿每条前驱块都能找到对应定义；</li><li>为<code>phi</code>指令的每一条数据流找到归属；</li><li>重命名该基本块内在生成<code>phi</code>之前无法得到准确赋值的被使用的变量。</li></ol><p>为<code>phi</code>值添加基本块流，需要保证其每一个前驱基本块都要为<code>phi</code>提供一条数据流，对于每一前驱块，沿其直接支配者找到最近的该原始变量定义，将其填入<code>phi</code>指令中。这一步的正确性<strong>基于DFS支配树</strong>，保证遍历到一节点时，其直接支配者的<code>phi</code>指令都已装配完毕。</p><p>重命名假标签同理，首先判断在<code>Phi</code>指令的插入后能否在当前基本块找到定义，若找到则重命名假标签为该<code>phi</code>值；若找不到，则沿其直接支配者找到最近的定义即可。</p><p>上述寻找过程一定都能找到，因为在插入PHI以后，已经<strong>确保了每个原始变量在每一时刻的虚拟变量的唯一性</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a1 &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        a1 = a1 + <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑如上情况<code>a1</code>应该被唯一确定，<code>if</code>内<code>a1</code>并非处在<code>a1</code>的决策边界处，DFS支配树。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2F%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%2Fblog%2F2024%2F10%2F12%2F16-17-12-d9fba2ed59384e5a46c4158d312d2c00-img_10-484c1b.png" alt="img_10.png"></p><p>给出官方的算法，由于本人到这一步看不太明白，因此上文均是自己推导，经评测验证应为正确。</p><h2 id="二-基本块合并"><a href="#二-基本块合并" class="headerlink" title="二. 基本块合并"></a>二. 基本块合并</h2><p>这一步应用在CFG之后，计算支配关系之前，因为涉及到对基本块的删除，主要工作有二：</p><ol><li>将非连通基本块删除</li><li>将相邻基本块(该基本块有且只有一个前驱且该前驱有且只有当前基本块一个后继)和二为一，指令相融合</li></ol><p>由于我们在上文已把基本块的关系构建完毕，接下来处理较为容易，有两点需要注意：</p><ul><li><p>基本块间的关系是一个双向链表，在合并以及删除时应注意前驱节点和后继节点的修正。</p><p>具体来说，设被合并删除的基本块为<code>a</code>，合并的基本块为<code>b</code>，则<code>a</code>不再是<code>b</code>唯一的后继节点，而<code>a</code>的后继节点成为<code>b</code>新的后继节点；<code>a</code>的后继节点们的前驱节点也不再是<code>a</code>，而替换为<code>b</code>!</p></li><li><p>合并基本块会导致定义位置紊乱，可能无法沿支配树找到最近<code>Value</code>，需要额外的操作。</p><ul><li>我们可以遍历被合并的块全部指令，用合并块的定义表进行匹配，将能匹配上的假标签替换为合并的块的定义<code>Value</code>，由于存在先后关系，定义表中保存的变量定义是最后一次定义，而被合并块存在的假标签一定是在该基本块第一次定义之前出现的，因此匹配正确性得到保证。</li><li>将被合并块的定义符号表(<code>IrSymbolTable</code>)转移到合并块的定义符号表，若合并块中存在该变量定义，则替换(因为被合并块的在合并块之后)；若不存在，则加入。</li></ul></li></ul><h2 id="三-死代码删除"><a href="#三-死代码删除" class="headerlink" title="三. 死代码删除"></a>三. 死代码删除</h2><h3 id="1-概念："><a href="#1-概念：" class="headerlink" title="1. 概念："></a>1. 概念：</h3><p>程序包含的一些代码可能并不会被运行或者不会对结果产生影响，那么我们称这种代码为死代码。我们将不会被运行到的称为不可达代码，将不会对结果产生影响的代码成为无用代码。删除无用或不可达代码可以缩减IR代码，可使程序更小、编译更快、执行也更快。</p><h3 id="2-死函数删除"><a href="#2-死函数删除" class="headerlink" title="2. 死函数删除"></a>2. 死函数删除</h3><p>构造函数调用链，删除没有使用过的函数。不过这一步只能减少生成的代码，并不会减少执行的cycle。使用BFS计算出有价值函数的闭包，其余删除。</p><h3 id="3-死代码删除"><a href="#3-死代码删除" class="headerlink" title="3. 死代码删除"></a>3. 死代码删除</h3><p>我们目前认为的有价值指令有：<code>br, ret, call, store</code>（有待商榷，需要进一步做内存分析，全局变量的<code>store</code>可以无脑加，局部变量的<code>store</code>取决于后续有无使用它的，需要涉及到公众子表达式删除等问题），其中<code>store</code>会在后文进一步优化。</p><p>采用逆推的形式，将所有有价值指令标记，再将有价值指令的操作数标记，大体思路同死函数删除，使用BFS计算出有价值指令闭包，其余指令删除。</p><h2 id="四-局部公共子表达式删除"><a href="#四-局部公共子表达式删除" class="headerlink" title="四. 局部公共子表达式删除"></a>四. 局部公共子表达式删除</h2><p>局部子表达式删除的正确性建立在基本块内指令的顺序执行。若是在全局范围内优化，则需要考量基本块执行顺序的问题，出现哈希冲突时并不代表其中存在可以优化的项，例如在两个分支中出现了</p><pre><code>分支1：c1 = a + b, d1 = c1 + a；分支2：c2 = a + b, d2 = c2 + a；</code></pre><p>此时我们不能将<code>c2</code>优化为<code>c1</code>，因为<code>c1</code>在这条分支中不会被计算。我们针对部分指令进行局部子表达式删除，包含<code>add,sub,mul,div,getelementptr,cmp</code>。该优化以每条指令为最小单元，站在基本块视角进行，步骤如下：</p><ol><li>对于每个<code>BasicBlock</code>初始化一个哈希表</li><li>对每条指令，获取它的操作数和操作符，根据操作数和操作符计算哈希值，需要特别考虑<code>add，mul，cmp</code>三类指令，他们存在着多种等价形式，<code>add</code>和<code>mul</code>将操作数颠倒同样等价，而<code>cmp</code>需要考虑的更多，例如<code>a&gt;b</code>和<code>b&lt;a</code>等价。</li><li>扫描基本块内全部指令，计算哈希值，如果哈希表中已经存在该值，那么我们直接将<code>BasicBlock</code>里后续用到该<code>Value</code>的地方全部替换为哈希表内存的<code>Value</code>，否则将哈希值及对应的<code>Value</code>存入哈希表</li></ol><h2 id="五-常量折叠与传播"><a href="#五-常量折叠与传播" class="headerlink" title="五. 常量折叠与传播"></a>五. 常量折叠与传播</h2><ul><li><p>提前计算好操作数为常数的表达式，针对<code>add,sub,mul,div,cmp</code>等进行了常量折叠，缩减计算指令。</p></li><li><p>只进行了较为简单的复杂折叠，诸如 <code>0 * a, 1 * a, 0 + a, a - 0, 0 / a</code> 等相邻情况的简单优化。</p></li></ul><h2 id="六-优化Store"><a href="#六-优化Store" class="headerlink" title="六. 优化Store"></a>六. 优化Store</h2><p>有时我们会在<code>load</code>之前多次对同一个地址进行<code>store</code>，那么显然只有最后一个<code>store</code>是有效的，前面的<code>store</code>指令可删除。因此我们可进行内存分析，删除一些无用的store指令，注意删除后可能会暴露新的优化空间，需要再次进行死代码删除。</p><h2 id="七-全局指令移动（超简化版）"><a href="#七-全局指令移动（超简化版）" class="headerlink" title="七. 全局指令移动（超简化版）"></a>七. 全局指令移动（超简化版）</h2><p>指令移动时有如下要求：</p><ol><li>操作数在循环中不变，为定值。</li><li>移动不会产生<strong>副作用</strong>：比如涉及存入内存等指令，若提出循环外，则可能没进循环，却由于外提而执行这条指令导致影响下文，这种即产生了副作用。</li><li>为变量赋值也是一种会产生副作用的操作，经过了死代码删除后，留下的被赋值的变量一定会在下文中被用到，外提还需要对<code>phi</code>指令做一些处理，比如循环外对<code>i</code>赋值，循环内也对<code>i</code>赋值(但满足操作数不变)，此时在循环结束后使用<code>i</code>值，正常应该是使用<code>phi</code>将两个数据流汇总，而外提后存在一些问题。</li></ol><p>我们首先通过深度优先遍历CFG找回边得到<strong>处于循环内的基本块</strong>，我们只针对循环内的基本块中某些语句做出前提，一是由于循环外指令再怎么前提也不会产生正面优化，二是指令前提也会产生活跃变量范围增大，溢出节点增多等副作用，需要权衡考虑。</p><p>为简单起见，我们只将偏移量为常数的<code>gpr(getElementPtr)</code>指令尝试前移至基地址的定义位置之后，若使用全局变量基地址则前移至入口基本块处，如此可避免多次重复计算访存地址。</p><p>正确性证明：一是<code>gpr</code>内操作数不变，二是<code>gpr</code>的结果并非是原始变量，而是临时变量，不会对<code>phi</code>流产生影响，一定不会存在副作用。</p><p>经实际检验，简化版的指令移动在第七个竞速测试点已经得到了大量优化！同时可以肯定地说，这部分优化非常关键，是做完Mem2Reg后提升性能的关键！</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 编译技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『编译技术』SysY-Mips编译器设计——目标代码Mips生成</title>
      <link href="/post/a0d75678.html"/>
      <url>/post/a0d75678.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『编译技术』SysY-Mips编译器设计——目标代码Mips生成"><a href="#『编译技术』SysY-Mips编译器设计——目标代码Mips生成" class="headerlink" title="『编译技术』SysY-Mips编译器设计——目标代码Mips生成"></a>『编译技术』SysY-Mips编译器设计——目标代码Mips生成</h1><p><strong>章节目录</strong></p><ul><li><strong><em><a href="https://yangyzzzz.github.io/post/80c7e14a.html">『编译技术』SysY-Mips编译器设计——总体设计概述</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/c6d56501.html">『编译技术』SysY-Mips编译器设计——词法分析</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/898866d1.html">『编译技术』SysY-Mips编译器设计——语法分析</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/eebe4e1.html">『编译技术』SysY-Mips编译器设计——语义分析(符号表管理与错误处理)</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/810d8044.html">『编译技术』SysY-Mips编译器设计——中间代码LLVM生成</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/a0d75678.html">『编译技术』SysY-Mips编译器设计——目标代码Mips生成</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/867e51bf.html">『编译技术』SysY-Mips编译器设计——中端代码优化</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/9f6855b5.html">『编译技术』SysY-Mips编译器设计——后端代码优化</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/dffb4f71.html">『编译技术』SysY-Mips编译器设计——实验总结</a></em></strong></li></ul><h2 id="零-任务目标"><a href="#零-任务目标" class="headerlink" title="零. 任务目标"></a>零. 任务目标</h2><p>由生成的中间代码LLVM转化为目标代码Mips，实现简单的寄存器分配，不考虑后端优化。</p><h2 id="一-前置准备"><a href="#一-前置准备" class="headerlink" title="一. 前置准备"></a>一. 前置准备</h2><h3 id="Mips基本分区"><a href="#Mips基本分区" class="headerlink" title="Mips基本分区"></a>Mips基本分区</h3><h4 id="data常量段"><a href="#data常量段" class="headerlink" title="data常量段"></a>data常量段</h4><p>包含所有准备输出的字符串。</p><h4 id="text代码段"><a href="#text代码段" class="headerlink" title="text代码段"></a>text代码段</h4><p>全局变量：使用<code>GP</code>做偏移</p><p>函数和主函数代码段：其中变量定义，入栈时使用<code>FP</code>做偏移</p><h3 id="关键寄存器"><a href="#关键寄存器" class="headerlink" title="关键寄存器"></a>关键寄存器</h3><ol><li><code>$gp</code>：全局寄存器 记录全局变量</li><li><code>$sp</code>：栈顶寄存器</li><li><code>$fp</code>：栈帧寄存器，记录的是活动记录基地址 开局 <code>li $fp, 0x10040000</code>设置栈帧寄存器</li><li><code>$t0~$t7,$s0~$s6</code>：待分配寄存器</li><li><code>$v0, $v1, $t8, $t9</code>：机动寄存器</li></ol><h3 id="Mips指南"><a href="#Mips指南" class="headerlink" title="Mips指南"></a>Mips指南</h3><ol><li><code>syscall</code>的使用，<code>$v0</code>中存储指令代码<ol><li><code>syscall 1</code>：打印整数，将整数参数存储在 <code>$a0</code> 寄存器中，然后使用 syscall 1 来打印这个整数</li><li><code>syscall 4</code>：打印字符串，将字符串的地址存储在 <code>$a0</code> 寄存器中，然后使用 syscall 4 来打印这个字符串。</li><li><code>syscall 5</code> ：读取整数，将整数的地址存储在 <code>$v0</code> 寄存器中，然后使用 <code>syscall 5</code> 来从用户输入中读取整数</li><li><code>syscall 10</code>：终止程序</li><li><code>syscall 11</code>：打印字符，将字符的数值存入 <code>$a0</code> 寄存器中，然后使用<code>syscall</code>打印字符</li></ol></li><li><code>li $x, 0x1</code>：将立即数赋值给指定寄存器</li><li><code>la $x, addr</code>：将地址赋值给指定寄存器，用于输出字符串</li><li><code>move $x1, $x2</code>：将<code>$x2</code>中的内容赋值给<code>$x1</code></li></ol><h2 id="二-指令转化"><a href="#二-指令转化" class="headerlink" title="二. 指令转化"></a>二. 指令转化</h2><ul><li><p><code>cmp</code> 的各种比较符号完全替换成 MIPS 的<code>sgt,sge</code>等指令即可</p></li><li><p><code>br</code> 无条件跳转替换为<code>j</code>，有条件跳转如 <code>br i1 label1 label2</code> 可替换为 <code>bne $x, $zero, label1; beq $x, $zero, label2</code> 两条语句</p></li><li><p><code>call</code> 替换为 <code>jal</code></p></li></ul><h2 id="四-MIPS-符号表"><a href="#四-MIPS-符号表" class="headerlink" title="四. MIPS 符号表"></a>四. MIPS 符号表</h2><p>首先说明本人的内存管理非常规，<code>$sp,$fp</code>并非指栈顶栈底，而是将其视为两个栈底，函数调用的活动变量用<code>$sp</code>记录，局部变量用<code>$fp</code>记录。</p><p>不能完全复用错误处理时的符号表，因为虚拟寄存器与符号表记录的信息相比多了许多中间变量，而这些中间变量也需要被记录，则需要<strong>在生成中间代码时重新构造一张符号表</strong>，而构建起两张符号表的联系是必要的。</p><p>中间代码的每个虚拟变量由<code>Value</code>记录，因此我们直接使用<code>Value</code>作为中间代码符号表的单元，在<code>Value</code>上额外记录一些属性即可。</p><p>新增属性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> offset; <span class="comment">// 对于基地址，是基于Fp或Gp的偏移</span></span><br><span class="line"><span class="type">bool</span> isGp; <span class="comment">// 标记全局Alloc的属性</span></span><br><span class="line"><span class="type">bool</span> isFp; <span class="comment">// 标记局部Alloc的属性</span></span><br><span class="line"><span class="type">bool</span> isInReg; <span class="comment">// 该Value是否在寄存器内</span></span><br></pre></td></tr></table></figure><h2 id="五-函数调用"><a href="#五-函数调用" class="headerlink" title="五. 函数调用"></a>五. 函数调用</h2><p>分为调用方和被调用方，调用函数时，此时已经使用过的寄存器要压入栈，返回时重新填入。</p><h3 id="调用方调用函数流程"><a href="#调用方调用函数流程" class="headerlink" title="调用方调用函数流程"></a>调用方调用函数流程</h3><ol><li>将前四个参数放入<code>A</code>中</li><li>将当前<code>FP，RA</code>，当前函数未释放的寄存器保存到<code>SP</code>中，并移动<code>SP</code>位置，即保存上下文现场</li><li>将<code>FP</code>增长至被调用函数的栈帧处</li><li>将剩余参数存入<code>FP</code>首地址的位置</li><li>执行跳转 <code>jal xxx</code></li><li>返回后首先将<code>FP，RA</code>，当前函数未释放的寄存器从<code>SP</code>中取回，再将<code>SP</code>还原，即还原上下文现场</li><li>将返回值转移到其他寄存器，继续运行</li></ol><h3 id="被调用方处理"><a href="#被调用方处理" class="headerlink" title="被调用方处理"></a>被调用方处理</h3><p>函数开始时需要将参数全部装入当前函数的<code>FP</code>栈帧中。计算时可能会出现寄存器不够的情况，若传递的参数大于当前寄存器可用的数量，要<strong>压栈</strong>。</p><pre><code>mipsInstructions.add(new Sw(V0, fpOffset, FP));irInstruction.offset = fpOffset;fpOffset += 4;</code></pre><h2 id="六-机动寄存器"><a href="#六-机动寄存器" class="headerlink" title="六. 机动寄存器"></a>六. 机动寄存器</h2><p>在参数传递时，若多于四个参数，此时<code>A0~A3</code>也无法作为中转寄存器，那我们规定<strong><code>V0,T8,T9</code></strong>作为<strong>立即数转移</strong>的机动寄存器，也作为<strong>压栈</strong>的临时寄存器，<strong><code>V1</code></strong>作为存储地址的机动寄存器，他们的共同特点就是使用后立即释放。</p><ul><li><strong><code>V1</code></strong>地址机动寄存器：由于地址每次都重新计算，因此只要规定不随意使用，<code>V1</code>一个就够。</li></ul><h2 id="七-相对与绝对地址"><a href="#七-相对与绝对地址" class="headerlink" title="七. 相对与绝对地址"></a>七. 相对与绝对地址</h2><h3 id="值与地址"><a href="#值与地址" class="headerlink" title="值与地址"></a>值与地址</h3><p>我们尝试找到一种寻址比较易于理解的方法。</p><p><code>Value</code>具有几个关键属性：</p><ul><li><p><code>isFp，isGp</code>: 这两个标识<strong>仅</strong>出现在<code>Alloc</code>的<code>Value</code>中，根据全局或局部变量设置，目的是配合<code>offset</code>设置定义的变量地址<code>fp/gp + offset</code>，对于数组而言是首地址。</p></li><li><p><code>isInReg</code>，<code>reg</code>: 标识该<code>Value</code>的值是否在寄存器中，若在，则位于<code>reg</code>号寄存器。</p></li><li><p><code>offset</code>：偏移量，若<code>isFp/isGp</code>为True，表示定义的变量的相对偏移量；若为 false，意为由于寄存器不足，将临时变量存入内存中，保存的地址相对于当前栈帧<code>FP</code>的偏移量。</p></li></ul><p><code>offset</code>在这两种情况表达的含义不同，由于寄存器不足而入栈的<code>Value</code>的<code>offset</code>，指的是<strong>Value的值存入的地址相对于栈帧的偏移</strong>；而<code>alloc</code>的<code>Value</code>本身就是地址，<code>offset</code>是<code>Value</code>值的偏移。</p><p>首先明确，我们想要得到一个Value的<strong>值</strong>，一共有两种方法：</p><ol><li>从内存中取，获得所在内存的地址又分为两种方法<ol><li><code>GP + offset</code>：<code>offset</code>是相对于全局基地址的偏移</li><li><code>FP + offset</code>：<code>offset</code>是相对于当前栈帧基地址的偏移</li></ol></li><li>从寄存器中取，此时寄存器中保存着<code>Value</code>的值</li></ol><p>针对<code>store,load,getelementptr</code>这三条指令的转化是重点，我们默认地址都指绝对地址，只是存储方式有区别。</p><p>当<code>Value</code>存的值是一个地址时，即上述三条指令会涉及，这个地址(<code>Value</code>值)可能有两种情况。</p><ol><li>该地址基地址，即<code>alloc</code>的<code>Value</code>，这时绝对地址就是<code>Value</code>中<code>FP/GP + offset</code>。</li><li>该地址是经过<code>elementptr</code>转化过的目标地址，这时通过上述的取值方法可得到地址的值。</li></ol><p>区别在于，第一种情况只需要<code>Add($a, FP, offset)</code>，而第二种若<code>Value</code>在内存中则需要<code>Lw($a, offset, FP)</code>，<code>$a</code>为绝对地址。</p><h3 id="绝对与相对寻址"><a href="#绝对与相对寻址" class="headerlink" title="绝对与相对寻址"></a>绝对与相对寻址</h3><p><strong>一旦寄存器或内存中保存了地址，则一定为绝对地址</strong>。当涉及到传指针传地址时，传的应当是绝对地址，这是由于若是相对地址，则由于不同函数的<code>FP</code>不同，将无法得到正确的地址。而传指针时必然会涉及到<code>getelementptr</code>，因此我们规定<code>getelementptr</code>的<code>Value</code>一律保存绝对地址。</p><p>在本部分，第一是要正确理解值，地址，内存的概念，第二是要理解相对只是绝对的另一种描述方式，本质上寻址都是基于绝对寻址。</p><h2 id="八-优化方法"><a href="#八-优化方法" class="headerlink" title="八. 优化方法"></a>八. 优化方法</h2><p>由于LLVM的临时变量(除去定义)用完即释放，操作数的寄存器一旦被用了一次即可释放，因此寄存器会比较够用，也会不易产生入栈读写内存的开销。然而这些应当是由于LLVM优化不够导致的，正如上一篇LLVM生成文档所言，一旦一个临时变量可以被多次使用，那么我们便不能轻易释放寄存器(但凡后面还会用到该<code>Value</code>)，寄存器之间的冲突会加剧，调度与分配会更为复杂，这些在优化LLVM后应当着手考虑。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 编译技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『编译技术』SysY-Mips编译器设计——中间代码LLVM生成</title>
      <link href="/post/810d8044.html"/>
      <url>/post/810d8044.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『编译技术』SysY-Mips编译器设计——中间代码LLVM生成"><a href="#『编译技术』SysY-Mips编译器设计——中间代码LLVM生成" class="headerlink" title="『编译技术』SysY-Mips编译器设计——中间代码LLVM生成"></a>『编译技术』SysY-Mips编译器设计——中间代码LLVM生成</h1><p><strong>章节目录</strong></p><ul><li><strong><em><a href="https://yangyzzzz.github.io/post/80c7e14a.html">『编译技术』SysY-Mips编译器设计——总体设计概述</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/c6d56501.html">『编译技术』SysY-Mips编译器设计——词法分析</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/898866d1.html">『编译技术』SysY-Mips编译器设计——语法分析</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/eebe4e1.html">『编译技术』SysY-Mips编译器设计——语义分析(符号表管理与错误处理)</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/810d8044.html">『编译技术』SysY-Mips编译器设计——中间代码LLVM生成</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/a0d75678.html">『编译技术』SysY-Mips编译器设计——目标代码Mips生成</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/867e51bf.html">『编译技术』SysY-Mips编译器设计——中端代码优化</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/9f6855b5.html">『编译技术』SysY-Mips编译器设计——后端代码优化</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/dffb4f71.html">『编译技术』SysY-Mips编译器设计——实验总结</a></em></strong></li></ul><h2 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h2><p>狭义的LLVM（Low Level Virtual Machine）是一种常用的通用中间代码表示。在本部分内容中，我们由建立好的语法树生成中间代码LLVM，不考虑复杂优化方法。</p><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><ol><li>LLVM生成时将常量全部带入，在后续中我们了解到属于<strong>常量折叠</strong>优化。</li><li>在编译开始前遍历字符串，清 <code>+,-</code> 连着的长串符号，这样可以减少部分无意义的运算指令。</li><li>将错误处理和中间代码生成解耦合，即默认输入代码不出错。</li><li>本方案采用第一遍扫描生成语法树，第二遍扫描语法树生成LLVM。</li></ol><h2 id="LLVM架构"><a href="#LLVM架构" class="headerlink" title="LLVM架构"></a>LLVM架构</h2><p>LLVM采用<strong>User,Value,Use</strong>的架构，具体的继承关系如图。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F10-05-42-34ae47fd4f56fa0cbea38beeaa2fdbfe-image-20241012100535673-270122.png" alt="image-20241012100535673"></p><p><strong>每一条LLVM语句都可以看作一个<code>Value</code>，<code>Value</code>是LLVM一切类的父类</strong>。从直观来看，<code>&#39;=&#39;</code>左边的值便是一条语句的Value，又可以叫做综合属性或返回值，当然存在诸如<code>Store</code>这类没有返回值，我们可以认为其Value为Null。</p><p><strong><code>User</code>类继承<code>Value</code>类，而<code>Instruction</code>又都继承User类</strong>，从直观来看，<code>&#39;=&#39;</code>右边用到的值，即一些操作数，便是一条语句的<code>User</code>，也可以称作继承属性或传入值。</p><p><strong><code>Use</code>类记录了<code>Value</code>和<code>User</code>之间的联系，可以看作是<code>def-use</code>图中的一条边</strong>，本架构中用列表替代了<code>Use</code>的作用，应当是等价的。</p><p>对于一条<code>Instruction</code>，它既作为一个<code>User</code>，又作为一个<code>Value</code>。作为<code>User</code>时，它记录了<code>Value</code>的列表，即记录了使用了哪些<code>Value</code>，又或者说使用了哪些语句的返回值；作为<code>Value</code>时，它又记录了一个<code>User</code>的列表，即记录了这条语句被哪些语句作为操作数使用。通过这种引用关系，我们可以很容易的得到<code>def-use</code>链和<code>use-def</code>链等，为后续优化做好了基础。</p><h3 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Value</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String value; <span class="comment">// 虚拟变量名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> valueType; <span class="comment">// 记录Value类型，具体如下</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;User&gt; users; <span class="comment">// 记录被哪些语句所使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> firstSize; <span class="comment">// 当为指针类型时，需要的额外维度参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> secondSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Value的类型人为规定如下，仍建议采用枚举类：</p><div class="table-container"><table><thead><tr><th>值</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>-1</td><td>常规 <code>store</code>, <code>move</code> 指令</td><td>用于表示无返回值的 <code>store</code> 和 <code>move</code> 指令</td></tr><tr><td>0</td><td><code>i32</code></td><td>32位整数</td></tr><tr><td>1</td><td><code>i32*</code></td><td>一维指针</td></tr><tr><td>2</td><td><code>[n x i32]*</code></td><td>一维数组的首地址或二维指针</td></tr><tr><td>3</td><td><code>[m x [n x i32]]*</code></td><td>二维数组的首地址</td></tr><tr><td>4</td><td><code>i1</code></td><td>1位布尔值</td></tr><tr><td>5</td><td><code>func</code></td><td>函数类型</td></tr><tr><td>6</td><td><code>basicblock</code></td><td>基本块引用</td></tr><tr><td>7</td><td><code>i32**</code></td><td>一维指针的地址</td></tr><tr><td>8</td><td><code>[n x i32]**</code></td><td>二维指针的地址</td></tr><tr><td>9(本次无关)</td><td><code>fakevalue</code></td><td>记录后续 <code>mem2reg</code> 时需要的假标签，在重命名步骤时被替换为真 <code>Value</code></td></tr><tr><td>10(本次无关)</td><td><code>storeValue</code></td><td>图着色优化新增，将溢出的变量 store 入内存所用的 <code>Value</code>，仅作为标识</td></tr></tbody></table></div><p><strong>以上12种类型可以表示所有类型Value，在LLVM生成以及在代码优化中会发挥大作用</strong></p><h3 id="User"><a href="#User" class="headerlink" title="User"></a>User</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">Value</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Value&gt; usedValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里简化了<code>Use</code>类，记录了当前<code>Value</code>使用过的<code>Value</code>，构建起<code>def-use</code>链。</p><p>其余全部结构皆继承<code>User</code>与<code>Value</code>，以<code>Value</code>为最终父类，构建起了LLVM的中端架构。</p><h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><h3 id="是否重新建表"><a href="#是否重新建表" class="headerlink" title="是否重新建表?"></a>是否重新建表?</h3><p>建树时已经生成过一份完整符号表，在每一个<code>Block</code>内记录符号表的<code>id</code>，由此生成LLVM时可实时获得当前层的符号表，<strong>复用旧符号表即可</strong>，无需再重建新的符号表。</p><p><strong>使用全局符号表的问题</strong>：符号进入顺序无法确定，如处理下述语句时，第一个<code>a</code>会查到该作用域新定义的<code>a</code>，而不是全局变量的<code>a</code>。</p><p><strong>解决方法</strong>：记录下符号表中每个符号的递增id，在定义语句出现时记录当前符号id，在非定义语句需要查表时，必须满足<strong>查到的符号id小于等于当前符号id</strong>，否则查到的符号在当前位置是<strong>还没定义过</strong>的，需要前往上层符号表继续查找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> b = a, a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="符号表的改动"><a href="#符号表的改动" class="headerlink" title="符号表的改动"></a>符号表的改动</h3><p>符号表中每个表项新增<code>Value</code>属性，记录<strong>存储该符号对应的Value</strong>，在后续使用到该符号时，我们可直接查符号表获取对应的<code>Value</code>，以生成中间代码。</p><h2 id="短路求值与条件语句，循环语句"><a href="#短路求值与条件语句，循环语句" class="headerlink" title="短路求值与条件语句，循环语句"></a>短路求值与条件语句，循环语句</h2><p><strong>and</strong>优先级高于<strong>or</strong></p><p>无论条件还是循环语句，其本质均是依赖于<code>icmp</code>跳转指令，仅仅是一些为有条件跳转，一些为无条件跳转的区别。故需要弄清，（1）跳转语句的位置，（2）标签的位置。</p><h3 id="条件语句的LLVM生成"><a href="#条件语句的LLVM生成" class="headerlink" title="条件语句的LLVM生成"></a>条件语句的LLVM生成</h3><h4 id="涉及文法"><a href="#涉及文法" class="headerlink" title="涉及文法"></a>涉及文法</h4><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stmt    → &#x27;if&#x27; &#x27;(&#x27; Cond &#x27;)&#x27; Stmt [ &#x27;else&#x27; Stmt ]</span><br><span class="line">Cond    → LOrExp</span><br><span class="line">RelExp  → AddExp | RelExp (&#x27;<span class="attribute">&lt;&#x27; | &#x27;&gt;</span>&#x27; | &#x27;<span class="attribute">&lt;=&#x27; | &#x27;&gt;</span>=&#x27;) AddExp</span><br><span class="line">EqExp   → RelExp | EqExp (&#x27;==&#x27; | &#x27;!=&#x27;) RelExp</span><br><span class="line">LAndExp → EqExp | LAndExp &#x27;&amp;&amp;&#x27; EqExp</span><br><span class="line">LOrExp  → LAndExp | LOrExp &#x27;||&#x27; LAndExp </span><br></pre></td></tr></table></figure><h4 id="跳转语句位置"><a href="#跳转语句位置" class="headerlink" title="跳转语句位置"></a>跳转语句位置</h4><ol><li>每个 <code>&amp;&amp;</code> ，<code>||</code> 处，<code>Cond</code>末尾处</li><li><code>Stmt</code> 末尾</li><li><code>elseStmt</code> 末尾</li></ol><h4 id="Label位置（即创建一个新基本块的位置）"><a href="#Label位置（即创建一个新基本块的位置）" class="headerlink" title="Label位置（即创建一个新基本块的位置）"></a>Label位置（即创建一个新基本块的位置）</h4><ul><li><p><code>Stmt</code>之前：<code>stmtLabel</code></p></li><li><p><code>elseStmt</code>之前：<code>elseStmtLabel</code></p></li><li><p><code>if</code>语句整体结束之后：<code>ifEndLabel</code></p></li><li><p>每个 <code>&amp;&amp;</code>，<code>||</code> 处：<code>andLabel</code>，<code>orLabel</code>（在相应的跳转语句之后）</p></li></ul><h4 id="短路求值"><a href="#短路求值" class="headerlink" title="短路求值"></a>短路求值</h4><p>不是全部的逻辑判断语句均要执行，我们称之为短路求值规则。在此给出每个位置跳转语句的跳转位置。</p><div class="table-container"><table><thead><tr><th>当前位置</th><th>后续逻辑</th><th>结果</th><th>跳转位置</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code>，“或”，<code>Cond</code>结尾</td><td><code>&amp;&amp;</code></td><td>真</td><td>下一个 <code>&amp;&amp;</code> 的 <code>andLabel</code></td></tr><tr><td></td><td></td><td>假</td><td>下一个 或 的 <code>orLabel</code>，若无 “或”，则跳转至 <code>elseStmtLabel</code></td></tr><tr><td></td><td>“或”</td><td>真</td><td><code>stmtLabel</code></td></tr><tr><td></td><td></td><td>假</td><td><code>orLabel</code></td></tr><tr><td></td><td>无</td><td>真</td><td><code>stmtLabel</code></td></tr><tr><td></td><td></td><td>假</td><td><code>elseStmtLabel</code></td></tr><tr><td><code>Stmt</code>末尾</td><td>-</td><td>-</td><td><code>ifEndLabel</code></td></tr><tr><td><code>elseStmt</code>末尾</td><td>-</td><td>-</td><td><code>ifEndLabel</code></td></tr></tbody></table></div><h4 id="重填法"><a href="#重填法" class="headerlink" title="重填法"></a>重填法</h4><p>由于Label出现的位置在跳转指令之后，无法第一时间填写Label名，因此需要在Label出现后重填跳转指令的标签。我们规定生成跳转指令时先使用如下假标签，采用上述规则生成:</p><ol><li><code>!nextOrLabel</code></li><li><code>!nextAndLabel</code></li><li><code>!stmtLabel</code></li><li><code>!elseStmtLabel</code></li><li><code>!ifEndLabel</code></li></ol><p>为每个条件语句开一个跳转指令列表，每当跳转指令出现时推入，每当真标签语句生成时，<strong>立即</strong>重填跳转指令列表中所有能匹配上的假标签。</p><p>立即重填的原因：<code>nextOrLabel</code>和<code>nextAndLabel</code>代表的位置会随着语句分析而变化。</p><h3 id="循环语句的LLVM生成"><a href="#循环语句的LLVM生成" class="headerlink" title="循环语句的LLVM生成"></a>循环语句的LLVM生成</h3><h4 id="涉及文法-1"><a href="#涉及文法-1" class="headerlink" title="涉及文法"></a>涉及文法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stmt    → &#x27;for&#x27; &#x27;(&#x27; [ForStmt1] &#x27;;&#x27; [Cond] &#x27;;&#x27; [ForStmt2] &#x27;)&#x27; Stmt </span><br><span class="line">        | &#x27;break&#x27; &#x27;;&#x27;</span><br><span class="line">        | &#x27;continue&#x27; &#x27;;&#x27;</span><br><span class="line">ForStmt → LVal &#x27;=&#x27; Exp</span><br></pre></td></tr></table></figure><h4 id="循环语句流程"><a href="#循环语句流程" class="headerlink" title="循环语句流程"></a>循环语句流程</h4><ol><li>执行初始化表达式<code>ForStmt1</code></li><li>执行条件表达式<code>Cond</code>，如果为真执行循环体<code>Stmt</code>，否则结束循环执行后续<code>BasicBlock</code></li><li>执行完循环体<code>Stmt</code>后执行增量/减量表达式<code>ForStmt2</code></li><li>重复执行步骤2和步骤3</li></ol><h4 id="Label位置"><a href="#Label位置" class="headerlink" title="Label位置"></a>Label位置</h4><ol><li>循环体语句<code>Stmt</code>之前：<code>stmtLabel</code></li><li>循环结束之后的第一条语句：<code>forEndLabel</code></li><li>循环条件改变语句<code>forStmt</code>之前：<code>forStmtLabel</code></li></ol><h4 id="跳转语句位置-1"><a href="#跳转语句位置-1" class="headerlink" title="跳转语句位置"></a>跳转语句位置</h4><ol><li><code>Cond</code>结尾，在此仅将<code>Cond</code>语句结尾作为一个跳转语句位置</li><li><code>break</code>后</li><li><code>continue</code>后</li><li><code>forStmt2</code>后</li><li><code>Stmt</code>后</li></ol><p>这部分多是无条件跳转，逻辑较简单，不过多赘述。</p><h4 id="Break-Continue的处理"><a href="#Break-Continue的处理" class="headerlink" title="Break, Continue的处理"></a>Break, Continue的处理</h4><p><code>Break</code>和<code>Continue</code>语法树节点生成时就要保存当前的<code>LoopStmt</code>节点引用信息，方便快速找到它是属于哪个循环语句的。</p><p><code>Continue</code>跳转到<code>forStmtLabel</code>，<code>Break</code>跳转到<code>forEndLabel</code>。</p><p><strong>注：条件或循环语句嵌套问题</strong>：每个<code>LoopStmt</code>，<code>CondStmt</code>都需要一个待重填指令的列表，即将各个语句的跳转指令分离开来，重填时避免混淆。</p><h2 id="高维数组"><a href="#高维数组" class="headerlink" title="高维数组"></a>高维数组</h2><p>符号表中记录的符号是一个地址，使用符号时从符号表中得到地址，再从地址中取出值；而定义符号时，先申请一块地址，再将值存入对应地址中。<strong>一维和二维数组首地址指针不会被存在内存中，但是它客观存在。</strong></p><h3 id="GetElementPtr"><a href="#GetElementPtr" class="headerlink" title="GetElementPtr"></a>GetElementPtr</h3><p>该指令为地址转化函数，使用的<code>Value(%1)</code>和返回的<code>Value(%2)</code>都一定是指针类型，对本文法而言，只有 <code>i32*</code>，<code>[n x i32]*</code>，<code>[m x [n x i32]]*</code> 三种。</p><pre><code>%2 = getelementptr [2 x [3 x i32]], [2 x [3 x i32]]*%1, i32 0, i32 0, i32 0</code></pre><p>对于该条语句，<code>%1</code>为基地址，<code>[2 x [3 x i32]]*</code>为该基地址指针的类型(若存到内存中均是4字节的地址，维度表明了该指针产生1单位偏移量时地址会随之偏移的多少)，<code>[2 x [3 x i32]]</code>为该基地址指针指向的值的类型，返回值<code>%2</code>为目标地址，指令后面跟的每一个索引（<code>i32 0, i32 0, i32 0</code>），第一个索引在原维度上偏移，自第二个起，先对目标地址降一维再偏移，依次类推，具体参考指令文档。</p><h3 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h3><p>高维数组传的是<strong>地址</strong>，不再是值。 第一个维度可以省略的原因是，需要后面的维度进行计算索引，而第一维不再需要，因为我们不需要关注数组越界问题。</p><ul><li><p>定义</p><ul><li>申请内存<ul><li>一维数组：<code>alloca [2 x i32]</code></li><li>二维数组：<code>alloca [3 x [2 x i32]]</code>，开辟一块指定大小的空间, 返回值是数组的首地址</li></ul></li><li>赋初值：遍历数组，根据基地址计算出需要赋初值的地址，接着同数值赋初值一样</li></ul></li><li><p><strong>表达式计算中使用</strong>：由于表达式计算中不涉及指针运算，先根据基地址和偏移量读取出使用位置的目标地址，再取值即可。</p></li><li><p><strong>传参</strong>：规定为统一起见，在涉及高维数组计算时，都要使用<code>getelementptr</code>指令进行基地址到目标地址的转化，即使出现<code>%2 = getelementptr [2 x [3 x i32]], [2 x [3 x i32]]*%1, i32 0</code>这种无意义指令。</p><ul><li>作为实参传递：根据符号表中查到的符号类型(分为一维数组，二维数组，一维指针，二维指针)与目标形参参数的类型(数值，一维指针，二维指针)，所有情况进行枚举分析。其中一定会使用到<code>GetElementPtr</code>指令，这在后续生成Mips有所用处。</li><li>作为形参接收：函数的形参实际上也是数个定义语句，将传过来的参数保存进定义的地址中即可。</li></ul></li></ul><h2 id="I1-➡-I32"><a href="#I1-➡-I32" class="headerlink" title="I1 ➡ I32"></a>I1 ➡ I32</h2><p>处理条件语句时，涉及<code>i1</code>和<code>i32</code>之间的相互转化(在MIPS中并无这类问题)，具体来说：</p><ol><li><p><code>icmp</code>语句的<code>Value</code>是<code>i1</code>类型，使用的两个操作数是i32类型。</p><pre><code>%2 = icmp ne i32 0, 0</code></pre></li><li><p><code>br</code>语句使用的比较操作数是<code>i1</code>类型。</p><pre><code>br i1 %2, label %12, label %3</code></pre></li></ol><p>条件跳转指令依赖于<code>EqExp</code>，我们统一规定<code>EqExp</code>返回<code>i1</code>类型的<code>Value</code>，<code>RelExp</code>返回<code>i32</code>类型的<code>Value</code>，当涉及到链式计算时，应使用<code>zext</code>指令将<code>i1</code>转化为<code>i32</code>类型；使用 <code>cmp ne 0</code> 将所有值为非零的<code>i32</code>转化为<code>i1 1</code>；值为零的<code>i32</code>转化为<code>i1 0</code>。</p><h2 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h2><p>生成LLVM后，并没有用到<code>Value</code>的<code>User</code>的列表，即并没有记录当前指令被哪些指令所使用，同时由于LLVM的特殊性，除了定义语句，其他值都是随用随从对应地址中取值，因此非定义的每个<code>Value</code>当且仅当被后续的一条指令所使用，记录下来并没有意义。</p><p>可以预见到如此做会产生极大量的内存读取指令，必然可以优化，根据<code>def-use</code>链的思想，在一个变量未赋新值前，都可以使用上一次赋值的虚拟变量，这样便省去了读取内存指令，然而这又涉及到基本块的关系以及分支间的选择(phi指令)，暂且留到优化文档中进行更深一步的探索。</p><h2 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h2><ul><li>链接两<code>.ll</code>文件，生成可执行文件 <code>clang main.ll lib.ll -o out.exe</code></li><li>执行 <code>.\out.exe</code></li><li>控制台输入 </li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 编译技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『编译技术』SysY-Mips编译器设计——语义分析(符号表管理与错误处理)</title>
      <link href="/post/eebe4e1.html"/>
      <url>/post/eebe4e1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『编译技术』SysY-Mips编译器设计——语义分析-符号表管理与错误处理"><a href="#『编译技术』SysY-Mips编译器设计——语义分析-符号表管理与错误处理" class="headerlink" title="『编译技术』SysY-Mips编译器设计——语义分析(符号表管理与错误处理)"></a>『编译技术』SysY-Mips编译器设计——语义分析(符号表管理与错误处理)</h1><p><strong>章节目录</strong></p><ul><li><strong><em><a href="https://yangyzzzz.github.io/post/80c7e14a.html">『编译技术』SysY-Mips编译器设计——总体设计概述</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/c6d56501.html">『编译技术』SysY-Mips编译器设计——词法分析</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/898866d1.html">『编译技术』SysY-Mips编译器设计——语法分析</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/eebe4e1.html">『编译技术』SysY-Mips编译器设计——语义分析(符号表管理与错误处理)</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/810d8044.html">『编译技术』SysY-Mips编译器设计——中间代码LLVM生成</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/a0d75678.html">『编译技术』SysY-Mips编译器设计——目标代码Mips生成</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/867e51bf.html">『编译技术』SysY-Mips编译器设计——中端代码优化</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/9f6855b5.html">『编译技术』SysY-Mips编译器设计——后端代码优化</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/dffb4f71.html">『编译技术』SysY-Mips编译器设计——实验总结</a></em></strong></li></ul><h2 id="零-作业要求"><a href="#零-作业要求" class="headerlink" title="零. 作业要求"></a>零. 作业要求</h2><p>设计并实现错误处理程序，能够诊断出题目要求的常见语法语义错误，并进行适当的局部化容错处理，输出程序中所有错误信息，包括类型与位置。</p><h2 id="一-错误编码"><a href="#一-错误编码" class="headerlink" title="一. 错误编码"></a>一. 错误编码</h2><p>本次作业只针对如下数条错误情况予以考虑。</p><ul><li><strong>a 非法符号</strong>：在字符串中出现的非法符号</li><li><strong>b 名字重定义</strong>：变量名在当前作用域下的重复定义，内层覆盖外层定义是合法的，必须是同层作用域才出错</li><li><strong>c 未定义的名字</strong>：使用未定义的标识符</li><li><strong>d 函数参数个数不匹配</strong>：调用语句中传参个数与符号表中函数定义时参数个数不一致</li><li><strong>e 函数参数类型不匹配</strong>：同上，参数类型不匹配</li><li><strong>f 无返回值的函数存在不匹配的return语句</strong>：void函数中任意地方出现return \<Exp\>。</Exp\></li><li><strong>g 有返回值的函数缺少return语句</strong>：只需要判断函数末尾有无return，报错行号为}所在行号</li><li><strong>h 改变常量的值</strong>：对const定义的常量进行修改</li><li><strong>i 缺少分号</strong></li><li><strong>j 缺少右小括号</strong></li><li><strong>k 缺少右中括号</strong>：以上三个报错行号为前一个非终结符所在行号</li><li><strong>l 输出语句格式字符与个数不匹配</strong></li><li><strong>m 非循环块使用continue和break</strong></li></ul><p>上述错误可大致分为两种，<strong>语法错误</strong>和<strong>语义错误</strong>，语法错误包括缺少符号(i,j,k)与输出语句中存在非法字符(a)，这些错误不满足文法要求；其余皆是语义错误，这些错误满足文法，然而不满足SysY语义限制。</p><p>进一步分析，其中b,c,d,e,h五种错误需要用到<strong>符号表</strong>，其余错误无需符号表辅助，可以通过在语法分析器基础上增添功能找寻错误。</p><h2 id="二-符号表"><a href="#二-符号表" class="headerlink" title="二. 符号表"></a>二. 符号表</h2><h3 id="建立符号表"><a href="#建立符号表" class="headerlink" title="建立符号表"></a>建立符号表</h3><p>无论错误处理是否需要，建立起符号表都是必须的，符号表中表项结构如下所示。</p><p><strong>BasicSymbol</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:center">属性名</th><th style="text-align:center">ID</th><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">是否常量</th><th style="text-align:center">行号</th></tr></thead><tbody><tr><td style="text-align:center"><strong>描述</strong></td><td style="text-align:center">自增ID，Symbol的唯一标识符</td><td style="text-align:center">符号名</td><td style="text-align:center">符号类型，规定 0-&gt;int,1-&gt;int[],2-&gt;int[][],3-&gt;func</td><td style="text-align:center">规定 0-&gt;变量，1-&gt;常量</td><td style="text-align:center">符号的行号，错误处理需要用到</td></tr></tbody></table></div><p><strong>FuncSymbol</strong>：</p><div class="table-container"><table><thead><tr><th>属性名</th><th>函数返回参数类型</th><th>函数形参个数</th><th>函数形参类型列表</th></tr></thead><tbody><tr><td><strong>描述</strong></td><td>规定 0-&gt;int, 1-&gt;void</td><td>记录函数形参个数</td><td>记录函数每个形参类型，规定如上</td></tr></tbody></table></div><p><strong>24.10.11补充</strong>：使用数字作为类型标记是不推荐的，易混淆也不方便他人理解，使用枚举类解决会更好！</p><p>每一张符号表存储<code>HashMap&lt;String, Symbol&gt;</code>，设计成哈希表一方面是由于每一张符号表的符号名不会重复，另一方面提高用符号名查询到对应<code>Symbol</code>的效率。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>每一个作用域对应一张符号表，开始一个新的作用域有两种情况，程序开始时的全局作用域以及每个<code>&lt;Block&gt;</code>都会开启新的作用域，因此要在这两处位置新建符号表。特别注意的是，<strong>函数定义时的形参应当放到紧接着函数主体开启的符号表当中</strong>。</p><p>作用域存在<strong>树状结构</strong>关系，符号表同理，查找符号时应当从当前作用域的符号表向全局作用域的符号表由底至上的搜索，这便需要我们记录下符号表的父节点。</p><p>因此一张符号表的结构如下所示。</p><div class="table-container"><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">ID</th><th style="text-align:center">父节点ID</th><th style="text-align:center">包含的所有符号</th></tr></thead><tbody><tr><td style="text-align:center"><strong>描述</strong></td><td style="text-align:center">自增ID，SymbolTable唯一标识符</td><td style="text-align:center">父符号表ID</td><td style="text-align:center"><code>HashMap&lt;String, Symbol&gt;</code></td></tr></tbody></table></div><p>在<code>Parser</code>中我们存储<code>HashMap&lt;Integer(id),SymbolTable&gt;</code>，便于我们通过<code>id</code>快速查找到对应的符号表。</p><h2 id="三-错误处理"><a href="#三-错误处理" class="headerlink" title="三. 错误处理"></a>三. 错误处理</h2><p>建立起符号表后，便可进行符号表相关的错误处理。符号表在当前需要提供如下两个功能。</p><ul><li>给定一标识符名，在当前符号表中查找是否出现过同名符号。</li><li>给定一标识符名，在树状符号表集合中由底至上查找是否出现过同名符号，直至全局作用域的符号表。</li></ul><p>第一个功能适用于判断是否出现<strong>标识符重定义</strong>；<br>第二个功能适用于判断是否出现<strong>标识符未定义</strong>，然而查到距离当前层最近的符号后，并不能直接下出标识符已定义的结论，还需要比较查到的符号类型和解析当前语法下需要的标识符类型，才能下定结论。</p><p>举例而言，<code>LVal</code>需要常变量类型，<code>UnaryExp</code>的函数调用分支需要函数类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如下所示 符号表查到的是函数类型的fun，而我们需要的是变量类型的fun，此时会出现“名字未定义”的错误</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fun = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他错误的判断逻辑不过多赘述。</p><h2 id="四-错误处理存在的Bug"><a href="#四-错误处理存在的Bug" class="headerlink" title="四. 错误处理存在的Bug"></a>四. 错误处理存在的Bug</h2><ul><li>当处理 <code>[&lt;Exp&gt;];</code> 中分号漏写的情况时产生问题。</li></ul><p><strong>问题原因</strong>：由于<code>Stmt</code>在判断<code>AssignStmt</code>,<code>InputStmt</code>,<code>ExpStmt</code>时使用的预读法会读走一个<code>Exp</code>，接着判断下一个单词是否是<code>&#39;;&#39;</code>来判断是属于哪类语句，然而若<code>&#39;;&#39;</code>不存在，则判断会产生异常。<br><strong>解决方法</strong>：将判断下一个字符是否为<code>&#39;;&#39;</code>改为判断是否为<code>&#39;=&#39;</code>即可，<code>&#39;=&#39;</code>不会出现缺失的情况。</p><ul><li><p><code>&lt;UnaryExp&gt; -&gt; Ident &#39;(&#39; &#123;&lt;FuncRParams&gt;&#125; &#39;)&#39;</code> 缺少右小括号的错误处理，即缺失某些符号时会在语法解析时引起二义性，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常</span></span><br><span class="line">b = <span class="built_in">a</span>() + <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 缺失&#x27;(&#x27;</span></span><br><span class="line">b = <span class="built_in">a</span>( + <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li></ul><p>​    <strong>问题原因</strong>：之前只需预读两位后判断当前单词是否是<code>&#39;)&#39;</code>即可判断是否存在实参，而存在缺失括号后，这个方法便不再适用</p><p>​    <strong>解决方法</strong>：预读两位后判断当前单词是否是<code>&lt;FuncRParams&gt;</code>的FIRST集来判断是否存在实参。</p><p>​    <strong>前提假设</strong>：由于<code>&lt;FuncRParams&gt;</code>的 FIRST 集包括 <code>&#123;&#39;+&#39;，&#39;-&#39;&#125;</code>，而<code>&lt;UnaryExp&gt;</code>的 FOLLOW 集中也包括 <code>&#123;&#39;+&#39;，&#39;-&#39;&#125;</code>，一旦去掉右小括号后会产生歧义。前提假设不会出现这种情况，即出现<code>&#123;&#39;+&#39;，&#39;-&#39;&#125;</code>时将其看作解析<code>&lt;FuncRParam&gt;</code>处理，这也符合C语言编译器的行为。</p><ul><li>主函数也要考虑无返回值的问题。</li><li><code>&#39;%&#39;</code> ascii码为37；<code>&#39;\&#39;</code>ascii码92 但是当且仅当和<code>\n</code>一起出现才算做合法，语法定义问题。</li><li>实参形参类型匹配中，应考虑到当实参是函数调用存在无返回值的错误情况。</li></ul><p>​    <strong>解决方法</strong>：遍历<code>Exp</code>树，将所有函数调用的函数名取出，查<strong>符号表</strong>依次判断其<strong>返回类型</strong>，若至少有一个<code>void</code>则需错误处理。</p><ul><li><code>printf</code>语句中同时出现非法字符和参数数目不相同。</li></ul><p>​    <strong>解决方法</strong>：为减少字符串遍历次数，我在词法分析时便记录了”%d”的个数与是否存在非法字符，并将其打包进<code>wordInfo</code>的实体中<code>value</code>属性。我们尝试将两部分信息合二为一，我们规定<code>value</code>记录”%d”的数量，若存在非法字符，将<code>value</code>取负再减一，如此语法分析器可通过<code>value</code>的正负信息及大小信息得到上述两种信息。</p><ul><li>处理注释时要保留换行符，不然行数会被打乱！</li></ul><h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h2><ul><li><p><strong>加入错误处理后语法解析思路需要改变</strong>：语法解析不能再过度依赖可能被删减的单词<code>&#39;)&#39;，&#39;&#125;&#39;，&#39;]&#39;，&#39;;&#39;</code>，需要另寻他路。</p><p>例如，在给<code>&lt;Stmt&gt;</code>分类时，赋值语句，表达式语句和输入语句需要预读判断，之前的思路是试探解析<code>Exp</code>后判断此时栈顶的单词是否为<code>&#39;;&#39;</code>，若是，则判定为表达式语句，反之则在另外两种语句中继续判断。而现在面临<code>&#39;;&#39;</code>可能缺失的问题，因此我们需要转换思路，输入语句和赋值语句在解析完Exp后下一个单词一定为<code>&#39;=&#39;</code>，反之则为表达式语句，颠倒了判断思路后即可解决。总之，<strong>不能依赖于可能丢失的单词作为解析后续文法的依据</strong>。</p></li><li><p>未考虑到的错误情况仍存在很多，且该任务已经为我们做了很多简化，每多考虑一种错误情况难度便会更上升一截。</p></li><li>学会使用C语言编译器(gcc)与我们的编译器做对照，观察gcc在错误处理时的行为，包括报错位置以及报错类型，尤其是存在多个报错的争议部分(比如名字未定义和函数参数类型不匹配同时出现)，并尽可能使我们的错误处理逻辑与其保持一致！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 编译技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『杂谈』What makes a good PhD student?</title>
      <link href="/post/5eeef2ab.html"/>
      <url>/post/5eeef2ab.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『杂谈』What-makes-a-good-PhD-student"><a href="#『杂谈』What-makes-a-good-PhD-student" class="headerlink" title="『杂谈』What makes a good PhD student?"></a>『杂谈』What makes a good PhD student?</h1><p>翻译自一篇Nature文章，作者是电气工程专业。</p><p>读博士应该是一趟充满乐趣且充满回报的旅程，因为你能够花费你的全部工作时间去发现探寻新想法，并且从中的得到回报，还不需要承担行政上的责任。尽管他们会得到很少的报酬，还会长时间工作，并且缺少安全感，但是那些执着于科学事业的研究者之所以如此做，是因为这是他们想要追求的全部。</p><p>不幸地是，大多数新博士生都是缺少提前准备的，并且因此他们之中的很少数将来会实现自己成为独立科研者的抱负。这主要的原因一是在多数大学存在固有的“成绩膨胀”情况，使得很难从毕业生中辨别出真正有天赋的一流学生，二是目前大学承担着培养越来越多博士生的压力。（The main reasons for this are the ‘grade creep’ inherent at most universities, making it difficult to identify the really talented first-class graduates from the rest, and the pressure on universities to graduate as many PhD students as possible.）结果是我们（学校/导师）招收（enrol）了太多的博士生而没有清楚告诉他们博士应该需要（entail）什么。我们因此将自己以及学生们都置入困难与沮丧的境地。</p><p>那么我们该向博士生给出哪些有前景的建议呢？</p><ul><li>选择一位导师，你钦佩他的工作并且他拥有足够的科研经费，得到部门机构的大力支持。</li><li>为你自己的项目负责。</li><li>努力工作——工作日和多数周末的大部分时间都要工作。如果研究的方向在你的兴趣点，那么这将很轻松，反之你可能在不适合你的领域。注意谁在结束一天工作后还带着材料回家继续工作，这便是成功的原因，而非结果。</li><li>在一些周末和体面的假期出去放松，这会使你不会燃尽。</li><li><strong>阅读你当前领域的文献，过去的，现在的，相关的。在你不知道当前领域已经发展到哪步时，你不可能对一篇文章做出原始贡献。</strong></li><li><strong>计划你每天和每周的安排要与你安排的实验相吻合（dovetail），以便最小化停工时间。（规划好实验安排，人和计算机可以异步而非同步）</strong></li><li><strong>保存一本实验笔记，并每天记录更新。</strong></li><li>要有创造力，时刻思考你在作什么，为什么做，是否寻找更好的方式去做。不要将博士的路线图看作是导师为你铺好的。</li><li><strong>培养良好写作能力</strong>：它将极大（immeasurably）轻松你的学术生涯</li><li><p>想要取得成功你必须至少具备一下四条：聪明，有自驱力，有创造力，努力工作，有熟练技巧，运气。你不能依赖于运气，所以最好聚焦于其他几个。</p></li><li><p>先完成，再完美~</p></li></ul><p>良好代码能力和领域内基本知识是基本功。已有记录的良好习惯，博士期间必须培养的能力：<strong>计划，阅读文献，写作</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 感想随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『编译技术』SysY-Mips编译器设计——总体设计概述</title>
      <link href="/post/80c7e14a.html"/>
      <url>/post/80c7e14a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『编译技术』SysY-Mips编译器设计——总体设计概述"><a href="#『编译技术』SysY-Mips编译器设计——总体设计概述" class="headerlink" title="『编译技术』SysY-Mips编译器设计——总体设计概述"></a>『编译技术』SysY-Mips编译器设计——总体设计概述</h1><p>本编译器源自『编译技术』课程设计，针对C语言子集<code>SysY</code>文法的源代码生成<code>Mips</code>体系架构目标代码。</p><p><strong><em><a href="https://github.com/wokron/tolangc/tree/master/docs/tutorials">2024年编译实验教程</a></em></strong></p><p><strong>章节目录</strong></p><ul><li><strong><em><a href="https://yangyzzzz.github.io/post/80c7e14a.html">『编译技术』SysY-Mips编译器设计——总体设计概述</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/c6d56501.html">『编译技术』SysY-Mips编译器设计——词法分析</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/898866d1.html">『编译技术』SysY-Mips编译器设计——语法分析</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/eebe4e1.html">『编译技术』SysY-Mips编译器设计——语义分析(符号表管理与错误处理)</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/810d8044.html">『编译技术』SysY-Mips编译器设计——中间代码LLVM生成</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/a0d75678.html">『编译技术』SysY-Mips编译器设计——目标代码Mips生成</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/867e51bf.html">『编译技术』SysY-Mips编译器设计——中端代码优化</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/9f6855b5.html">『编译技术』SysY-Mips编译器设计——后端代码优化</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/dffb4f71.html">『编译技术』SysY-Mips编译器设计——实验总结</a></em></strong></li></ul><h2 id="零-支持文法"><a href="#零-支持文法" class="headerlink" title="零. 支持文法"></a>零. 支持文法</h2><p><a href="https://github.com/YangYzzzz/2023Autumn-BUAA-CE/blob/main/2023%E7%BC%96%E8%AF%91%E5%AE%9E%E9%AA%8C%E6%96%87%E6%B3%95%E8%AF%B4%E6%98%8E.pdf"><strong>2023年编译技术实验文法说明</strong></a></p><h2 id="一-总体结构"><a href="#一-总体结构" class="headerlink" title="一. 总体结构"></a>一. 总体结构</h2><p>本编译器采用经典的前端-中端-后端架构，前端负责词法分析，语法分析，符号表建立，错误处理部分，中端负责生成中间代码LLVM以及中间代码优化，后端负责生成目标代码MIPS以及后端代码优化。</p><h2 id="二-接口设计"><a href="#二-接口设计" class="headerlink" title="二. 接口设计"></a>二. 接口设计</h2><p>本编译器秉持着高内聚，低耦合的思想，将核心功能完整封装在了各个子模块，而主类Compiler仅保留调用子模块的接口，编译步骤跟随调用的接口依次为：</p><ol><li><code>clearAnnotation</code>：删除代码中的注释</li><li><code>parseCompUnit</code>：语法分析，依据语法规则生成语法树，同时伴随着词法分析与生成符号表，并进行错误处理</li><li><code>printWrongInfo</code>：若代码出错，则打印报错信息并暂停编译过程</li><li><code>genLLVM</code>：生成中间代码LLVM，并将其逻辑结构保存在IrModule中</li><li><code>optimizeLLVM</code>：进行中间代码优化，通过调节IrModule中的FLAG可随时关闭/开启优化</li><li><code>setMipsModule</code>/<code>genMips</code>：将中间代码的结构依次装填入后端Mips的结构中，并生成最终的目标代码Mips</li></ol><h2 id="三-文件说明"><a href="#三-文件说明" class="headerlink" title="三. 文件说明"></a>三. 文件说明</h2><p><a href="https://github.com/YangYzzzz/2023Autumn-BUAA-CE">项目源码仓库</a></p><p>文件树如下所示：</p><ul><li><code>FrontEnd</code>：前端代码包<ul><li><code>Core</code>：内含语法分析器与词法分析器，是前端解析的精髓</li><li><code>Info</code>：存储解析中遇到的错误，单词等相关信息</li><li><code>NonTerminal</code>：存储文法内各个非终结符节点</li><li><code>SymbolTable</code>：存储符号表</li></ul></li><li><code>MidEnd</code>：中端代码包<ul><li><code>IrInstructions</code>：存储LLVM的相关指令</li><li><code>SymbolTable</code>：代码优化时用到，存储为mem2reg而重新构建了中间代码符号表</li><li><code>Tools</code>：一些工具类</li><li><code>IrCore</code>：内含Value, User, IrGlobal, IrFunction, IrBasicBlock, IrModule等LLVM中端架构类</li></ul></li><li><code>BackEnd</code>：后端代码包<ul><li><code>MipsInstructions</code>：存储Mips的相关指令</li><li><code>MipsCore</code>：完全模仿LLVM架构，构建出的Mips下的一套架构，用于将LLVM架构装配到后端，并进行Mips目标代码生成，其中MipsInstructionBlock为核心，它的作用是将一条LLVM语句翻译为多条Mips语句。</li><li><code>Compiler</code>：编译器启动类</li></ul></li></ul><h2 id="四-各章节目录"><a href="#四-各章节目录" class="headerlink" title="四. 各章节目录"></a>四. 各章节目录</h2><ul><li>『编译技术』SysY-Mips编译器设计——总体设计概述</li><li>『编译技术』SysY-Mips编译器设计——词法分析</li><li>『编译技术』SysY-Mips编译器设计——语法分析</li><li>『编译技术』SysY-Mips编译器设计——语义分析(符号表管理与错误处理)</li><li>『编译技术』SysY-Mips编译器设计——中间代码LLVM生成</li><li>『编译技术』SysY-Mips编译器设计——目标代码Mips生成</li><li>『编译技术』SysY-Mips编译器设计——中端代码优化</li><li>『编译技术』SysY-Mips编译器设计——后端代码优化</li><li>『编译技术』SysY-Mips编译器设计——实验总结</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 编译技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『编译技术』SysY-Mips编译器设计——语法分析</title>
      <link href="/post/898866d1.html"/>
      <url>/post/898866d1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『编译技术』SysY-Mips编译器设计——语法分析"><a href="#『编译技术』SysY-Mips编译器设计——语法分析" class="headerlink" title="『编译技术』SysY-Mips编译器设计——语法分析"></a>『编译技术』SysY-Mips编译器设计——语法分析</h1><p><strong>章节目录</strong></p><ul><li><strong><em><a href="https://yangyzzzz.github.io/post/80c7e14a.html">『编译技术』SysY-Mips编译器设计——总体设计概述</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/c6d56501.html">『编译技术』SysY-Mips编译器设计——词法分析</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/898866d1.html">『编译技术』SysY-Mips编译器设计——语法分析</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/eebe4e1.html">『编译技术』SysY-Mips编译器设计——语义分析(符号表管理与错误处理)</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/810d8044.html">『编译技术』SysY-Mips编译器设计——中间代码LLVM生成</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/a0d75678.html">『编译技术』SysY-Mips编译器设计——目标代码Mips生成</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/867e51bf.html">『编译技术』SysY-Mips编译器设计——中端代码优化</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/9f6855b5.html">『编译技术』SysY-Mips编译器设计——后端代码优化</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/dffb4f71.html">『编译技术』SysY-Mips编译器设计——实验总结</a></em></strong></li></ul><h2 id="零-任务目标"><a href="#零-任务目标" class="headerlink" title="零. 任务目标"></a>零. 任务目标</h2><p>设计并实现语法分析程序，分析语法成分，建立正确的语法树。</p><h2 id="一-终结符"><a href="#一-终结符" class="headerlink" title="一. 终结符"></a>一. 终结符</h2><ul><li>Ident</li><li>Number</li><li>FormatString（即使它有文法，仍将其看作终结符）</li><li>各种符号，关键字</li></ul><h2 id="二-非终结符"><a href="#二-非终结符" class="headerlink" title="二. 非终结符"></a>二. 非终结符</h2><p>将在下列出非终结符的FIRST以及是否有冲突情况，以便于解决后续问题；从简单至复杂分析，有助于分析复杂非终结符的FIRST。</p><div class="table-container"><table><thead><tr><th>非终结符</th><th>FIRST集</th><th>备注</th></tr></thead><tbody><tr><td><code>&lt;CompUnit&gt;</code></td><td><code>&#123;&#125;</code></td><td></td></tr><tr><td><code>&lt;LVal&gt;</code></td><td><code>&#123;Ident&#125;</code></td><td></td></tr><tr><td><code>&lt;PrimaryExp&gt;</code></td><td><code>&#123;&#39;(&#39;, Number, Ident&#125;</code></td><td></td></tr><tr><td><code>&lt;UnaryOp&gt;</code></td><td><code>&#123;&#39;+&#39;, &#39;-&#39;, &#39;!&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;UnaryExp&gt;</code></td><td><code>&#123;&#39;(&#39;, Number, Ident, &#39;+&#39;, &#39;-&#39;, &#39;!&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;MulExp&gt;</code></td><td><code>&#123;&#39;(&#39;, Number, Ident, &#39;+&#39;, &#39;-&#39;, &#39;!&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;AddExp&gt;</code></td><td><code>&#123;&#39;(&#39;, Number, Ident, &#39;+&#39;, &#39;-&#39;, &#39;!&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;ConstExp&gt;</code></td><td><code>&#123;&#39;(&#39;, Number, Ident, &#39;+&#39;, &#39;-&#39;, &#39;!&#39;&#125;</code></td><td>特殊: Ident只能是常量</td></tr><tr><td><code>&lt;Exp&gt;</code></td><td><code>&#123;&#39;(&#39;, Number, Ident, &#39;+&#39;, &#39;-&#39;, &#39;!&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;ForStmt&gt;</code></td><td><code>&#123;Ident&#125;</code></td><td></td></tr><tr><td><code>&lt;FuncRParams&gt;</code></td><td><code>&#123;&#39;(&#39;, Number, Ident, &#39;+&#39;, &#39;-&#39;, &#39;!&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;RelExp&gt;</code></td><td><code>&#123;&#39;(&#39;, Number, Ident, &#39;+&#39;, &#39;-&#39;, &#39;!&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;EqExp&gt;</code></td><td><code>&#123;&#39;(&#39;, Number, Ident, &#39;+&#39;, &#39;-&#39;, &#39;!&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;LAndExp&gt;</code></td><td><code>&#123;&#39;(&#39;, Number, Ident, &#39;+&#39;, &#39;-&#39;, &#39;!&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;LOrExp&gt;</code></td><td><code>&#123;&#39;(&#39;, Number, Ident, &#39;+&#39;, &#39;-&#39;, &#39;!&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;Cond&gt;</code></td><td><code>&#123;&#39;(&#39;, Number, Ident, &#39;+&#39;, &#39;-&#39;, &#39;!&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;Block&gt;</code></td><td><code>&#123;&#39;&#123;&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;Stmt&gt;</code></td><td><code>&#123;&#39;if&#39;, &#39;for&#39;, &#39;break&#39;, &#39;continue&#39;, &#39;return&#39;, Ident, &#39;printf&#39;, &#39;&#123;&#39;, &#39;;&#39;, &#39;(&#39;, Number, &#39;+&#39;, &#39;-&#39;, &#39;!&#39;&#125;</code></td><td><strong>存在冲突</strong></td></tr><tr><td><code>&lt;ConstDecl&gt;</code></td><td><code>&#123;&#39;const&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;ConstDef&gt;</code></td><td><code>&#123;Ident&#125;</code></td><td></td></tr><tr><td><code>&lt;ConstInitVal&gt;</code></td><td><code>&#123;&#39;(&#39;, Number, Ident, &#39;+&#39;, &#39;-&#39;, &#39;!&#39;, &#39;&#123;&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;BType&gt;</code></td><td><code>&#123;&#39;int&#39;&#125;</code></td><td>可能要增加基本类型，因此不能将其视为终结符</td></tr><tr><td><code>&lt;VarDecl&gt;</code></td><td><code>&#123;&#39;int&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;Decl&gt;</code></td><td><code>&#123;&#39;int&#39;, &#39;const&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;VarDef&gt;</code></td><td><code>&#123;Ident&#125;</code></td><td><strong>存在冲突</strong></td></tr><tr><td><code>&lt;Initial&gt;</code></td><td><code>&#123;&#39;(&#39;, Number, Ident, &#39;+&#39;, &#39;-&#39;, &#39;!&#39;, &#39;&#123;&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;FuncType&gt;</code></td><td><code>&#123;&#39;void&#39;, &#39;int&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;FuncDef&gt;</code></td><td><code>&#123;&#39;void&#39;, &#39;int&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;MainFuncDef&gt;</code></td><td><code>&#123;&#39;int&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;FuncFParam&gt;</code></td><td><code>&#123;&#39;int&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;FuncFParams&gt;</code></td><td><code>&#123;&#39;int&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;BlockItem&gt;</code></td><td><code>&#123;&#39;const&#39;, &#39;int&#39;, &#39;if&#39;, &#39;for&#39;, &#39;break&#39;, &#39;continue&#39;, &#39;return&#39;, Ident, &#39;printf&#39;, &#39;&#123;&#39;, &#39;;&#39;, &#39;(&#39;, Number, &#39;+&#39;, &#39;-&#39;, &#39;!&#39;&#125;</code></td><td></td></tr><tr><td><code>&lt;CompUnit&gt;</code></td><td><code>&#123;&#39;int&#39;, &#39;const&#39;, &#39;void&#39;&#125;</code></td><td><strong>存在冲突</strong></td></tr></tbody></table></div><h2 id="三-解决非终结符具有多产生式的问题"><a href="#三-解决非终结符具有多产生式的问题" class="headerlink" title="三. 解决非终结符具有多产生式的问题"></a>三. 解决非终结符具有多产生式的问题</h2><p>由上述分析可以得到总共有<strong>四</strong>处非终结符的FIRST存在冲突，接下来依次给出解决方案：</p><p><strong>语句冲突</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FrontEnd.NonTerminal.AllStmt → LVal &#x27;=&#x27; Exp &#x27;;&#x27;</span><br><span class="line">    | [Exp] &#x27;;&#x27;</span><br><span class="line">    | Block</span><br><span class="line">    | &#x27;if&#x27; &#x27;(&#x27; Cond &#x27;)&#x27; AllStmt [ &#x27;else&#x27; AllStmt ]</span><br><span class="line">    | &#x27;for&#x27; &#x27;(&#x27; [ForStmt] &#x27;;&#x27; [Cond] &#x27;;&#x27; [ForStmt] &#x27;)&#x27; AllStmt</span><br><span class="line">    | &#x27;break&#x27; &#x27;;&#x27;</span><br><span class="line">    | &#x27;continue&#x27; &#x27;;&#x27;</span><br><span class="line">    | &#x27;return&#x27; [Exp] &#x27;;&#x27;</span><br><span class="line">    | LVal &#x27;=&#x27; &#x27;getint&#x27;&#x27;(&#x27;&#x27;)&#x27;&#x27;;&#x27;</span><br><span class="line">    | &#x27;printf&#x27;&#x27;(&#x27;FormatString&#123;&#x27;,&#x27;Exp&#125;&#x27;)&#x27;&#x27;;&#x27;</span><br></pre></td></tr></table></figure><p>主要体现分支中两个<code>LVal</code>和<code>Exp</code>的 FIRST 集合存在交集{<code>Ident</code>}，若当前词法分析的单词为<code>Ident</code>，我们就无法判断该从哪一个分支进行解析。考虑到<code>Exp</code>可以推理出<code>LVal</code>（<code>Exp</code> ➡ <code>AddExp</code> ➡ <code>MulExp</code> ➡ <code>UnaryExp</code> ➡ <code>PrimaryExp</code> ➡ <code>LVal</code>），因此我们可以用<code>Exp</code>的解析方法来解析<code>LVal</code>。如果当前单词为<code>Ident</code>，则</p><ul><li>首先利用调用<code>Exp</code>的子程序来解析出语法成分<code>Exp</code>，判断下一个单词是<code>&#39;;&#39;</code>还是<code>&#39;=&#39;</code>，如果是<code>&#39;;&#39;</code>，则按第三条产生式处理，完成Stmt解析，否则转第2步，从前两条产生式中选择一条解析</li><li>从<code>Exp</code>提取出<code>LVal</code>（该<code>Exp</code>一定由唯一的<code>LVal</code>组成），继续判断下一个单词是不是<code>&#39;getint&#39;</code>，如果是则按第二条产生式处理，否则按第一条产生式处理，完成<code>Stmt</code>解析</li></ul><p><strong>变量定义冲突</strong></p><pre><code>VarDef -&gt; Ident &#123; &#39;[&#39; ConstExp &#39;]&#39; &#125; | Ident &#123; &#39;[&#39; ConstExp &#39;]&#39; &#125; &#39;=&#39; InitVal</code></pre><p>两分支 FIRST 存在交集{<code>Ident</code>}，不难发现前半部分都相同，因此改写文法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VarDef -&gt; Ident &#123; &#x27;[&#x27; ConstExp &#x27;]&#x27; &#125; [ &#x27;=&#x27; InitVal ]</span><br></pre></td></tr></table></figure><p><strong>编译单元冲突</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompUnit -&gt; &#123; Decl &#125; &#123; FuncDef &#125; MainFuncDef</span><br></pre></td></tr></table></figure><p>虽然其中没有分支，但是也算是分支文法的改写形式，<code>Decl</code>，<code>FuncDef</code>，<code>MainFuncDef</code>的FIRST集存在交集{<code>&#39;int&#39;</code>}</p><p>解决方法，使用<strong>未来探测法</strong>：</p><ul><li>若当前读取到的词是<code>int</code>，则继续预读下一个单词，若是<code>main</code>，则回退并进入主函数解析；若都为变量名，则跳转第二步</li><li>再读取下一个单词，若是<code>&#39;(&#39;</code>则跳转到函数定义解析，若为其他(具体来说包含<code>&#39;=&#39;</code>, <code>&#39;;&#39;</code>,<code>&#39;[&#39;</code>)则跳转到变量声明解析中，别忘了此时要<strong>回退两个单词</strong>!</li></ul><p><strong>一元表达式冲突</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnaryExp -&gt; PrimaryExp | Ident &#x27;(&#x27; [FuncRParams] &#x27;)&#x27;</span><br></pre></td></tr></table></figure><p><code>PrimaryExp</code>和<code>Ident</code>的FIRST集合存在交集{<code>Ident</code>}，因此当首单词为<code>Ident</code>时仍使用未来探测法来预读下一个单词，若为<code>&#39;(&#39;</code>则进入第二分支进行解析，反之回退，并进入第一分支进行解析。</p><h2 id="四-左递归文法的改写"><a href="#四-左递归文法的改写" class="headerlink" title="四. 左递归文法的改写"></a>四. 左递归文法的改写</h2><p>通过理论课程的学习，我们知道左递归文法是无法被自顶向下分析解析的，因为会无限递归，因此对于左递归文法需要改写。</p><p>左递归文法全部出现在各类表达式文法当中，统计并改写如下：</p><ul><li>乘除模表达式</li></ul><pre><code>MulExp -&gt; UnaryExp &#123; (&#39;*&#39; | &#39;/&#39; | &#39;%&#39;) UnaryExp &#125;</code></pre><ul><li>加减表达式</li></ul><pre><code>AddExp -&gt; FrontEnd.NonTerminal.MulExp &#123; (&#39;+&#39; | &#39;-&#39;) MulExp &#125;</code></pre><ul><li>关系表达式</li></ul><pre><code>RelExP -&gt; AddExp &#123; (&#39;&lt;&#39; | &#39;&gt;&#39; | &#39;&lt;=&#39; | &#39;&gt;=&#39;) AddExp &#125;</code></pre><ul><li>相等表达式</li></ul><pre><code>EqExp -&gt; RelExp &#123; (&#39;==&#39; | &#39;!=&#39;) RelExp &#125;</code></pre><ul><li>逻辑与表达式</li></ul><pre><code>LAndExp -&gt; EqExp &#123; &#39;&amp;&amp;&#39; EqExp &#125;</code></pre><ul><li>逻辑或表达式</li></ul><pre><code>LOrExp -&gt; LAndExp &#123; &#39;||&#39; LAndExp &#125;</code></pre><p><strong>注意</strong>：我们为了能正确分析而改写了文法，但是输出结果应与原文法保持相同，例如 <code>2+3</code> ，使用改写后文法将<code>+</code>两边都看作<code>MulExp</code>，然而按照实际文法中，<code>+</code>左边为<code>AddExp</code>，<code>+</code>右边为<code>MulExp</code>。</p><p><strong>解决方法</strong>：可以在每次解析(<code>&#39;+&#39;</code> | <code>&#39;−&#39;</code>) <code>MulExp</code>之前，先将之前已经解析出的若干个<code>MulExp</code>合成一个<code>AddExp</code>，输出一次<code>&lt;AddExp&gt;</code>。</p><h2 id="五-规定"><a href="#五-规定" class="headerlink" title="五. 规定"></a>五. 规定</h2><p>为了确保语法分析和词法分析的配合，我们做出如下规定供参考：</p><ul><li>一个子程序在调用其他子程序前，需要调用词法分析器来预读一个单词</li><li>一个子程序在退出时，需要调用词法分析器来预读一个单词</li></ul><p>有了上述规定，就可以确保：</p><ul><li>刚进入一个子程序时，词法分析器已经预读好了一个单词</li><li>从一个子程序返回时，词法分析器已经预读好了一个单词</li></ul><p>再规定：</p><ul><li>进入一个解析函数中，先创建该类实例，再按流程逐步填充对象，最后整体返回</li></ul><h2 id="六-语法分析Bug"><a href="#六-语法分析Bug" class="headerlink" title="六. 语法分析Bug"></a>六. 语法分析Bug</h2><ul><li><p>先新建Parser类导致Lexer提前预读，致使注释无法正常清除，应当先清注释再 <code>new Parser()</code>；</p></li><li><p>定义时<code>Ident</code>后面Follow的终结符情况未考虑完全，少考虑了一种如<code>int i, j;</code>带有逗号的情况。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 编译技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『编译技术』SysY-Mips编译器设计——词法分析</title>
      <link href="/post/c6d56501.html"/>
      <url>/post/c6d56501.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『编译技术』SysY-Mips编译器设计——词法分析"><a href="#『编译技术』SysY-Mips编译器设计——词法分析" class="headerlink" title="『编译技术』SysY-Mips编译器设计——词法分析"></a>『编译技术』SysY-Mips编译器设计——词法分析</h1><p><strong>章节目录</strong></p><ul><li><strong><em><a href="https://yangyzzzz.github.io/post/80c7e14a.html">『编译技术』SysY-Mips编译器设计——总体设计概述</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/c6d56501.html">『编译技术』SysY-Mips编译器设计——词法分析</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/898866d1.html">『编译技术』SysY-Mips编译器设计——语法分析</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/eebe4e1.html">『编译技术』SysY-Mips编译器设计——语义分析(符号表管理与错误处理)</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/810d8044.html">『编译技术』SysY-Mips编译器设计——中间代码LLVM生成</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/a0d75678.html">『编译技术』SysY-Mips编译器设计——目标代码Mips生成</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/867e51bf.html">『编译技术』SysY-Mips编译器设计——中端代码优化</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/9f6855b5.html">『编译技术』SysY-Mips编译器设计——后端代码优化</a></em></strong></li><li><strong><em><a href="https://yangyzzzz.github.io/post/dffb4f71.html">『编译技术』SysY-Mips编译器设计——实验总结</a></em></strong></li></ul><h2 id="零-任务目标"><a href="#零-任务目标" class="headerlink" title="零. 任务目标"></a>零. 任务目标</h2><p>设计并实现词法分析程序，从源程序中识别出单词，记录其单词类别和单词值。</p><h2 id="一-SysY文法的单词（Token）"><a href="#一-SysY文法的单词（Token）" class="headerlink" title="一. SysY文法的单词（Token）"></a>一. SysY文法的单词（Token）</h2><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/img_16.png" alt="img_16.png"></p><h2 id="二-词法解析器Lexer设计"><a href="#二-词法解析器Lexer设计" class="headerlink" title="二. 词法解析器Lexer设计"></a>二. 词法解析器Lexer设计</h2><p>词法解析器通过扫描输入的源程序字符串，将其分割成一个个单词，同时记录这些单词的类别信息，主要用途在于耦合进后续的语法解析器，使得语法解析器在解析文法时词法解析器可以源源不断为其提供语法解析的最小单元，<strong>单词</strong>。</p><p>因此我们的词法解析主要功能有二：</p><ol><li>不影响其他的基础上消除掉单行注释与多行注释</li><li>依次将每个单词及其相应信息打包取出，直至输入文件结束</li></ol><p>我们定义Lexer类，内部属性有：</p><ol><li><code>input</code>：输入字符串</li><li><code>pos</code>：当前解析到的位置</li><li><code>curWordInfo</code>：记录当前读到的单词种类，单词值，行数等信息</li></ol><p>方法有：</p><ol><li><code>next</code>：读取下一个单词</li><li><code>peek</code>：获取当前单词信息</li></ol><p>本质上我们读取单词的过程等价于一台有限状态自动机，词法解析(next函数)的基本逻辑如下图所示：</p><p><img src="/post/c6d56501/Users\大三上\编译原理\代码优化\blog\img_17.png" alt="img_17.png"></p><h2 id="三-词法分析的预读策略"><a href="#三-词法分析的预读策略" class="headerlink" title="三. 词法分析的预读策略"></a>三. 词法分析的预读策略</h2><p>我们发现单词中有一些单词存在前缀重叠的情况，如<code>&#39;&lt;&#39;</code>和<code>&#39;&lt;=&#39;</code>，对于这些前缀重叠的单词，从词法层面我们既可以认为这是一个单词，也同样可以认为是两个单词，因此我们单单读入一个符号是无法判断的，需要预读下一个字符来判断是哪一种单词。</p><h2 id="四-词法分析Bug"><a href="#四-词法分析Bug" class="headerlink" title="四. 词法分析Bug"></a>四. 词法分析Bug</h2><ul><li>注释消除有误，<code>StrCon</code>内存在<code>&quot;//...&quot;</code>时也会被当作注释消除，应在消除注释时特判此种情况。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 编译技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『保研经历』保研经历Part4——暑假插曲</title>
      <link href="/post/27a5ffcb.html"/>
      <url>/post/27a5ffcb.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『保研经历』保研经历Part4——暑假插曲"><a href="#『保研经历』保研经历Part4——暑假插曲" class="headerlink" title="『保研经历』保研经历Part4——暑假插曲"></a>『保研经历』保研经历Part4——暑假插曲</h1><p>保研后记，聊一聊人生迄今最焦虑的一个暑假我是怎么度过的，本Part暂时搁置一下，后续补齐。</p><h2 id="计算所暑期学校"><a href="#计算所暑期学校" class="headerlink" title="计算所暑期学校"></a>计算所暑期学校</h2>]]></content>
      
      
      <categories>
          
          <category> 感想随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『计算机组成原理』具备外设交互与异常处理功能的五级流水线CPU设计文档（潦草版）</title>
      <link href="/post/54aa859c.html"/>
      <url>/post/54aa859c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『计算机组成原理』具备外设交互与异常处理功能的五级流水线CPU设计文档（潦草版）"><a href="#『计算机组成原理』具备外设交互与异常处理功能的五级流水线CPU设计文档（潦草版）" class="headerlink" title="『计算机组成原理』具备外设交互与异常处理功能的五级流水线CPU设计文档（潦草版）"></a>『计算机组成原理』具备外设交互与异常处理功能的五级流水线CPU设计文档（潦草版）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于笔者大二上学期还停留在记纸质笔记的睿智阶段，因此丢失了很多宝贵的计组材料。但计组带我真正踏入了计算机领域的大门，那段时光也是最一心向学的美好记忆，故有必要整理下仍能找到的材料，主要集中在P7与P8部分。</p><h2 id="主控制信号"><a href="#主控制信号" class="headerlink" title="主控制信号"></a>主控制信号</h2><p>基于Mips汇编开发。</p><h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><div class="table-container"><table><thead><tr><th>指令</th><th>NPCSel</th><th>ExtOp</th><th>RegDst</th><th>ALUSrc</th><th>ALUControl</th><th>MemWrite</th><th>RegWriteSel</th><th>RegWrite</th><th>TuseRs</th><th>TuseRt</th><th>Tnew</th><th>Op</th><th>Func</th><th>DataExtOp</th></tr></thead><tbody><tr><td>位数</td><td>[1:0]</td><td>[1:0]</td><td>[1:0]</td><td>[1:0]</td><td>[2:0]</td><td>[0:0]</td><td>[1:0]</td><td>[0:0]</td><td>[1:0]</td><td>[1:0]</td><td>[1:0]</td><td>[5:0]</td><td>[5:0]</td><td>[2:0]</td></tr><tr><td>ADD</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>000000</td><td>100000</td><td>0</td></tr><tr><td>SUB</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>000000</td><td>100010</td><td>0</td></tr><tr><td>AND</td><td>0</td><td>0</td><td>1</td><td>0</td><td>4</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>000000</td><td>100100</td><td>0</td></tr><tr><td>OR</td><td>0</td><td>0</td><td>1</td><td>0</td><td>2</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>000000</td><td>100101</td><td>0</td></tr><tr><td>SLT</td><td>0</td><td>0</td><td>1</td><td>0</td><td>5</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>000000</td><td>101010</td><td>0</td></tr><tr><td>SLTU</td><td>0</td><td>0</td><td>1</td><td>0</td><td>6</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>000000</td><td>101011</td><td>0</td></tr><tr><td>ORI</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td><td>0</td><td>1</td><td>1</td><td>3</td><td>1</td><td>001101</td><td></td><td>0</td></tr><tr><td>ADDI</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>3</td><td>1</td><td>001000</td><td></td><td>0</td></tr><tr><td>ANDI</td><td>0</td><td>0</td><td>0</td><td>1</td><td>4</td><td>0</td><td>0</td><td>1</td><td>1</td><td>3</td><td>1</td><td>001100</td><td></td><td>0</td></tr><tr><td>LUI</td><td>0</td><td>2</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>3</td><td>1</td><td>001111</td><td></td><td>0</td></tr><tr><td>LW</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>3</td><td>2</td><td>100011</td><td></td><td>0</td></tr><tr><td>SW</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>2</td><td>“0”</td><td>101011</td><td></td><td>0</td></tr><tr><td>JAL</td><td>2</td><td>0</td><td>2</td><td>0</td><td>0</td><td>0</td><td>2</td><td>1</td><td>3</td><td>3</td><td>0</td><td>000011</td><td></td><td>0</td></tr><tr><td>JR</td><td>3</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>3</td><td>“0”</td><td>000000</td><td>001000</td><td>0</td></tr><tr><td>BEQ</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>“0”</td><td>000100</td><td></td><td>0</td></tr><tr><td>BNE</td><td>4</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>“0”</td><td>000101</td><td></td><td>0</td></tr><tr><td>SLL</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>0</td><td>0</td><td>1</td><td>1</td><td>3</td><td>1</td><td>000000</td><td>000000</td><td>0</td></tr><tr><td>LB</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>3</td><td>2</td><td>100000</td><td></td><td>2</td></tr><tr><td>LH</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>3</td><td>2</td><td>100001</td><td></td><td>4</td></tr><tr><td>SB</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>3</td><td>0</td><td>0</td><td>1</td><td>2</td><td>“0”</td><td>101000</td><td></td><td>0</td></tr><tr><td>SH</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>2</td><td>0</td><td>0</td><td>1</td><td>2</td><td>“0”</td><td>101001</td><td></td><td>0</td></tr></tbody></table></div><h3 id="乘除指令"><a href="#乘除指令" class="headerlink" title="乘除指令"></a>乘除指令</h3><div class="table-container"><table><thead><tr><th>指令</th><th>NPCSel</th><th>ExtOp</th><th>RegDst</th><th>ALUSrc</th><th>ALUControl</th><th>MemWrite</th><th>RegWriteSel</th><th>RegWrite</th><th>TuseRs</th><th>TuseRt</th><th>Tnew</th><th>Op</th><th>Func</th><th>DataExtOp</th><th>MDControl</th><th>MDDataOp</th></tr></thead><tbody><tr><td>MULT</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>‘0’</td><td>000000</td><td>011000</td><td>0</td><td>1</td><td>0</td></tr><tr><td>MULTU</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>‘0’</td><td>000000</td><td>011001</td><td>0</td><td>2</td><td>0</td></tr><tr><td>DIV</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>‘0’</td><td>000000</td><td>011010</td><td>0</td><td>3</td><td>0</td></tr><tr><td>DIVU</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>‘0’</td><td>000000</td><td>011011</td><td>0</td><td>4</td><td>0</td></tr><tr><td>MTLO</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>3</td><td>‘0’</td><td>000000</td><td>010011</td><td>0</td><td>5</td><td>0</td></tr><tr><td>MTHI</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>3</td><td>‘0’</td><td>000000</td><td>010001</td><td>0</td><td>6</td><td>0</td></tr><tr><td>MFLO</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>3</td><td>1</td><td>3</td><td>3</td><td>1</td><td>000000</td><td>010010</td><td>0</td><td>7</td><td>0</td></tr><tr><td>MFHI</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>3</td><td>1</td><td>3</td><td>3</td><td>1</td><td>000000</td><td>010000</td><td>0</td><td>7</td><td>1</td></tr></tbody></table></div><h3 id="中断异常指令"><a href="#中断异常指令" class="headerlink" title="中断异常指令"></a>中断异常指令</h3><div class="table-container"><table><thead><tr><th>指令</th><th>NPCSel</th><th>ExtOp</th><th>RegDst</th><th>ALUSrc</th><th>ALUControl</th><th>MemWrite</th><th>RegWriteSel</th><th>RegWrite</th><th>TuseRs</th><th>TuseRt</th><th>Tnew</th><th>Op</th><th>Func</th><th>Rs</th><th>CPUWrite</th><th>ExcCode</th><th>EXLClr</th></tr></thead><tbody><tr><td>SYSCALL</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>3</td><td>3</td><td>0</td><td>000000</td><td>001100</td><td></td><td>0</td><td>8</td><td>0</td></tr><tr><td>ERET</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>3</td><td>0</td><td>0</td><td>010000(CP0指令)</td><td>011000</td><td></td><td>0</td><td>1</td><td>1</td></tr><tr><td>MTC0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>3</td><td>2</td><td>0</td><td>010000</td><td></td><td>00100</td><td>1</td><td>0</td><td>0</td></tr><tr><td>MFC0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>4</td><td>1</td><td>3</td><td>3</td><td>2</td><td>010000</td><td></td><td>00000</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></div><h2 id="控制信号含义"><a href="#控制信号含义" class="headerlink" title="控制信号含义"></a>控制信号含义</h2><div class="table-container"><table><thead><tr><th>取值</th><th>功用</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>nPCSel</td><td>下一条地址</td><td>正常PC+4</td><td>小跳转偏移offset</td><td>大跳转 imm26</td><td>GRF值</td><td></td><td></td><td></td><td></td></tr><tr><td>ExtOp</td><td>立即数扩展</td><td>无/0扩展</td><td>符号扩展</td><td>立即数置高位</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>RegDst</td><td>写入GRF地址</td><td>Rt</td><td>Rd</td><td>31</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>ALUSrc</td><td>ALU第二计算数选择</td><td>GRF读出的第二个数</td><td>立即数</td><td>Rt(移位操作)</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>ALUControl</td><td>ALU计算操作</td><td>无/加法</td><td>减法</td><td>或</td><td>逻辑左移</td><td>与</td><td>有符号小于置1</td><td>无符号小于置1</td><td></td></tr><tr><td>MemWrite</td><td>是否写入存储器&amp;处理写入数据</td><td>否</td><td>SW是</td><td>SH是</td><td>SB是</td><td></td><td></td><td></td><td></td></tr><tr><td>RegWrite</td><td>是否写入寄存器</td><td>否</td><td>是</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>RegWriteSel</td><td>写入寄存器的值选择</td><td>ALU计算结果</td><td>存储器读出结果</td><td>PC+8</td><td>乘除模块HILO读出结果</td><td>CP0协处理器读出结果</td><td></td><td></td><td></td></tr><tr><td>DataExtOp</td><td>处理存储器读出数据</td><td>无处理</td><td>无符号扩展字节</td><td>有符号扩展字节(LB)</td><td>无符号扩展半字</td><td>有符号扩展半字(LH)</td><td></td><td></td><td></td></tr><tr><td>MDControl</td><td>乘除模块操作&amp;判断是否为乘除指令</td><td>非乘除指令</td><td>有符号乘</td><td>无符号乘</td><td>有符号除</td><td>无符号除</td><td>写入LO</td><td>写入HI</td><td>读出HI/LO</td></tr><tr><td>MDDataOp</td><td>乘除模块读出选择</td><td>无/LO</td><td>HI</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>CP0Write</td><td>是否写入CP0模块</td><td>否</td><td>是</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>ExcCode</td><td>D级产生的(因特殊指令而产生的)异常码</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>EXLClr</td><td>是否清空M级前流水线寄存器</td><td>否</td><td>是(ERET专属)</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><p><strong>注</strong>：</p><ul><li>此处<strong>ALUControl</strong>是宏观整体行为，未考虑不同异常处理情况，其进一步针对不同异常码的改造见下文</li><li>乘除指令与中断异常指令表格中其余未包含的控制信号均为0</li><li>MemWrite信号需配合Addr[1:0]进一步判断产生Byteen信号</li></ul><h3 id="ALUControl改造"><a href="#ALUControl改造" class="headerlink" title="ALUControl改造"></a>ALUControl改造</h3><p>为应对P7出现的ExcCode码，需要将一个操作细分为若干个操作，以判断出相应的异常码</p><div class="table-container"><table><thead><tr><th>ALUControl</th><th>NUM</th><th>运用指令</th></tr></thead><tbody><tr><td>ADD_UNSIGN</td><td>0</td><td>其余一般无符号运算</td></tr><tr><td>ADD_SIGN</td><td>1</td><td>ADDI，ADD</td></tr><tr><td>SUB_SIGN</td><td>2</td><td>SUB</td></tr><tr><td>OR</td><td>3</td><td>OR，ORI</td></tr><tr><td>AND</td><td>4</td><td>AND，ANDI</td></tr><tr><td>SLT</td><td>5</td><td>SLT</td></tr><tr><td>SLTU</td><td>6</td><td>SLTI</td></tr><tr><td>ADD_LW</td><td>7</td><td>LW</td></tr><tr><td>ADD_LH</td><td>8</td><td>LH</td></tr><tr><td>ADD_LB</td><td>9</td><td>LB</td></tr><tr><td>ADD_SW</td><td>10</td><td>SW</td></tr><tr><td>ADD_SH</td><td>11</td><td>SH</td></tr><tr><td>ADD_SB</td><td>12</td><td>SB</td></tr></tbody></table></div><h2 id="转发暂停矩阵"><a href="#转发暂停矩阵" class="headerlink" title="转发暂停矩阵"></a>转发暂停矩阵</h2><p>利用AT法判断每条指令的<code>TuseRT</code>, <code>TuseRS</code>, <code>Tnew</code>。</p><div class="table-container"><table><thead><tr><th></th><th>E</th><th>E</th><th>E</th><th>M</th><th>M</th><th>W</th></tr></thead><tbody><tr><td><strong>TuseRsRt</strong>\<strong>Tnew</strong></td><td>0</td><td>1</td><td>2</td><td>0</td><td>1</td><td>0</td></tr><tr><td>0</td><td>F(Forward)</td><td>S(Stall)</td><td>S</td><td>F</td><td>S</td><td>F</td></tr><tr><td>1</td><td>0</td><td>0</td><td>S</td><td>F</td><td>F</td><td>F</td></tr><tr><td>2</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td><td>F</td></tr></tbody></table></div><p><strong>整体思路</strong>：D级强制阻塞，后级但凡出现冒险一定能通过转发解决，尽可能多转发，每级皆转发（共五个转发多路选择器<code>RD1</code>，<code>RD2</code>，<code>ALUA</code>，<code>ALUB</code>，<code>StoreData</code>）。</p><h2 id="延迟槽"><a href="#延迟槽" class="headerlink" title="延迟槽"></a>延迟槽</h2><ul><li><p>B/J型指令会用到延迟槽，紧随其后的一条指令不会清除而是会执行，因此JAL应链接下两条指令，即$PC+8$；</p></li><li><p>无需考虑分支冒险，仅考虑数据冒险即可</p></li></ul><h2 id="通路结构"><a href="#通路结构" class="headerlink" title="通路结构"></a>通路结构</h2><p>仅存P5的草图，感谢金哥的IPAD的大力支持！</p><p><img src="https://private-user-images.githubusercontent.com/137391849/348549331-3704f753-66ad-4cce-a720-730e76948d19.jpg?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3Mjg0NTI0NTcsIm5iZiI6MTcyODQ1MjE1NywicGF0aCI6Ii8xMzczOTE4NDkvMzQ4NTQ5MzMxLTM3MDRmNzUzLTY2YWQtNGNjZS1hNzIwLTczMGU3Njk0OGQxOS5qcGc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjQxMDA5JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI0MTAwOVQwNTM1NTdaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1mZjUyZjUxZWM5ZjYxYmIzMzBhYTE3Y2RiZDUzMWEyOGE0NGFkY2YyYzM4NzU4Y2QwYzY5YzdhYmU1Mjc4NmY4JlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCJ9._3b7Li3yAeEjia0dqv145cwKE36RBC14t918nSlNZ2k" alt="https://private-user-images.githubusercontent.com/137391849/348549331-3704f753-66ad-4cce-a720-730e76948d19.jpg?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJnaXRodWIuY29tIiwiYXVkIjoicmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbSIsImtleSI6ImtleTUiLCJleHAiOjE3Mjg0NTI0NTcsIm5iZiI6MTcyODQ1MjE1NywicGF0aCI6Ii8xMzczOTE4NDkvMzQ4NTQ5MzMxLTM3MDRmNzUzLTY2YWQtNGNjZS1hNzIwLTczMGU3Njk0OGQxOS5qcGc_WC1BbXotQWxnb3JpdGhtPUFXUzQtSE1BQy1TSEEyNTYmWC1BbXotQ3JlZGVudGlhbD1BS0lBVkNPRFlMU0E1M1BRSzRaQSUyRjIwMjQxMDA5JTJGdXMtZWFzdC0xJTJGczMlMkZhd3M0X3JlcXVlc3QmWC1BbXotRGF0ZT0yMDI0MTAwOVQwNTM1NTdaJlgtQW16LUV4cGlyZXM9MzAwJlgtQW16LVNpZ25hdHVyZT1mZjUyZjUxZWM5ZjYxYmIzMzBhYTE3Y2RiZDUzMWEyOGE0NGFkY2YyYzM4NzU4Y2QwYzY5YzdhYmU1Mjc4NmY4JlgtQW16LVNpZ25lZEhlYWRlcnM9aG9zdCJ9._3b7Li3yAeEjia0dqv145cwKE36RBC14t918nSlNZ2k"></p><h2 id="补充-P7思考题"><a href="#补充-P7思考题" class="headerlink" title="补充-P7思考题"></a>补充-P7思考题</h2><h3 id="一-输入输出设备"><a href="#一-输入输出设备" class="headerlink" title="一. 输入输出设备"></a>一. 输入输出设备</h3><p><strong>键盘控制流程</strong></p><ol><li><p>每一个按键对应两个独特的编码，按下时产生的编码叫通码，松开时的编码叫断码，由键盘编码器统一控制。键盘编码器监控是否有键按下或弹起，若有键按下，向键盘控制器发送此键的通码；若有键弹起，则发送断码</p></li><li><p>键盘控制器将编码保存到自己的输出缓存区中，然后通过中断控制器向CPU发送键盘中断信号(不同外设的中断信号肯定不同，课上做出了很大的简化)</p></li><li><p>CPU未关中断的情况下响应，中断控制器再发送中断向量号，CPU根据向量号定位中断服务程序，并进入</p></li><li><p>压栈保护上下文，从键盘输出缓存区读取扫描码，<strong>若不从输出缓存区读取数据的话，键盘控制器是无法继续工作的</strong>，读取后判断这个扫描码是否是有多字节的，若有多字节，需要先保存下来等待接下来的扫描码组合成为完整的扫描码。</p></li><li><p>寻址调用相应的键处理程序。每个扫描码都有一个键处理程序入口，寻址并进入，执行特定的操作</p></li><li><p>键处理程序：对于普通键的处理，主要的功能为将扫描码转化成ASCII码，然后放进缓冲区中；对于操作控制键如CTRL SHIFT等的处理，设置一个寄存器(mode/leds)的相应位，当检测到他们的通码时，相应位置1，而检测到断码时，相应位置0(因此我们使用组合键时要先按下控制键,程序为控制键置好按下状态，再处理后来的键时会检查这些标识，是否有控制键按下，来执行不同的操作)</p></li><li><p>退出中断，执行原任务</p></li></ol><p><strong>鼠标控制流程</strong></p><p>鼠标不只有左键右键滚轮侧键，还需要有光标位置的判定，因此在图形化界面的不同的交互位置和不同的点击松开按键结合都将产生不同的编码，大致流程与上无异。</p><p><strong>总结</strong></p><p>外设其内部均有一些微处理器控制自己与CPU的信息交互，每个设备都需要有驱动程序，有的在电脑系统内，如无线键鼠，驱动程序就在USB头上，叫免驱设备；有的需另外安装，若没有驱动程序的话，CPU是无法识别内容的。</p><h3 id="二-自定义中断处理程序"><a href="#二-自定义中断处理程序" class="headerlink" title="二. 自定义中断处理程序"></a>二. 自定义中断处理程序</h3><p>我认为是不妥当的，在自定义时程序有可能会占据CPU存储空间的其他地方，如占据DM段，外设段等，这样会使得访存时出现冲突。中断程序的入口地址是一个固定的地址，不会因任何因素变化而变化，而在设计系统之初就提前制定好地址，并不允许用户私自更改，是便于维护的，合乎道理的。</p><h3 id="三-为何与外设通信用Bridge"><a href="#三-为何与外设通信用Bridge" class="headerlink" title="三. 为何与外设通信用Bridge"></a>三. 为何与外设通信用Bridge</h3><p>系统桥相当于CPU与外设沟通的桥梁。外设的种类是无穷无尽的，而 CPU 的指令集却是有限的。我们并不能总是因为新加入了一个外设，就专门为这个外设增加新的 CPU 指令。我们希望的是，尽管外设多种多样，但是 CPU 可以用统一的方法访问它们，这个方法在MIPS中便是为每个外设配置一块CPU地址空间，使用L/S型指令向不同的地址读出/写入数据，来交换外设寄存器所蕴含的信息。为了实现这个目标，我们设计了系统桥。</p><p>系统桥是连接 CPU 和外设的功能设备，它会给 CPU 提供一种接口，使得 CPU 可以像读写普通存储器一样（即按地址读写）来读写复杂多变的外设。系统桥统一且简化了 CPU 的对外接口，CPU 不必为每种外设单独提供接口，符合高内聚，低耦合的设计思想。</p><h3 id="四-两种计时器模式异同"><a href="#四-两种计时器模式异同" class="headerlink" title="四. 两种计时器模式异同"></a>四. 两种计时器模式异同</h3><p>初始化相同，即先将倒计时数存在PRESET寄存器，后将行为模式存入CTRL寄存器，在允许计数时先将PRESET寄存器的值赋值给COUNT寄存器，后每个周期使COUNT寄存器值减一，当减到0时，两种模式产生异常。</p><p><strong>模式0</strong>：减到0时中断产生并持续有效，将计数器写使能变为0，直到计数器写使能为1时(由CPU修改)，清除中断信号，重新载入初值，再次开始计时；</p><p><strong>模式1</strong>：减到0时中断产生并只存在一个时钟周期，下一个时钟周期重新载入计数器初值，再次开始计时。</p><h3 id="五-倘若中断信号流入的时候，在检测宏观-PC-的一级如果是一条空泡（你的-CPU该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在-P7-中，清空流水线产生的空泡指令应该保留原指令的哪些信息？"><a href="#五-倘若中断信号流入的时候，在检测宏观-PC-的一级如果是一条空泡（你的-CPU该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在-P7-中，清空流水线产生的空泡指令应该保留原指令的哪些信息？" class="headerlink" title="五. 倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？"></a>五. 倘若中断信号流入的时候，在检测宏观 <strong>PC</strong> <strong>的一级如果是一条空泡（你的</strong> CPU该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 <strong>P7</strong> <strong>中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</strong></h3><p>会发生的情况为，在异常处理程序返回时EPC中返回的值为0，导致程序错乱，显然不符合逻辑。空泡指令应保留被阻塞的当前指令的PC值以及判断其是否为延迟槽指令的BD位控制信号，以便在空泡中断返回后回到正确的指令上执行。至于为何要保留BD位，则是由于当延迟槽指令被阻塞时中断，中断的气泡就应该像中断的延迟槽指令一样，向EPC写入PC-4(跳转指令的地址)，否则返回时会返回到延迟槽指令，进而顺序进行，与前跳转指令逻辑不符。</p><h3 id="六-为什么-jalr-指令为什么不能写成-jalr-31？"><a href="#六-为什么-jalr-指令为什么不能写成-jalr-31？" class="headerlink" title="六. 为什么 jalr 指令为什么不能写成 jalr 31？"></a>六. 为什么 <strong>jalr</strong> <strong>指令为什么不能写成</strong> jalr 31？</h3><p>jarl为跳转并链接指令，行为是$PC \leftarrow GPR[rs]; GPR[rd] \leftarrow PC+4$ ;</p><p>按照正常转发阻塞逻辑，其 GPR[rs] 在D级使用，TuseRs 为0，而 GPR[rd] 在D级产生，其 Tnew 为0，因此当出现 rs==rd 时，转发需要在D级进行，此时将PC+4转发给PC，从意义上看便是顺序执行下一条指令，影响了PC原本应跳转到的 GPR[rs] 的值，因此 jalr 指令的 rs 一定不能等于 rd。</p><h2 id="补充-P8思考题"><a href="#补充-P8思考题" class="headerlink" title="补充-P8思考题"></a>补充-P8思考题</h2><p>当阅读至此，微处理器的设计便来到了最后且最高深的一关，我们之前开发的CPU，只能在IM里接受一段来自汇编的指令码，并用开发软件自带的输出功能向外显示信息，这对于一个真正意义上的处理器显然是不合格的。一个合格的处理器应当具备真正的IO接口，并通过CPU交流信息，实现各种逻辑上的肉眼可见的直观的输入输出。在P7中，我们实现了系统桥，可以识别响应外部中断，这为P8奠定了基础，然而外部中断究竟从何而来，什么时候该响应中断，CPU如何与真正的外设交互；同时P7我们编写的异常处理程序可能只是简单的跳过或重复执行当前指令，这显然是为了图方便进行的操作，在P8中，为实现某些功能，需要我们编写一段简单却具有实际功能的异常处理程序，这些问题马上将会得到答案。</p><p>在P8中，我们需要完成IP核的替换与改装，对GPIO，UART，TUBE这三类输入输出外设模块的添加，为其编写驱动程序，并学习到软件与硬件如何配合工作，相辅相成的实现最终要求。让我们一起走向最后的关底。</p><h3 id="一-微系统接入乘除法器与外设驱动模块的方案"><a href="#一-微系统接入乘除法器与外设驱动模块的方案" class="headerlink" title="一. 微系统接入乘除法器与外设驱动模块的方案"></a>一. 微系统接入乘除法器与外设驱动模块的方案</h3><p><strong>乘除法器</strong>：教程中提供了用加减法和移位操作代替verilog中*/%的运算的乘除核，但是我们需要和原先的乘除模块进行耦合，才能正确实现乘除法器。</p><p><strong>乘除核</strong></p><p>老四位代表mult，multu，div，divu</p><ol><li><p>in_op, in_sign：这两个信号共同组合出四种需要用到乘除核的乘除指令，而我之前只用一个控制信号MDControl控制，因此需要组合逻辑进行转化</p></li><li><p>in_valid：当有老四位到来且非中断时置1，实际与原ready信号等价，因此assign即可</p></li><li><p>in_ready：当乘除核中可进行乘除法计算，即未被使用中时置1，与~busy等价，因此 <code>assign busy = in_ready</code>即可</p></li><li><p>out_ready：外界此时能接受乘除法结果，对于本实验而言恒1即可，外界不存在不能接受的情况</p></li><li><p>out_valid：当计算结果合法，即计算完成后置1，相应修改为当 <code>out_valid==1</code> 时，lo与hi寄存器写入相应计算结果</p></li><li><p>其余数据输入输出信号易于理解</p></li></ol><p><strong>外设驱动模块</strong></p><p>本实验共需要四种外设</p><ul><li>计时器Timer，可读可写；</li><li>通用输入输出设备GPIO，其中包含：<ul><li>8位用户按键user_key，一般用于选择工作模式，只读；</li><li>64位拨码开关 dip_switch，一般用于计算数的选择，只读；</li><li>32位LED灯，一般用于结果的显示，只写；</li><li>2组四位八段数码管Tube，同样用于结果的显示，只写；</li></ul></li><li>UART串口，用于串口通信，可以实现串口回显，以及和LED,Tube相同的显示结果的功能。</li></ul><p>每种外设都有各自的外设寄存器，用于和CPU的交互，同样也会有一些内部的独立寄存器，为了使其接入CPU中，我们需要使用P7中系统桥的概念，将桥作为与外设寄存器交换信息的桥梁，每个外设对应CPU地址的部分空间，一一分配好地址空间后，便可以通过L和S型指令精确的找到相应的外设并进行寄存器堆与外设寄存器的信息交换。</p><p>由于DM使用了IP核，变为同步读同步写模式，读出结果滞后一个周期，因此如教程所言需将MW流水寄存器中的LoadData短接处理。但值得注意的是，由于系统桥沟通的外设仍为同步读异步写模式，在读取数据时会使得和DM不一致，具体体现为，为改DM而短接MW级的LoadData同样可能来自各个外设，因此需在系统桥内对于外设的读取数据进行滞后一周期的处理。具体实现方法很简单，即将地址和各个外设的读取值先用寄存器存储起来，将寄存器值接入LoadData的选择即可。同时因此还要考虑原先在M级的DataExt模块需改装到W级。</p><p>外设寄存器可以存储数据，无论是CPU存入的(此时相对于CPU角度该寄存器只写)，还是外设内部计算得来而存入的(此时相对于CPU角度该寄存器只读)，也可以存储状态信号来控制外设，外设通过各自的外设寄存器做到了外设与CPU相沟通。可以做一个比喻，桥相当于车道，数据相当于跑的汽车，根据目的地不同走向不同的车道，而外设寄存器就相当于目的地的车位。</p><h3 id="二-控制与外设交互的汇编程序"><a href="#二-控制与外设交互的汇编程序" class="headerlink" title="二. 控制与外设交互的汇编程序"></a>二. 控制与外设交互的汇编程序</h3><figure class="highlight mips"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Memory Map:</span></span><br><span class="line"><span class="comment"># 0x7f68 0~7 represent user_key lb $xx, 0($s0)</span></span><br><span class="line"><span class="comment"># 0x7f70 sw $xx, 0($s1) represent led_light  </span></span><br><span class="line"><span class="comment"># 0x7f60 ALUB preset lw $xx, 0($s2)</span></span><br><span class="line"><span class="comment"># 0x7f64 ALUA lw $xx, 0($s2)  </span></span><br><span class="line"><span class="comment"># 0x7f50 Tube (sign no use) sw $xx, 0($s4)</span></span><br><span class="line"><span class="comment"># 0x7f30 UART data</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set status register </span></span><br><span class="line"><span class="keyword">ori </span>$<span class="built_in">s0</span>, $<span class="number">0</span>, <span class="number">0xfff1</span></span><br><span class="line"><span class="keyword">mtc0 </span>$<span class="built_in">s0</span>, $<span class="number">12</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">loop:</span></span><br><span class="line">    <span class="comment"># Read user input</span></span><br><span class="line">    <span class="keyword">lw </span>$<span class="built_in">s0</span>, <span class="number">0x7f68</span>($<span class="number">0</span>)  </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Load ALU operands</span></span><br><span class="line">    <span class="keyword">lw </span>$<span class="built_in">s1</span>, <span class="number">0x7f64</span>($<span class="number">0</span>)  <span class="comment"># alua</span></span><br><span class="line">    <span class="keyword">lw </span>$<span class="built_in">s2</span>, <span class="number">0x7f60</span>($<span class="number">0</span>)  <span class="comment"># alub preset</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Decode user input</span></span><br><span class="line">    <span class="keyword">andi </span>$<span class="built_in">t3</span>, $<span class="built_in">s0</span>, <span class="number">0x0001</span>  <span class="comment"># cnt or maths</span></span><br><span class="line">    <span class="keyword">andi </span>$<span class="built_in">t4</span>, $<span class="built_in">s0</span>, <span class="number">0x0002</span>  <span class="comment"># uart or led tube</span></span><br><span class="line">    <span class="keyword">andi </span>$<span class="built_in">t6</span>, $<span class="built_in">s0</span>, <span class="number">0x00fc</span>  <span class="comment"># 1111 1100 alucontrol</span></span><br><span class="line">    <span class="keyword">andi </span>$<span class="built_in">t7</span>, $<span class="built_in">s0</span>, <span class="number">0x0004</span>  <span class="comment"># high or low</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Branch based on cnt or maths</span></span><br><span class="line">    <span class="keyword">beq </span>$<span class="built_in">t3</span>, $<span class="number">0</span>, maths  <span class="comment"># 1 cnt ; 0 maths</span></span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol"></span></span><br><span class="line"><span class="symbol">cnt:</span></span><br><span class="line">    <span class="keyword">lw </span>$<span class="built_in">s3</span>, <span class="number">0x7f08</span>($<span class="number">0</span>)   <span class="comment"># count</span></span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">s2</span>, <span class="number">0x7f04</span>($<span class="number">0</span>)   <span class="comment"># load preset</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Set cnt model based on high/low</span></span><br><span class="line">    <span class="keyword">beq </span>$<span class="built_in">t7</span>, $<span class="number">0</span>, high </span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol">    </span></span><br><span class="line"><span class="symbol">low:</span>  <span class="comment"># model 0</span></span><br><span class="line">    <span class="keyword">ori </span>$<span class="built_in">t3</span>, $<span class="number">0</span>, <span class="number">0x0009</span></span><br><span class="line">    <span class="keyword">j </span>preend</span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol">    </span></span><br><span class="line"><span class="symbol">high:</span>  <span class="comment"># model 2 </span></span><br><span class="line">    <span class="keyword">ori </span>$<span class="built_in">t3</span>, $<span class="number">0</span>, <span class="number">0x000d</span></span><br><span class="line"><span class="symbol"></span></span><br><span class="line"><span class="symbol">preend:</span>    </span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">t3</span>, <span class="number">0x7f00</span>($<span class="number">0</span>)   <span class="comment"># ctrl</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Branch based on uart or led</span></span><br><span class="line">    <span class="keyword">beq </span>$<span class="built_in">t4</span>, $<span class="number">0</span>, cntled</span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol">    </span></span><br><span class="line"><span class="symbol">cntuart:</span></span><br><span class="line">    <span class="keyword">beq </span>$<span class="built_in">t2</span>, $<span class="built_in">s3</span>, loop</span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol">    </span></span><br><span class="line"><span class="symbol">pass:</span></span><br><span class="line">    <span class="keyword">lw </span>$<span class="built_in">t2</span>, <span class="number">0x7f08</span>($<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">s3</span>, <span class="number">0</span>($<span class="number">0</span>) </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Output count to UART byte by byte</span></span><br><span class="line">    <span class="keyword">lb </span>$<span class="built_in">s3</span>, <span class="number">3</span>($<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">s3</span>, <span class="number">0x7f30</span>($<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">jal </span><span class="keyword">wait</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    </span><br><span class="line">    <span class="keyword">lb </span>$<span class="built_in">s3</span>, <span class="number">2</span>($<span class="number">0</span>) </span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">s3</span>, <span class="number">0x7f30</span>($<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">jal </span><span class="keyword">wait </span></span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    </span><br><span class="line">    <span class="keyword">lb </span>$<span class="built_in">s3</span>, <span class="number">1</span>($<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">s3</span>, <span class="number">0x7f30</span>($<span class="number">0</span>) </span><br><span class="line">    <span class="keyword">jal </span><span class="keyword">wait</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    </span><br><span class="line">    <span class="keyword">lb </span>$<span class="built_in">s3</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">s3</span>, <span class="number">0x7f30</span>($<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">jal </span><span class="keyword">wait </span></span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    </span><br><span class="line">    <span class="keyword">j </span>loop</span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol"></span></span><br><span class="line"><span class="symbol">cntled:</span></span><br><span class="line">    <span class="comment"># Output to led and tube  </span></span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">s3</span>, <span class="number">0x7f50</span>($<span class="number">0</span>)  <span class="comment"># tube</span></span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">s3</span>, <span class="number">0x7f70</span>($<span class="number">0</span>)  <span class="comment"># led_light</span></span><br><span class="line">    <span class="keyword">j </span>loop</span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol"></span></span><br><span class="line"><span class="symbol">maths:</span>    </span><br><span class="line"><span class="keyword">jia:</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">ori </span>$<span class="built_in">s6</span>, $<span class="number">0</span>, <span class="number">4</span></span><br><span class="line">    <span class="keyword">bne </span>$<span class="built_in">t6</span>, $<span class="built_in">s6</span>, <span class="keyword">jian</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">nop </span></span><br><span class="line">    <span class="keyword">add </span>$<span class="built_in">s3</span>, $<span class="built_in">s1</span>, $<span class="built_in">s2</span></span><br><span class="line">    <span class="keyword">j </span>print</span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol">    </span></span><br><span class="line"><span class="symbol">jian:</span></span><br><span class="line">    <span class="keyword">ori </span>$<span class="built_in">s6</span>, $<span class="number">0</span>, <span class="number">8</span></span><br><span class="line">    <span class="keyword">bne </span>$<span class="built_in">t6</span>, $<span class="built_in">s6</span>, cheng  </span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">sub </span>$<span class="built_in">s3</span>, $<span class="built_in">s1</span>, $<span class="built_in">s2</span></span><br><span class="line">    <span class="keyword">j </span>print</span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol">    </span></span><br><span class="line"><span class="symbol">cheng:</span></span><br><span class="line">    <span class="keyword">ori </span>$<span class="built_in">s6</span>, $<span class="number">0</span>, <span class="number">16</span></span><br><span class="line">    <span class="keyword">bne </span>$<span class="built_in">t6</span>, $<span class="built_in">s6</span>, chu</span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">mult </span>$<span class="built_in">s1</span>, $<span class="built_in">s2</span></span><br><span class="line">    <span class="keyword">mflo </span>$<span class="built_in">s3</span></span><br><span class="line">    <span class="keyword">j </span>print</span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol">    </span></span><br><span class="line"><span class="symbol">chu:</span>     </span><br><span class="line">    <span class="keyword">ori </span>$<span class="built_in">s6</span>, $<span class="number">0</span>, <span class="number">32</span></span><br><span class="line">    <span class="keyword">bne </span>$<span class="built_in">t6</span>, $<span class="built_in">s6</span>, qie</span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">div </span>$<span class="built_in">s1</span>, $<span class="built_in">s2</span> </span><br><span class="line">    <span class="keyword">mflo </span>$<span class="built_in">s3</span></span><br><span class="line">    <span class="keyword">j </span>print</span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol">    </span></span><br><span class="line"><span class="symbol">qie:</span></span><br><span class="line">    <span class="keyword">ori </span>$<span class="built_in">s6</span>, $<span class="number">0</span>, <span class="number">64</span> </span><br><span class="line">    <span class="keyword">bne </span>$<span class="built_in">t6</span>, $<span class="built_in">s6</span>, huo</span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">and </span>$<span class="built_in">s3</span>, $<span class="built_in">s1</span>, $<span class="built_in">s2</span></span><br><span class="line">    <span class="keyword">j </span>print</span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol">    </span></span><br><span class="line"><span class="symbol">huo:</span></span><br><span class="line">    <span class="keyword">ori </span>$<span class="built_in">s6</span>, $<span class="number">0</span>, <span class="number">128</span></span><br><span class="line">    <span class="keyword">bne </span>$<span class="built_in">t6</span>, $<span class="built_in">s6</span>, loop</span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">or </span>$<span class="built_in">s3</span>, $<span class="built_in">s1</span>, $<span class="built_in">s2</span></span><br><span class="line">    <span class="keyword">j </span>print</span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol">        </span></span><br><span class="line"><span class="symbol">print:</span></span><br><span class="line">    <span class="comment"># Branch based on uart or led  </span></span><br><span class="line">    <span class="keyword">beq </span>$<span class="built_in">t4</span>, $<span class="number">0</span>, aluled</span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol"></span></span><br><span class="line"><span class="symbol">aluuart:</span></span><br><span class="line">    <span class="keyword">beq </span>$<span class="built_in">t2</span>, $<span class="built_in">s3</span>, loop </span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">sw </span>$<span class="built_in">s3</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">lw </span>$<span class="built_in">t2</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Output result to UART byte by byte</span></span><br><span class="line">    <span class="keyword">lb </span>$<span class="built_in">s3</span>, <span class="number">3</span>($<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">s3</span>, <span class="number">0x7f30</span>($<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">jal </span><span class="keyword">wait</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">lb </span>$<span class="built_in">s3</span>, <span class="number">2</span>($<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">s3</span>, <span class="number">0x7f30</span>($<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">jal </span><span class="keyword">wait</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">lb </span>$<span class="built_in">s3</span>, <span class="number">1</span>($<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">s3</span>, <span class="number">0x7f30</span>($<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">jal </span><span class="keyword">wait</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">nop </span></span><br><span class="line">    <span class="keyword">lb </span>$<span class="built_in">s3</span>, <span class="number">0</span>($<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">s3</span>, <span class="number">0x7f30</span>($<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">jal </span><span class="keyword">wait</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    </span><br><span class="line">    <span class="keyword">j </span>loop</span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol"></span></span><br><span class="line"><span class="symbol">aluled:</span></span><br><span class="line">    <span class="comment"># Output to led and tube</span></span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">s3</span>, <span class="number">0x7f50</span>($<span class="number">0</span>)  <span class="comment"># tube</span></span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">s3</span>, <span class="number">0x7f70</span>($<span class="number">0</span>)  <span class="comment"># led_light</span></span><br><span class="line">    <span class="keyword">j </span>loop </span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span><span class="symbol">    </span></span><br><span class="line"><span class="symbol">wait:</span></span><br><span class="line">    <span class="keyword">lw </span>$<span class="built_in">t1</span>, <span class="number">0x7f34</span>($<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">andi </span>$<span class="built_in">t1</span>, $<span class="built_in">t1</span>, <span class="number">0x0020</span>  </span><br><span class="line">    <span class="keyword">beq </span>$<span class="built_in">t1</span>, $<span class="number">0</span>, <span class="keyword">wait</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span>    <span class="keyword">jr </span>$<span class="number">31</span></span><br><span class="line">    <span class="keyword">nop</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line">.ktext </span><br><span class="line">    <span class="comment"># timer</span></span><br><span class="line">    <span class="keyword">lw </span>$<span class="built_in">k1</span>, <span class="number">0x7f00</span>($<span class="number">0</span>)  </span><br><span class="line">    <span class="keyword">ori </span>$<span class="built_in">k1</span>, $<span class="built_in">k1</span>, <span class="number">0x0001</span></span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">k1</span>, <span class="number">0x7f00</span>($<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># uart back</span></span><br><span class="line">    <span class="keyword">lw </span>$<span class="built_in">k0</span>, <span class="number">0x7f30</span>($<span class="number">0</span>) </span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">k0</span>, <span class="number">0x7f30</span>($<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">eret</span></span><br></pre></td></tr></table></figure><p>大致思路为，首先根据第一位按键选择功能是计时器or计算器，若为计时器要根据第三位按键选择工作模式高向低计时or低向高计时，若为计算器要根据三到八位按键选择计算类型，加减乘除且或，最后根据第二位按键选择输出位置led&amp;tube or uart进行输出。从最初选择功能时便不断使用条件判断if语句将指令一层层的分岔，执行各自的操作，最后可较为统一(如六种计算指令可跳转到同一部分的输出语句)的输出，然而由于计时器的特殊性，体现在若输入结果变化则应立刻归位重新计时，以及串口回显的特殊性，体现在只有当输出结果变化时再回显，需要对输出逻辑进行适当的修改以满足要求，这时输出函数就不能跳转到同一个了，因此针对不同的功能将有特殊性的处理。而串口回显功能我使用了进入异常中断处理的方法，不进入异常同样可行，智者见智。</p><h3 id="三-犯过的错"><a href="#三-犯过的错" class="headerlink" title="三. 犯过的错"></a>三. 犯过的错</h3><ol><li><p>M级DataExt模块没有改装到W级</p></li><li><p>计时器总是少一秒，计时器的异常产生与异常处理模块没配合好</p></li><li><p>IM没减3000</p></li><li><p>汇编逻辑混乱，难以debug</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『面向对象』面向对象第四单元总结——图书管理系统与UML</title>
      <link href="/post/ce9effbf.html"/>
      <url>/post/ce9effbf.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『面向对象』面向对象第四单元总结——图书管理系统与UML"><a href="#『面向对象』面向对象第四单元总结——图书管理系统与UML" class="headerlink" title="『面向对象』面向对象第四单元总结——图书管理系统与UML"></a>『面向对象』面向对象第四单元总结——图书管理系统与UML</h1><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>随着马原考试铃声敲响，大二一年的学习生活即将告一段落，由于考试周的复习以及准备os的挑战性任务答辩，期末周显得格外匆忙(也是自己有点泄劲了)。抱着还是要用心总结一下这学期以来对OO的感受的想法，于是选择在最后一天的下午完成最后一次的博客，为面向对象课程画上一个圆满的句号。</p><h2 id="二-正向建模与开发"><a href="#二-正向建模与开发" class="headerlink" title="二.正向建模与开发"></a>二.正向建模与开发</h2><p>本单元重点考验我们对程序架构的设计和抽象能力，以及加强对UML图的绘制训练，在三次迭代开发中完成一个小型的图书管理系统，并逐步增加校际借阅与购书，还书逾期处理等功能，同时使用UML类图，状态图，顺序图辅助完成代码工作。</p><p>本单元鼓励我们采用正向建模的方式，即先画出类图，构造好类的功能和类与类之间联系，再去进行代码的实际实现，由架构指导实现的出发点是很好的，在较大规模的设计开发中必须要先有整体的架构设计，分成不同的模块，无论是分配给不同的人做也好，抑或是让实现者有明确的思路也好，无疑是有所裨益的。在本单元第一次作业中，我先在纸上画出了草图，再根据草图完成代码，最后补充了UML图(相信很多人都是如此)，我认为这也算是正向建模的体现。至于为何老师一直提倡的一定要先画UML图难以落实，我认为在设计伊始并没有办法设想出所有实现的细节，许多问题只有在实践中才会遇到，同时在实践中所创新出的更加优秀的想法可能需要大幅度调整自己的架构。无论如何，如果没有UML的机械评测，在面对复杂问题时，我想我是很愿意先设计架构画出UML类图的。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/16_1.jpg" alt></p><p>引用听到的一位同学的观点，本单元指导书对于需求不像一个真正的甲方那样是抽象的表述，而是方便我们完成作业或是方便评测正确性，而具有很强的引导性的表述。主要体现在差不多喂到嘴边的类的设计，约束住的输出逻辑，经常使用保证数据不会出现的字眼，同时描述出了分散且繁琐的借书过程(于是讨论区成了另一本指导书)，导致整体体验并不是很好，我认为课程对于模型化结构化的设计思维训练与引导有待进一步加强。</p><h2 id="三-架构设计"><a href="#三-架构设计" class="headerlink" title="三.架构设计"></a>三.架构设计</h2><p>本单元的架构设计没有经历太大重构，在第一次作业的引导下我将每个部门都当成一个类，后续的作业也继续保持，尽管类图画出来赏心悦目且符合实际，然而其中大量涉及到各个部门的联系，需要很多本不该存在的属性，造成类之间耦合度较高而类内内聚程度较低，不值得提倡。将图书馆的整体当作一个类是明智的选择。</p><p>第一次：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/16_2.jpg" alt></p><p>后两次大致无异：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/16_3.jpg" alt></p><p><strong>状态图</strong>(若不是评测机制，想必应该会做的更好)：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/16_4.jpg" alt></p><h2 id="四-架构设计思维的演进"><a href="#四-架构设计思维的演进" class="headerlink" title="四.架构设计思维的演进"></a>四.架构设计思维的演进</h2><p>四个单元的训练重点各有侧重，但始终蕴含着架构设计思维：</p><p>第一单元完成了表达式计算与化简，训练重点在于<strong>层次化设计与递归下降法</strong>，设计了 表达式 -&gt; 项 -&gt; 多种因子 的层次架构，并从单项式到多项式由底至上返回，使我深刻体会到了类之间互相蕴含与配合竟能发生如此奇妙的反应。</p><p>第二单元完成了多线程电梯的设计，训练重点在于<strong>对设计模式的理解与并发式编程的处理</strong>，通过生产者-消费者模式，观察者模式等设计模式的实现，体会到了其在架构设计上的重要性与必要性，同时在今后的coding中我也会保持思考能否采用适合的设计模式进行实现。</p><p>第三单元完成了社交网络的设计，训练重点在于<strong>JML规格化设计与对”设计与实现分离”理念的理解</strong>，由于本单元给好了很不错的架构，只需重点关注性能的优化，算法的实现。</p><p>第四单元模拟了图书馆的运作，训练重点在于<strong>UML图模型与模型化设计</strong>，通过更为直观的UML图可以更直观的分析架构，由于这次我的架构实在是太庞大臃肿了，因此更加领悟了架构设计<strong>高内聚低耦合</strong>的真谛，这条准则是我对一学期以来学习到的架构设计思维的极简概括。简洁，完美，应当是我们老一辈计算机人共同的追求。</p><h2 id="五-测试思维的演进"><a href="#五-测试思维的演进" class="headerlink" title="五.测试思维的演进"></a>五.测试思维的演进</h2><p>测试是工程中重要的环节，也是想得分必须进行的重要环节，课程组在这方面煞费苦心，而我们也在课下付出了很多的心血以求强测互测不被橄榄。测试从数据构造角度说大致分为两种，使用评测机测试和手搓数据点测试，一般采用先手搓后评测机的测试方式。</p><p>我在第一与第三单元搭建了评测机，因为实现较为简单，第一单元使用python的numpy数学工具包，第三单元由于对数据限制性不大且答案唯一，直接随机生成数据对拍即可。第二单元需要用逻辑检验正确性，第一次作业以后用了良心院友的评测机，在此表示万分感谢orz。第四单元由于对输入数据的限制较大，在脑海里构想了一下便放弃了，好在由于手搓数据的强大，帮我顺利通过了强测。</p><p>在第三单元中涉及到了黑白盒测试，单元化，模块化测试的思想。其中功能测试，集成测试，回归测试的概念虽然是第一次听说，但实则早已应用到实际的测试过程中去。以第三单元举例，我在构建评测机时便针对所有的指令开展了集成测试与针对部分指令构成的某一功能开展了功能测试，并在修复完Bug后开展回归测试，这与我们的测试思想不谋而合。我的测试思维的演进主要体现在<strong>压力测试</strong>上，工程对于代码的性能势必会作出约束，我此前不曾拥有这种思维，导致三单元第一次作业性能上暴毙，这无疑给了我沉重一击，也让我更加理解了压力测试的重要性。</p><p>总的来说，测试应从点到线，由线到面，由单元到整体，同时测试的规模要大，数据量要大，这样才能保证我们代码的健壮性与正确性。</p><h2 id="六-课程总结与收获"><a href="#六-课程总结与收获" class="headerlink" title="六.课程总结与收获"></a>六.课程总结与收获</h2><p>一学期的学习转瞬即逝，现在回想起自己竟完成了十二次代码训练感觉有些恍惚，面对第一次作业抓耳挠腮翻看学长博客的时刻还历历在目，没想到转眼间便迎来了尾声。重新翻出第一单元的递归下降和第二单元的多线程，当时懂到不能再懂的代码如今竟有些迷惑，我一直在问自己真的学到知识了么？我想，我们学习到的是一种面向对象思维，一种将各种事物依据一定的属性特征分类打包思考问题解决问题的思维，一种能厘清各事物间蕴含着的联系的思维，它并不依赖于某个特定问题而存在，它会如影随形指导我们面对接下来更加艰巨的挑战；自然，这门课程也高强度的训练了我的编码能力，测试能力，架构设计能力，优化迭代能力，语言表达能力，甚至是时间管理能力，听我说谢谢你，温暖了我一整个大二下学期。</p><p>没想到笔者还能拿到一个杰出性能奖，感谢这份奖品背后对我的肯定，感谢这一学期带给我帮助的伙伴们，感谢理论课的袁源老师以及所有认真负责的老师们与助教哥哥姐姐们，因为有你们，面向对象这门课程才会如此被代代六系学子津津乐道；也感谢这一路学习与 coding 中带给我的磕磕绊绊，<del>使我更加相信经历风雨也未必看到彩虹</del>。最后，即使遗憾未能成为OO助教团的一员，我仍祝愿面向对象课程可以在一届届的传承中取长补短去芜存菁，祝北航OO出于mit而远胜于mit！！！</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/16_5.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『面向对象』面向对象第三单元总结——社交网络与JML</title>
      <link href="/post/af1b3afe.html"/>
      <url>/post/af1b3afe.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『面向对象』面向对象第三单元总结——社交网络与JML"><a href="#『面向对象』面向对象第三单元总结——社交网络与JML" class="headerlink" title="『面向对象』面向对象第三单元总结——社交网络与JML"></a>『面向对象』面向对象第三单元总结——社交网络与JML</h1><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>转眼第三单元也迎来结尾，这单元的笔者的经历可谓是起起落落落落落(省略n个)，充满了魔幻色彩。</p><p>官方要求培养的能力有二：</p><ol><li>了解基本的JML语法和语义，以及具备根据JML给出的规格编写Java代码的能力。</li><li>了解OK方法，以及具备规格写OK测试的能力。</li></ol><p>JML(Java Modeling Language)是用于对Java程序进行规格化设计的一种表示语言。在单元末尾再来思考JML的存在意义，笔者终于理解为什么行业上鲜有人使用，一旦方法代码复杂起来，用语法很难去描述一个完备的规格(比如实验课上较复杂的JML俺都写不出来)，连课程组给出的JML都能被找出Bug，在日后的大工程中那想都不敢想，以及目前好像缺少形式化验证的方法(如何验证JML所写与你脑海里构想的功能相符且完备)，我们也要去深入探讨是否有必要完成这种形式化编程，或者说是否需要将需求先转化成JML规格进而再转化成代码，就笔者目前接触到的程序中是不太需要的，然而无论如何本单元也为我们开辟了一片新的天地，对于形式化构建类和方法，增强程序的健壮性有了更加深入的理解，学习到了许多未接触过的知识。</p><p>然而实际上，我更愿意称本单元作业是披着JML规格化外衣的算法题，这三次作业对算法复杂度要求颇高，研究算法所花费的时间远远超过了根据JML写代码的时间，尤其是求最小环时，使用最常见的删边法并使用优先队列堆优化竟然会超时，在使用讨论区大佬<strong>自创</strong>的算法后才能通过，诚然，对于之前使用的算法需要n次迪杰斯特拉，而自创的算法只需1次，在数据量大时效率一定有很大差距，但我不禁感到疑惑，我和朋友在市面上(CSDN，博客园等)均没有发现一次迪杰斯特拉求最小环的解，难道一个OO作业已经要求我们去自创，去魔改算法了吗，这未免对我们要求过高。</p><h2 id="二-测试方法"><a href="#二-测试方法" class="headerlink" title="二.测试方法"></a>二.测试方法</h2><h3 id="1-对黑箱测试、白箱测试的理解"><a href="#1-对黑箱测试、白箱测试的理解" class="headerlink" title="1.对黑箱测试、白箱测试的理解"></a>1.对黑箱测试、白箱测试的理解</h3><p>白盒测试也称为结构测试，主要用于检测软件编码过程中的错误。程序员的编程经验、对编程软件的掌握程度、工作状态等因素都会影响到编程质量，导致代码错误。</p><p>黑盒测试又称为功能测试，主要检测软件的每一个功能是否能够正常使用。在测试过程中，将程序看成不能打开的黑盒子，不考虑程序内部结构和特性的基础上通过程序接口进行测试，检查程序功能是否按照设计需求以及说明书的规定能够正常打开使用。</p><p>黑盒测试和白盒测试主要有以下三个区别：</p><ol><li><p>从定义上的不同：白盒测试需要从代码句法发现内部代码在算法，溢出，路径，条件等等中的缺点或者错误，进而加以修正。而黑盒测试着重测试软件功能，它并不涉及程序的内部结构和内容特性。黑盒测试并不能取代白盒测试，它与白盒是互补的测试方法，它很可能发现白盒测试不易发现的其他类型错误。</p></li><li><p>从测试目的上的不同：黑盒测试的目的是检测是否有不正确或遗漏的功能；数据或者参数上，输入能否正确接收；是否有数据结构错误或外部信息访问错误；性能上是否能够满足要求；是否有初始化或终止性错误。而白盒测试的目的是通过在不同点检查程序的状态，确定实际的状态是否与预期的状态一致，而不顾它的功能。</p></li><li><p>检测方式上的不同：白盒测试是穷举路径测试，黑盒测试是穷举输入测试，这两种方法是基于完全不同的观点，反应了事物的两个极端，它们各有侧重和优势，但不能彼此替代。在现代的测试理念中，这两种测试方法不是截然分开的，而是交叉使用。</p></li></ol><h3 id="2-对单元测试、功能测试、集成测试、压力测试、回归测试的理解"><a href="#2-对单元测试、功能测试、集成测试、压力测试、回归测试的理解" class="headerlink" title="2.对单元测试、功能测试、集成测试、压力测试、回归测试的理解"></a>2.对单元测试、功能测试、集成测试、压力测试、回归测试的理解</h3><p>这几种测试都包含在黑箱测试的范畴。</p><ol><li>单元测试：是对软件中最小可测试单元(通常是一个方法)进行检查和验证。单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。</li><li>功能测试：功能测试就是对产品的各功能进行验证，根据功能测试用例，逐项测试，检查产品是否达到用户要求的功能。</li><li>集成测试：也叫组装测试或联合测试。在单元测试的基础上将所有模块按照要求设计组装成为子系统或系统，进行集成测试。</li><li>压力测试：通常是使用极大的数据量或临界数据对系统进行测试，检验系统是否具备处理高压数据的能力，或者系统处理数据的时间是否过长复杂性过高。</li><li>回归测试: 修改了了旧代码之后重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。</li></ol><p>我们课程组极力推荐的JUnit便是进行单元测试，通过对每个方法人为设置输入，前置条件并判断得到的输出是否与预期输出相符。据简要的研究，JUnit对一个方法每次只能测一组数据，效率过低，因此笔者整单元并没有使用过JUnit，即并没有进行过单元测试。</p><p>笔者采取了下述几种测试，均是以自制的半随机生成指令评测机与朋友对拍为基础：<strong>集成测试</strong>，对全部的指令半随机生成，测试整个系统的正确性；<strong>功能测试</strong>，对部分功能涉及的指令半随机生成，算是对某些功能的强测，诸如测试发红包分钱，关系图，计算组内年龄方差等等；<strong>压力测试</strong>，一次性输入大量(指令数上限左右)复杂度较高的指令，如第三次的qlm和第一次的qts，测试系统会不会超时或崩溃，这点笔者做的并不好，并没有针对qlm和qts进行万条指令的测试，因此强测便被狠狠的上了一波压力；<strong>回归测试</strong>，自然，每改一个Bug都一定会重新对整体进行测试。</p><h3 id="3-数据构造有何策略"><a href="#3-数据构造有何策略" class="headerlink" title="3. 数据构造有何策略"></a>3. 数据构造有何策略</h3><p>具体来说，评测机的数据构造采用的半随机生成方式，针对集成测试，即先添加给定的组数，消息数，表情数，接着添加人数，并随机将人分进组内，并随机生成数量固定的二人关系，做好前置部署；最后随机的从所有指令中生成(这是为了避免一开始出现大量的无用异常)，为了使指令出现频率某些高某些低，可以再适当手动调整，诸如加人，加组等操作已经执行过，便可降低频率，但为测试异常还是要保留，另诸如发送信息操作，我们自然是想让添加的信息尽可能发出，那便提高发送信息的概率。<strong>归根到底即保证所有情况都要被全面的测试到，无论是正常还是异常。</strong></p><p>当执行集成测试时，经常会出现上千条数据中出现Bug的情况，Debug根本无从下手，于是笔者找到错误的指令，并针对与之相关的功能设置了强测，即排除掉其余不会对该功能产生影响的指令，只针对性生成指令，这样在百条左右的测试中便会暴露问题，大大提高了Debug效率，诸如图算法出现问题时，只保留加人，添加关系，删除关系等指令，查询金钱出现问题时，只保留与组相关的以及添加发送红包信息的指令。现在想想应当是先进行功能测试再进行集成测试，然而为了图方便，也是抱着侥幸心理，二者的顺序被我颠倒了，在以后面临大型的项目时，应该分清先后才对。</p><h2 id="三-梳理本单元的架构设计，分析自己的图模型构建和维护策略"><a href="#三-梳理本单元的架构设计，分析自己的图模型构建和维护策略" class="headerlink" title="三.梳理本单元的架构设计，分析自己的图模型构建和维护策略"></a>三.梳理本单元的架构设计，分析自己的图模型构建和维护策略</h2><p>本单元UML图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/U3_UML.jpg" alt></p><p>大致框架JML已经给出，并不涉及过多复杂的内容，为加强功能的分离以及Network不能超过500行，将图算法相关内容和Ok测试相关内容单独封装成类。</p><p>第九次笔者采用<strong>BFS图算法</strong>并没有动态维护属性，后因超时修改为<strong>并查集</strong>且进行动态维护，效率大增。</p><p>第十次笔者发现<strong>并查集</strong>适用于只涉及加点加边的问题，而即使有着重建并查集的方法，仍觉得并查集不适合进行删边操作，后终于发觉真正影响时间的是动态维护与否，而非图算法性能高低，后又改为BFS并进行动态维护。</p><p>第十一次笔者采用最常见的<strong>迪杰斯特拉+删边法</strong>处理qlm问题，需要进行指定结点度次数的dij算法，效率低然而并无更好的想法。后由于强测超时将方法更改为讨论区提到的<strong>一次迪杰斯特拉寻找结点最短路径与次短路径的方法</strong>，笔者对其大为震撼，然而由于正在二阳，还未来得及研究其证明过程。在更改算法时遇到一个问题：优先队列不能擅自更改内部元素，不然将无法准确排序。</p><p>本单元使用的动态维护策略如下：</p><ul><li><p><strong>qbs</strong>: 静态计算n方复杂度，也许不会爆，然而动态维护很方便，只需在加人时加一，增关系前，减关系后判断两节点连通性即可。</p></li><li><p><strong>qts</strong>：静态计算n三次方复杂度，罪魁祸首。动态维护只需在增删关系时遍历找到二人共同的朋友即可。</p></li><li><p><strong>qcs</strong>：静态计算n复杂度，而动态维护较方便，对于每人维护一个<code>Pair&lt;bestFriendId,bestValue&gt;</code>即可。</p></li><li><p><strong>qba</strong>：同上。</p></li><li><p><strong>qgav</strong>：静态计算n复杂度，可动态维护组内的年龄和和年龄平方和，查询时直接带入方差公式计算即可，注意应严格按照JML标准(不严格会出现由于向下取整问题导致的差一现象)。</p></li></ul><p>对于有些复杂度并非很高且动态维护较为麻烦的指令(qgvs)选择放弃，复杂度在$O(n^2)$之内的应当都可以接受。</p><h2 id="四-Bug分析"><a href="#四-Bug分析" class="headerlink" title="四.Bug分析"></a>四.Bug分析</h2><p>本单元三次作业Bug如下:</p><ul><li>第一次：强测40分，没有使用动态维护，qts，qbs完全按照JML写的，导致被强测干烂，后改成上文所述方法，因此对规格与实现分离<strong>略</strong>有理解。</li><li>第二次：强测寄一个点，没有看到JML中组内人数上限，不细致，活该出错。</li><li>第三次：强测寄一个点，qlm的压力测试未能通过，采用的传统方法复杂度较高(nmlogn)，后使用院友改进版方法(n+mlogn)通过并大受震撼。笔者对于qlm的性能已经尽力辣，还是要多看看讨论区，信息渠道不要太闭塞为好。</li></ul><p>规格与实现的分离有几个很好的例子，在规格中Person拥有int[] acquaintance 和 int[] value 两个属性，一开始还傻傻的开数组，并尝试将数组和ArrayList来回转化，后来有点小悟，觉得<strong>无论用什么方式只要能存储起来就行</strong>，便改成了Arr，再最后改成了HashMap。再比如qlm的JML表述，读懂后能很快明白意思，找到一个Path数组，长度大于等于4，头和尾相同，中间依次相连……就是找到一个最小环，然而正所谓<strong>条条大路通罗马</strong>，在求最小环时你使用迪杰斯特拉，弗洛伊德抑或其他算法皆可，复杂度高还是低皆可，这属于具体实现方法，并不是规格所关心的，规格关心的只是到底干没干好这件工作，即前置条件，后置条件，副作用，结果等是否正确。qbs，qts也同理，若是按照JML严丝合缝地写，复杂度过大，然而实则无论你采用何种方法得出正确结果即可，JML只是给出了一个正确结果如何得到的表述，(要是能早点意识到该多好。</p><p>规格与实现的分离也是契约式编程中规格撰写方与代码实现方互相信任的表现。</p><h2 id="五-本单元中同学们实现了OK测试方法，请同学们思考OK测试对于检验代码实现与规格的一致性的作用，有何改进何建议"><a href="#五-本单元中同学们实现了OK测试方法，请同学们思考OK测试对于检验代码实现与规格的一致性的作用，有何改进何建议" class="headerlink" title="五.本单元中同学们实现了OK测试方法，请同学们思考OK测试对于检验代码实现与规格的一致性的作用，有何改进何建议"></a>五.本单元中同学们实现了OK测试方法，请同学们思考OK测试对于检验代码实现与规格的一致性的作用，有何改进何建议</h2><p>本单元每次作业都令我们实现了一个OKTest，即给定一组输入输出，已知输入状态合法，让我们判断输入经过方法后得到的预期输出与执行后状态与给定的输出与执行后状态是否一致。我身边的同学对Ok测试颇有争议，对实现方式也颇有争议，有根据输入状态真实生成一个网络并调用被测试方法的，也有仅依据JML直接对输入输出容器进行判断的，前者过于复杂，笔者采用的是后者的方式，也更倾向课程组是以后者的思路设计的，所以起初认为这好像只是一个锻炼我们对容器基本操作能力的东西，仅仅用到了官方给出的规格。小组讨论后，我现在更倾向于一种说法，Ok测试是<strong>对JML的一种代码化实现</strong>，完成Ok测试时我们的角色应该是<strong>规格撰写者</strong>，站在规格撰写者角度应百分之百信任JML和Ok测试，即认定JML与Ok测试具有一致正确性，然后我们对将一位笨笨的程序员的代码执行该方法前后的信息提出，并接入我们的Ok测试，判断其代码实现的正确与否，即检验了代码实现与规格的一致性，只不过在本单元，我们既充当了规格撰写者又充当了代码实现者，需要在两种角色间自由转换。</p><p>至于改进建议，不知上述笔者理解的是否存在偏差，建议课程组可以写的详细具体一些，令大家直观的明白写Ok测试的意义，不至于令人抓瞎。</p><h2 id="六-学习体会"><a href="#六-学习体会" class="headerlink" title="六.学习体会"></a>六.学习体会</h2><p>经过本单元的学习，笔者了解到了JML领域相关的知识，掌握了简单JML的阅读与撰写，复习了经典图算法问题也学习到了大家智慧的结晶，以及对复杂度控制与优化方面有了更深的理解，尽管大家对本单元争议较多，笔者认为这是值得铭记，收获满满的经历，人与人之间思想的碰撞必然会迸发出全新的灵感火花。</p><p>第四单元鼠鼠我啊要更认真了捏！</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『面向对象』面向对象第二单元总结——多线程电梯</title>
      <link href="/post/9d246226.html"/>
      <url>/post/9d246226.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『面向对象』面向对象第二单元总结——多线程电梯"><a href="#『面向对象』面向对象第二单元总结——多线程电梯" class="headerlink" title="『面向对象』面向对象第二单元总结——多线程电梯"></a>『面向对象』面向对象第二单元总结——多线程电梯</h1><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>三至四月实属是笔者大学生涯中最为辛劳的一段时间，一周一次的OO，操作系统的LAB2LAB3上机，蓝桥杯，以及最最最麻烦的冯如杯，与这段经历比起来，高三的最后冲刺也彷佛暗淡无光。一晃撑到了四月中旬，痛并痛着的电梯月即将迎来尾声，各种繁事琐事也纷纷有条不紊的结束，那便即以此篇收尾。</p><p>在本单元中，学习的主要目标是掌握简单的多线程程序设计方法以及更深一步体会层次化架构设计的魅力，为此我们进行了三个单元的多线程电梯迭代作业。第一次作业，要求实现一套简单的多线程电梯调度系统，大致可分解为单部电梯的运行策略和多台电梯的联合调度策略；第二次作业，为每台电梯新增了容量，起始楼层与运行速度的属性，以及扩展了增加电梯与维修电梯的请求；第三次作业，增加了每台电梯的可达性属性，以及对同一楼层的同时开门的服务中电梯，只接人电梯数量做出了约束。</p><p>笔者个人而言难度排序为1&gt;3&gt;2。</p><h2 id="二-锁与同步块"><a href="#二-锁与同步块" class="headerlink" title="二.锁与同步块"></a>二.锁与同步块</h2><p>本单元中笔者锁的选择就是synchronized关键字，并加之配合上sleep,wait,notifyAll的方法，完成了对多线程并发问题的处理。在研讨课讨论以及实验课上，还学习到了读写锁ReadWriteLock，以及信号量Semephore，同步容器ConcurrentArrayList等其他实现加锁的方式，笔者并没有更深入的了解，在此不过多介绍。</p><p>涉及多个线程间对于共享对象的访问时，则应该加锁处理，拿本次作业来说，对于输入线程和电梯线程而言，笔者架构的共享对象一共有三个，分别为<strong>请求队列</strong>，<strong>全体电梯</strong>，以及<strong>楼层监视器(用来管控同一楼层同时开门的电梯数量)</strong>，这三个共享对象皆放置在Scheduler(调度器)类中。</p><p>在本单元作业中，笔者只使用到了非静态方法锁和代码块锁，这二者本质都是锁一个对象实例，被锁包围起来的代码区域称作<strong>同步块</strong>，只能拥有对应锁的线程进入其中执行，其余线程需在外部等待，直至该线程释放锁(执行完代码块或wait)。线程wait后会进入等待池，需要其他获得对应锁的线程notify才能使wait线程被唤醒，进而参与锁的争夺以及执行后续的语句。为避免CPU轮询，我们需要合理使用wait-notify方法编程，一般来说需要wait的地方比较清晰，在本次作业中有：</p><ul><li>requestQueue(请求队列): <ul><li>当前电梯内部无人且请求队列中无人时</li></ul></li><li>floorMonitor(楼层监视器): <ul><li>当前电梯由于同步开门数量限制而无法开门时</li></ul></li><li>由于采用了宏观调度的方式，笔者有一处地方采用了wait(时间)的方式，即当前电梯内部无人且请求队列有人，然而此刻请求队列中所有请求都不需要当前电梯接时。这是由于随着请求的不断更新各台电梯的状态难以控制，会出现一段时间过后当前电梯反而成了某个请求的最优解却在这段时间中没有触发notify的情况，此时wait便不是明智的选择。</li></ul><p>而需要notify的地方则需要考究，若notify太少，则会出现线程无法正常结束，有些请求无法接到等问题，若notify太多，则会出现电梯线程等了又醒，醒了又等的类似轮询情况，很容易造成CTLE，在本次作业中有如下情况需notifyAll(综合了三次作业):</p><p><strong>很大一部分要思考的点在于如何结束进程上，笔者最后的思路是，任何一台电梯除维修外，只有当所有请求全部执行完后才有资格结束。</strong></p><ul><li><p>requestQueue: </p><ul><li>当输入来临一个Person请求时，无需解释</li><li>当有乘客从电梯内下车而下车点非目的地时，理由同上</li><li>当输入彻底完成后，设置结束标志位时。因为会出现在Person请求早已全部执行完然而用增加电梯请求拖时间的情况，此时结束时所有电梯都在wait中</li><li>当得到一个维修电梯请求时，因为此时对应电梯可能在wait中</li><li>当一台电梯正常结束时。其他电梯全在等待，当前仅剩的运行中电梯线程执行完最后的操作后得到结束指示，接着它来唤醒其他电梯结束，归根到底即是需要一个”导火索”，与下一种情况一个道理</li><li>当一台电梯的maintain执行结束时。考虑下述情况，其他电梯全在等待，当前维修的电梯还在运送最后一个人且能送达目的地，此时必须需要维修的这台电梯在结束时发出唤醒指令，令其他电梯可以正常结束</li></ul></li><li><p>floorMonitor:</p><ul><li>当一台服务中电梯关门时</li><li>当一台只接人电梯关门时</li></ul></li></ul><p>同时在加锁过程中应注意有一些操作是<strong>连贯</strong>的，不允许被其他线程抢断，这种情况也需要对连贯操作打包加锁处理，具体参考下文分析Bug部分。</p><h2 id="三-类分析与调度器详解"><a href="#三-类分析与调度器详解" class="headerlink" title="三.类分析与调度器详解"></a>三.类分析与调度器详解</h2><h3 id="一-类分析"><a href="#一-类分析" class="headerlink" title="(一).类分析"></a>(一).类分析</h3><p><strong>第三次作业最终UML类图如下所示：</strong> 蓝色部分为第三次作业新增类，第二次作业仅在原有类基础上修改，整体未经历重构。<br><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83UML%E7%B1%BB%E5%9B%BE.jpg" alt></p><p>整体使用生产者-消费者模式，随着结构便复杂，共享对象也在变多，Input线程作为生产者，而Elevator线程从一开始只是消费者，变成既是消费者又是生产者，但是总体思路不变。</p><h4 id="1-Input-输入类"><a href="#1-Input-输入类" class="headerlink" title="1. Input 输入类:"></a>1. Input 输入类:</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/8_2.jpg" alt></p><p>该类继承Runnable，与官方输入包对接，用来识别不同的请求并将其进行相应的分配，Person请求分配到RequestQueue，Maintain与Add请求分配到Scheduler，当输入结束时标记终止符。</p><h4 id="2-RequestQueue-请求队列类"><a href="#2-RequestQueue-请求队列类" class="headerlink" title="2. RequestQueue 请求队列类:"></a>2. RequestQueue 请求队列类:</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/8_3.jpg" alt></p><p>该类用来储存全部在请求队列内的人，为简化getset方法，采用了HashMap<Integer，ArrayList<MyselfRequest>&gt;的结构实现，单独存储每层的请求队列。updataPath方法为第三次新增，用来对请求队列内全部请求重新规划路线。</Integer，ArrayList<MyselfRequest></p><h4 id="3-Operation-操作类"><a href="#3-Operation-操作类" class="headerlink" title="3. Operation 操作类:"></a>3. Operation 操作类:</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/8_8.jpg" alt></p><p>该类作为枚举类，用来表示电梯可能要执行的全部操作。</p><h4 id="4-Elevator-电梯类"><a href="#4-Elevator-电梯类" class="headerlink" title="4. Elevator 电梯类:"></a>4. Elevator 电梯类:</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/8_7.jpg" alt></p><p>该类继承Runnable，完成电梯执行与输出的各项操作。笔者认为一台电梯作为电梯不该拥有“思想”，即电梯只会乖乖听从调度器的话行事，因此电梯除自身属性外只拥有调度器一个外部对象，很好的满足了高内聚低耦合的原则。事实上笔者在整体架构的处理上一直秉持这一思想，即每个类既要满足单一职责原则，又要尽量和更少的类相关联。在方法上，该类在run方法中不断向调度器寻求建议，并根据调度器的建议机械执行相应的操作。与一般架构而言，有两点进行了优化:</p><ol><li>上电梯时采用<strong>二次寻求策略</strong>。根据笔者的调度策略，忽略下电梯的请求，只有在开门前判断好有请求上电梯，电梯才会选择开门，然而在开关门的0.4秒内，有可能会有其他可搭载的请求来临。因此笔者为电梯设置了一个缓冲区Buffer，并且采取开门-下人-sleep(400)-上人-关门的步骤，在判断是否开门时和真正上人之前皆将可行的请求置入缓冲区，在上人时从缓冲区里转移，并清空缓冲区。</li><li>维修电梯时采用<strong>最后一搏策略</strong>。根据题意，电梯在收到维修指令时还能至多移动两层，考虑到效率问题，笔者没有选择就地放人，而是选择尽可能的继续运行。因此为每台电梯设置了一个等于2的常量lastStep，在电梯收到维修指令时每移动一层便减1，直至为0后放出所有乘客，当然若电梯内提前没有乘客则会提前结束。这其中涉及到一个小问题，那便是<strong>指令来临和电梯接收存在时间差</strong>，有可能在指令来临后与电梯接受前进行了一次move，因此最后改成在move中特判是否存在维修标记位，若存在则lastStep—。</li></ol><h4 id="5-MyselfPersonRequest-人员请求类"><a href="#5-MyselfPersonRequest-人员请求类" class="headerlink" title="5. MyselfPersonRequest 人员请求类:"></a>5. MyselfPersonRequest 人员请求类:</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/8_Myself.jpg" alt></p><p>该类为第三次作业新增，由于Person请求在第三次中存在换乘的情况，仅仅使用官方的Person请求类得到fromFloor和toFloor显然不满足题目需求。因此笔者创建了该类，大致属性与原无异，区别在于使用ArrayList<Integer>存放此时从起点到终点的最短路径，并在内设置setSequence方法，核心思路是利用<strong>未满电梯</strong>的可达性序列构建邻接矩阵，使用BFS广搜获得最短路径。<strong>该类对外部提供一层抽象，只向外提供数组的第0项，作为fromFloor，以及数组的第1项，作为toFloor，这会让调度器只关注于每个请求的第一段路线，像是在处理一个与第一第二次作业一样的从fromFloor到toFloor的请求，大大简化了调度器的设计(以及减少对笔者的脑子的折磨)，同时令电梯只接能送达至toFloor的请求</strong>。<br>ps:由于使用未满电梯，请求会出现得不到可达路径的情况，此时令第0项为当前楼层，第1项为最终楼层即可，反正此刻也不会有任何一台电梯去接它。</Integer></p><h4 id="6-OverControl-结束控制器"><a href="#6-OverControl-结束控制器" class="headerlink" title="6. OverControl 结束控制器:"></a>6. OverControl 结束控制器:</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/8_4.jpg" alt></p><p>该类为第三次作业新增，实际从第一次就该如此设计。不必多说，大家一定都遇到过无法结束电梯进程的情况，随着设计变复杂，需要考虑的情况越来越多。因此该类统计输入线程输入的Person请求数量，以及Person请求到达最终楼层的完成请求数量，并在输入结束时置入标记位，<strong>每台非维修电梯当且仅当输入数等于完成数且拥有结束标记位时才被允许结束</strong>。</p><h4 id="7-FloorMonitor-楼层监控器类"><a href="#7-FloorMonitor-楼层监控器类" class="headerlink" title="7.FloorMonitor 楼层监控器类:"></a>7.FloorMonitor 楼层监控器类:</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/8_6.jpg" alt></p><p>该类为第三次作业新增，用于满足同一楼层服务中与只接人电梯数量的限制。实现方法较为简单，作为全部电梯线程的共享对象，维护了两个<code>HashMap&lt;Integer,Integer&gt;</code>，表示某层当前服务中or只接人的电梯数目，在一台电梯执行Open操作时，执行如下流程:</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/8_9.jpg" alt></p><h4 id="8-MainClass"><a href="#8-MainClass" class="headerlink" title="8. MainClass:"></a>8. MainClass:</h4><p>进行调度器，楼层监控器，请求队列等单例的初始化，开启初始的电梯线程与输入线程。</p><h4 id="9-Scheduler-调度器类"><a href="#9-Scheduler-调度器类" class="headerlink" title="9. Scheduler 调度器类:"></a>9. Scheduler 调度器类:</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/8_5.jpg" alt></p><p>该类是本单元核心类，用于实现对多台电梯的统一调度，主要通过getOperation方法来为电梯提供指令，并实现判断电梯该进行哪一步骤的算法，流程如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start </span><br><span class="line">op=&gt;operation: getOperation </span><br><span class="line">cond0=&gt;condition: 电梯是否需要维修</span><br><span class="line">st-&gt;op-&gt;cond0</span><br><span class="line">cond1=&gt;condition: 电梯能否开门与是否需要开门</span><br><span class="line">cond2=&gt;condition: 电梯内是否有人</span><br><span class="line">cond3=&gt;condition: 请求队列是否为空</span><br><span class="line">cond4=&gt;condition: 是否满足终止条件</span><br><span class="line">cond5=&gt;condition: 电梯前方能否找到合适接的人</span><br><span class="line">cond6=&gt;condition: 电梯后方(包括当前层反方向)能否找到合适接的人</span><br><span class="line">maintain=&gt;operation: MAINTAIN</span><br><span class="line">move=&gt;operation: MOVE</span><br><span class="line">move1=&gt;operation: MOVE</span><br><span class="line">open=&gt;operation: OPEN</span><br><span class="line">over=&gt;operation: OVER</span><br><span class="line">wait=&gt;operation: WAIT</span><br><span class="line">turn=&gt;operation: TURN</span><br><span class="line">waittime=&gt;operation: WAIT(400)</span><br><span class="line">cond0(yes)-&gt;maintain</span><br><span class="line">cond0(no)-&gt;cond1</span><br><span class="line">cond1(yes)-&gt;open</span><br><span class="line">cond1(no)-&gt;cond2</span><br><span class="line">cond2(yes)-&gt;move</span><br><span class="line">cond2(no)-&gt;cond3</span><br><span class="line">cond3(yes)-&gt;cond4</span><br><span class="line">cond4(yes)-&gt;over</span><br><span class="line">cond4(no)-&gt;wait</span><br><span class="line">cond3(no)-&gt;cond5</span><br><span class="line">cond5(yes)-&gt;move1</span><br><span class="line">cond5(no)-&gt;cond6</span><br><span class="line">cond6(no)-&gt;waittime</span><br><span class="line">cond6(yes)-&gt;turn</span><br></pre></td></tr></table></figure><p>经过琢磨后发现判断顺序应该不可变，这些判断将是调度的重点，放在后文论述。</p><h3 id="二-调度策略"><a href="#二-调度策略" class="headerlink" title="(二).调度策略"></a>(二).调度策略</h3><p><strong>调度器不单独作为一个线程，仅仅在电梯线程访问调度器时调度器才会进行调度，而非调度器作为线程去一直调度，后者考虑的情况太过复杂，且笔者也不太能理解</strong></p><p>首先考虑单台电梯的调度算法，LOOK算法显然是最稳妥的做法，那么六台电梯是否跟一台电梯有某种共同之处呢，笔者采用了一种针对单台电梯变种LOOK的宏观调控法。</p><p>这种方法正如其名，是动态的根据每台电梯的状态来为电梯提供指导，每台电梯没有一个明确的目标请求，且每台电梯的行为不仅取决于请求队列，还取决于其他电梯的状态，例如当一台空闲电梯在1楼，另一台在10楼，面临一个来自11楼的请求时，会让10楼的电梯去接，而1楼电梯保持不动。事实上这种方法一定不是完备的，当请求数变多变复杂时，难免会出现没有考虑到的情况，<strong>但是一定要保证接到所有请求</strong>。算法思路有很多很多，针对某个逻辑判断，某些情况下更好而某些情况会更烂，因此设计的思路将千奇百怪且没有最优解，笔者也仅是给出自己的思路抛砖引玉。这种方法的优点很显然可以省电，一定会令电梯尽可能少动，相对的运行时间和人员等待时间也许会更多，属于是资本阶级压榨人民了。</p><p>我们研究LOOK算法会发现，<strong>一台空闲电梯在当前方向有人时会过去接，而当前方向无人且反方向有人时就掉头</strong>。笔者作出了优化，更改为<strong>一台空闲电梯在当前方向有更适合它接的人时会过去接，而当前方向无人且反方向有更适合它接的人时会掉头</strong>，其余思想类似，如电梯内有请求就朝当前方向移动，开门时捎带所有同方向的请求等。因此主要针对空闲电梯的调度，即何时Move何时Turn进行改进。</p><p>什么称得上适合接的请求?当调度器为一台空闲电梯判断是否要去接人时，首先从远及近遍历当前方向上全部请求，针对每一个请求，调用thisMoreSatisfy方法，在该方法内，会判断其余所有非维修电梯与当前电梯谁去接更好(代码参见如下，逻辑些许复杂，不好解释清楚)，若发现至少一个令当前电梯去接更好的请求，则电梯选择Move，为更改第一个Bug，在后续又新增了若当前方向请求超过12个，则即使无更适合接的请求，也要Move，<strong>这算是在电量与时间上寻求一个平衡</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">timeCompare</span><span class="params">(Elevator it, Elevator other, MyselfPersonRequest person)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> it.getSpeed() * abs(person.fromFloor() - it.getCurrentFloor()) &gt;</span><br><span class="line">            other.getSpeed() * abs(person.fromFloor() - other.getCurrentFloor());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isUp</span><span class="params">(MyselfPersonRequest it)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> it.fromFloor() &lt;= it.toFloor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">thisMoreSatisfy</span><span class="params">(MyselfPersonRequest it, Elevator elevator)</span> &#123;  <span class="comment">//当前电梯为空 都认为彼此会接</span></span><br><span class="line">        <span class="keyword">synchronized</span> (elevators) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Elevator elevatorAll : elevators) &#123;</span><br><span class="line">                <span class="comment">//不是同一台电梯 且不在维修状态</span></span><br><span class="line">                <span class="keyword">if</span> (!elevatorAll.equals(elevator) &amp;&amp; elevatorAll.getMaintain() == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        elevatorAll.getAccess().contains(it.toFloor()) &amp;&amp;</span><br><span class="line">                        elevatorAll.getAccess().contains(it.fromFloor())) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (elevatorAll.getCurrentNum() == <span class="number">0</span> &amp;&amp; ((elevatorAll.getDirection() == UP &amp;&amp;</span><br><span class="line">                            elevatorAll.getCurrentFloor() &lt;= it.fromFloor()) ||</span><br><span class="line">                            (elevatorAll.getDirection() == DOWN &amp;&amp;</span><br><span class="line">                                    elevatorAll.getCurrentFloor() &gt;= it.fromFloor())) &amp;&amp;</span><br><span class="line">                            timeCompare(elevator, elevatorAll, it)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (elevatorAll.getCurrentNum() &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                            elevatorAll.getCurrentNum() &lt; elevator.getCurrentNum()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (((elevatorAll.getDirection() == UP &amp;&amp; elevatorAll.getCurrentFloor()</span><br><span class="line">                                &lt;= it.fromFloor() &amp;&amp; isUp(it)) ||</span><br><span class="line">                                (elevatorAll.getDirection() == DOWN &amp;&amp; elevatorAll.getCurrentFloor()</span><br><span class="line">                                        &gt;= it.fromFloor() &amp;&amp; !isUp(it))) &amp;&amp;</span><br><span class="line">                                timeCompare(elevator, elevatorAll, it)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>调度器判断是否需要Turn同样需要用到如上方法，令电梯判断反方向上有无更适合接的请求，由于笔者的当前方向和反方向的定义是没有考虑当前层的，因此还需额外判断若该电梯转向后能否接到当前层的请求，若二者满足其一，则Turn，若否，则Wait(400)。</p><p><strong>第三次作业补充:需要为请求重新规划路线的时刻</strong></p><ol><li>当增加电梯请求来临时，为全部请求队列规划</li><li>当维修电梯请求来临时，为全部请求队列规划</li><li>当Person请求来临时，单独为其规划</li><li>当Person请求从正常电梯or维修电梯下来，且未到达终止楼层时，单独为其规划</li></ol><h3 id="三-UML协作图"><a href="#三-UML协作图" class="headerlink" title="(三).UML协作图"></a>(三).UML协作图</h3><p>由于是第一次接触协作图，已经尽力在画了，省略了部分类的协同。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/8_10.jpg" alt></p><h2 id="四-Bug分析"><a href="#四-Bug分析" class="headerlink" title="四.Bug分析"></a>四.Bug分析</h2><p>本单元三次强测均遗憾错一个点。</p><ol><li><ul><li>错因：有一个点数据很离谱，几十个人从高层往下下，由于初始设计的调度器是不关注每层请求数量多少的，因此会出现先只派一台电梯接人，等到接满后还有别人，另一台电梯再上去，这样会极大的耽误时间，导致RTLE(就差一秒啊!)。然而笔者认为现实中的电梯应该是像这么运行，这时间卡的多少有点不合实际了捏。<ul><li>改正方法: 令调度器同时关注请求人数，若超过某个阈值，则所有电梯一起Move，非常拙劣，但是极其有效。</li></ul></li></ul></li><li><ul><li>错因：在结束输入后，从维修电梯下来的请求没电梯去接了，其他电梯错判了某些情况，导致提前结束。<ul><li>改正方法：新增了OverControl类，令电梯在完成所有请求后统一结束，有效避免了上述问题。</li></ul></li></ul></li><li><ul><li>错因：只接人的电梯超过限制。笔者并不确定问题究竟出在哪里，有一定可能是最开始提到<strong>连贯语句</strong>的问题，试想一种情况，假定当前第一层onlyIn=1，servicing=2，第一台只接人电梯判断可以开门，令servicing++后CPU切换线程到第二台只接人的电梯，此时onlyIn=1，servicing=3，第二台电梯判断可以开门，servicing++，onlyIn++，并在开关门过程中控制权再次转给第一台，此时onlyIn=2，servicing=4，显然已不能再开门，然而第一台已经执行过判断语句，因此第一台也会选择开门，造成问题。<ul><li>改正方法：将servicing++和onlyIn++上锁打包，一个线程必须连贯的执行这两个操作。</li></ul></li></ul></li></ol><p>由于多线程的随机性，Debug在本单元是一件痛苦的事情，笔者选择自己构建极端数据加白嫖评测机的方式寻找Bug，并主要使用打印大法寻找Bug出现的位置，同时遇到Bug时会先将自己的程序看作单线程进行逻辑分析，若没错的话再去考虑与其他线程协同时可能引起的冲突。本次作业似乎并未遇到无法复现的Bug。</p><h2 id="五-心得体会"><a href="#五-心得体会" class="headerlink" title="五.心得体会"></a>五.心得体会</h2><p>行文至此，写的有些冗长，最后对电梯月做一个总结。</p><p>笔者在这一个月以来接触到了大量的有关多线程编程的新知识，尤其在编写第一次作业时显得捉襟见肘，一边思索了两天调度策略一边处理多线程遇到的并发等问题，深刻体会到了线程安全的重要性。为保护线程安全，我的方法是涉及到共享对象则统一加锁处理，但是要注意不能在同步块中进行sleep的操作，以及在遍历共享对象集合应使用迭代器进行遍历，这样可以避免线程并发的问题。至于层次化设计方面，由于在理论课与实验课中学习到了生产者-消费者模型，并在一开始便下定决心要编写一个多电梯的调度策略，架构是很自然设计出来了，并且在之后的迭代中坚持SOLID原则，主体框架不变，在主干上增枝添叶，由于第三次作业中笔者认为原架构开的类有些少，因此又刻意多设计了几个类出来看着更美观，当然实际上这些类自然也有它们被设计出来的道理。</p><p>笔者认为本单元作业的设计很有创新性，也极具挑战性，这都是前几年OO所感受不到的小小电梯震撼。同时逐步给电梯系统加限制也很好的满足了训练迭代化设计能力的目标，笔者由于未经历重构，综合体感下来，在一次次增加要求中看着自己的架构越来越完善，逻辑越来越清晰(复杂)，还是颇有成就感与挑战感的。奈何后两次作业由于种种原因没有认真测试，撒手不管，很遗憾在电梯月里没有画上一个完美的句号。</p><p>年年岁岁花相似，岁岁年年人不同。看着往届学长的博客中对三四月奔忙的感慨，笔者也有所释怀，没想到跨越了一年我们仍能心境相通。希望略清闲的下半学期可以更加用心对待OO，用心对待身边的一切。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『面向对象』面向对象第一单元总结——表达式求解</title>
      <link href="/post/759256ff.html"/>
      <url>/post/759256ff.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『面向对象』面向对象第一单元总结——表达式求解"><a href="#『面向对象』面向对象第一单元总结——表达式求解" class="headerlink" title="『面向对象』面向对象第一单元总结——表达式求解"></a>『面向对象』面向对象第一单元总结——表达式求解</h1><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>第一单元的主题是表达式解析与计算，主要学习目标是让我们这些OO小白初步了解体会面向对象层次化编程的思想，并浅浅进行代码上的实践（给大伙一..小小的OO震撼），把握不同类的拆分与继承，同时把握每一个类的属性，方法的设计，使得各个类间关系得当，构造出以类为基础的模块结构，并在主函数中用较短的代码（因为主要的代码实现应在类中）合理调度各个对象，实现最终要求。</p><p>本博客将分四个方面进行总结：度量分析，架构设计体验，自我Bug分析与找院友Bug方法，心得体会，接下来让我们一同走进美丽的OO世界。</p><h2 id="二-度量分析"><a href="#二-度量分析" class="headerlink" title="二.度量分析"></a>二.度量分析</h2><h3 id="1-代码统计"><a href="#1-代码统计" class="headerlink" title="1.代码统计"></a>1.代码统计</h3><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/P1.png" alt></p><p>本单元最终统计代码量1300+行，包含部分注释与辅助函数，去除后整体代码量在1200行左右，与整个项目的难度预期相符。除Poly类外大多控制在100行内，较为符合<strong>单一职责</strong>原则；而Poly类内存在大量化简函数与计算函数，长度来到400+行。</p><h3 id="2-UML类图分析"><a href="#2-UML类图分析" class="headerlink" title="2.UML类图分析"></a>2.UML类图分析</h3><p>本单元历经三次迭代，最终UML类图如下，<strong>白色</strong>部分为第一次作业，<strong>绿色</strong>部分为第二次作业新增，<strong>红色</strong>部分为第三次作业新增。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/P2.png" alt></p><p>可以看到，本结构以Factor，Unit，Poly类的实现为核心，在后两次的迭代中仅是增加对应类以及其余类的方法，并未进行大规模代码改动，很好的符合了<strong>开放封闭原则</strong>，展现出了极强的可扩展性，尤其是第三次作业，笔者基于此良好的架构，两个小时便完成速通。</p><p>然而本架构仍存在不足之处，点名批评Poly类，可以看到其函数过多，其功能过于冗杂繁琐，笔者认为或许应当像第三次作业构造了求导方法类一样，考虑构建一化简计算工具类来存储这些函数，使整体结构更为独立与美观。</p><h3 id="3-复杂度分析"><a href="#3-复杂度分析" class="headerlink" title="3.复杂度分析"></a>3.复杂度分析</h3><h4 id="度量标准"><a href="#度量标准" class="headerlink" title="度量标准:"></a>度量标准:</h4><blockquote><p>OCavg:平均操作复杂度</p><p>OCmax:最大操作复杂度</p><p>WMC:加权方法复杂度</p><p>CogC:认知复杂度</p><p>ev(G):基本圈复杂度，描述非结构化程度</p><p>iv(G):设计复杂度，描述模块耦合度</p><p>v(G):圈复杂度，描述独立路径的数目</p></blockquote><p>以上笔者也是头一次听说，并且对其的概念仅限于数越大越复杂越不太好。</p><h4 id="类复杂度"><a href="#类复杂度" class="headerlink" title="类复杂度:"></a>类复杂度:</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/P3.png" alt></p><p>由图可见，Parser类的平均复杂度与加权复杂度较高，而Poly类极高。这是由于Parser类主要负责对于表达式的解析，本次作业中表达式，三角函数，自定义函数等因子皆支持嵌套构造，因此解析过程中不可避免的会反复递归调用解析函数，复杂度必然较高。而Poly类是由于实现第二单元引入的三角函数化简所致，笔者完成了基本化简外又化简了平方和，诱导公式，而这些化简步骤皆在该类内实现，因此复杂度极高，具体原因下文说明。</p><h4 id="方法复杂度"><a href="#方法复杂度" class="headerlink" title="方法复杂度:"></a>方法复杂度:</h4><h5 id="1-Poly类"><a href="#1-Poly类" class="headerlink" title="(1)Poly类:"></a>(1)Poly类:</h5><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/P4.png" alt></p><p>一片惨淡的红~该类复杂度极高便不奇怪了。</p><p>首先是重写的equals函数，其用于判断两个Poly是否相等，以及isHashMapSame函数，其用于判断两个HashMap\<Poly, integer>是否相等，由于递归嵌套的存在，想简单实现是不可能了，笔者采用的是<strong>深克隆</strong>加”<strong>消消乐</strong>“的方法，以isHashMapSame函数为起始，即深拷贝出两份HashMap，接着<strong>双循环</strong>依次比较，每当键值对相同时便消去，直至全部消光即可判定相等，而键值对重点在比较“Poly”键，需要<strong>深克隆</strong>出两份ArrayList<Unit>，再去<strong>双循环</strong>依次比较，全部消光判相等，那么比较Unit重点又在于比较其HashMap，子子孙孙无穷尽也……可见如此反复递归调用，想不复杂都难，但最后一定会结束，因为HashMap到最后一定会为空。</Unit></Poly,></p><p>接着是addPoly和mulPoly方法，用于多项式的加法与乘法，要反复调用上述两函数的同时自身也要进行<strong>双循环</strong>遍历，因此复杂度极高。</p><p>squareMerge方法用于两个Unit的平方和化简，在addPoly中调用,其本质即一边找到sin(x)方而另一边找到cos(x)方并判断其余部分是否相等(支持常数不相等)，相等即化简，因此同样需要<strong>双循环</strong>并调用isHashMapSame方法，复杂度同样极高。</p><h5 id="2-其余类"><a href="#2-其余类" class="headerlink" title="(2)其余类:"></a>(2)其余类:</h5><p>CustomFun，TriFun内的toPoly方法，Lexer内的next方法复杂度较高，原因在于存在大量if-else语句以及存在遍历与递归的过程。</p><p>可见存在双循环乃至更多，以及大量递归调用的函数复杂度偏高，也许可以找到更加合适的算法优化函数降低复杂度。</p><h2 id="三-架构设计体验"><a href="#三-架构设计体验" class="headerlink" title="三.架构设计体验"></a>三.架构设计体验</h2><p>第一次作业发布伊始，笔者甚是迷茫，架构从何搭起更是无从下手，经历一天的冥思苦想后决定进行一个借的鉴，而发现了单项式多项式的思路后，顿时茅塞顿开，并在其中加入了大量自己的想法。在几次迭代中始终保持此架构，且增加功能愈发熟练。</p><p>根据BNF文法，一个表达式大致能拆成如下的架构：</p><p><strong>表达式➡项➡因子(各种类型)➡递归…➡常变量</strong> </p><p>它是一个递归的过程，可以使用递归下降法层层解析，直到将表达式拆成数个最小单元，也就是常量与变量。</p><h3 id="1-计算架构设计"><a href="#1-计算架构设计" class="headerlink" title="1.计算架构设计"></a>1.计算架构设计</h3><p>在第一次作业中，我们可以将常量和变量全都看成一个<strong>基元</strong>，也可以称作<strong>单项式</strong>，即$pos \ constant \times x^{index_x} \times y^{index_y} \times z^{index_z}$。它由pos,constant,index_x,index_y,index_z五个属性构成，是一个广义的最小单位，这么做的好处是，不仅常量因子(变量的指数为0)和变量因子(常数项为1)可以统一由基元表示以外，连常量，变量，多项式彼此数学运算后得到的多项式也可以由多个基元构成，而且此种表示非常利于进行同类项的合并，因此我们可以想象到，无论是表达式，还是项，还是因子，都是由有限个基元构成，这为我们表达式的计算奠定了基础。</p><p>而第二次作业新增了三角函数，以上概念明显不再可行，但就如何存储一个“基本单位”而言仍能发现有相通之处。笔者将每一个基元新增一个<code>HashMap&lt;Poly, Integer&gt;</code>属性,其中HashMap中每一个键值对代表着一个三角函数因子， Poly存储的是该三角函数中含有的因子toPoly后的多项式Poly形式，Integer存储的是该三角函数因子的指数，同时令正数为sin，负数为cos，这点很有创造性，使用一个HashMap即可存储任何形式的三角函数，而通过这一键值对即可完全描述出一个三角函数因子。</p><p>Poly内存有<code>ArrayList&lt;Unit&gt;</code>，事实上无论是Unit自身，还是其余每种因子和项,都可以看作是一个Poly,而在类中皆提供了toPoly方法以便将当前层次及以下的所有内容转化成Poly形式返回，在实现上只需对顶层表达式toPoly，便会依次递归调用各层的toPoly，并自下而上层层计算返回，得到最终结果</p><h3 id="2-解析架构设计"><a href="#2-解析架构设计" class="headerlink" title="2.解析架构设计"></a>2.解析架构设计</h3><p>本次笔者与大多数人无异，采用的是递归下降法解析，根据文法对表达式有规则的解读，并根据读取到的特定token进入到不同的解析函数中，由于后两次迭代主要是添加不同因子，因此仅在parseFactor方法内调用了新增的parseTriFun，parseDerivation，parseCustomFun即可完成解析。</p><h3 id="3-各类的设计考虑"><a href="#3-各类的设计考虑" class="headerlink" title="3.各类的设计考虑"></a>3.各类的设计考虑</h3><h4 id="1-MainClass"><a href="#1-MainClass" class="headerlink" title="(1)MainClass"></a>(1)MainClass</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/U1_P5.png" alt></p><p>主类实现自定义函数与待求表达式的输入，对于所有表达式的预处理与构造解析器进行解析，将自定义函数拆解存入CustomFunSet类，以及最后输出结果。</p><h4 id="2-Lexer"><a href="#2-Lexer" class="headerlink" title="(2)Lexer"></a>(2)Lexer</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/OO_P6.png" alt></p><p>词法器类实现语法单元的顺序按步读取，耦合进Parser类中。</p><h4 id="3-Parser"><a href="#3-Parser" class="headerlink" title="(3)Parser"></a>(3)Parser</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/P7.png" alt></p><p>语法解析器类实现对于表达式的解析，生成一颗层次结构分明的表达式树。</p><h4 id="4-Expr"><a href="#4-Expr" class="headerlink" title="(4)Expr"></a>(4)Expr</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/P8.png" alt></p><p>表达式类实现Factor接口，存储表达式以及表达式因子，由ArrayList\<Term>，本质是数个Term相加减，与指数(默认为1)组成，提供toPoly方法转化成Poly对象(下文不再重复)。</Term></p><h4 id="5-Term"><a href="#5-Term" class="headerlink" title="(5)Term"></a>(5)Term</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/P9.png" alt></p><p>项类存储项单元，由ArrayList\<Factor>，本质是数个Factor相乘，和项的正负标识组成，笔者在此将项赋予了符号以便后续的计算与输出，然而在toPoly时应注意。</Factor></p><h4 id="6-Factor"><a href="#6-Factor" class="headerlink" title="(6)Factor"></a>(6)Factor</h4><p>接口类，本架构的精髓之处，所有种类的因子均实现此接口并重写toPoly方法，在存储时也均当作Factor对象统一存储，是<strong>里氏替换原则</strong>的最好体现。</p><h4 id="7-TriFun-CustomFun-第二次作业-，Derivation-第三次作业"><a href="#7-TriFun-CustomFun-第二次作业-，Derivation-第三次作业" class="headerlink" title="(7)TriFun, CustomFun(第二次作业)，Derivation(第三次作业)"></a>(7)TriFun, CustomFun(第二次作业)，Derivation(第三次作业)</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/P10.png" alt></p><p>三角函数，自定义函数，求导函数因子，均实现了Factor接口，内部存储了描述对应因子的完备信息。</p><h4 id="8-CustomFunSet"><a href="#8-CustomFunSet" class="headerlink" title="(8)CustomFunSet"></a>(8)CustomFunSet</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/P12.png" alt></p><p>自定义函数定义类，存储了自定义函数定义的相关信息，包括函数名，变量名，表达式，属于工具人类。</p><h4 id="9-DerivationMethod"><a href="#9-DerivationMethod" class="headerlink" title="(9)DerivationMethod"></a>(9)DerivationMethod</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/P13.png" alt></p><p>求导方法类，Derivation继承了该类，该类属于工具类，提供Poly对变量var的求偏导方法，现在再来想想将该类合并进Derivation类也有道理。</p><h4 id="10-Unit"><a href="#10-Unit" class="headerlink" title="(10)Unit"></a>(10)Unit</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/P11.png" alt></p><p>基元类，该类是核心类，有两个重要功能。由于在架构上笔者去除了独立的Num类和Var类，直接使用Unit类存储常量与变量，因此功能其一是作为因子实现Factor接口，而其二是作为<strong>基本单元</strong>存储基本项，所谓基本项即是由若干常量变量以及三角函数相乘得到。</p><h4 id="11-Poly"><a href="#11-Poly" class="headerlink" title="(11)Poly"></a>(11)Poly</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/P14.png" alt></p><p>多项式类，由ArrayList\<Unit>组成，一切表达式相关类的终极形态，内置了大量的化简方法与计算方法。</Unit></p><h2 id="四-自我Bug分析与找院友Bug方法"><a href="#四-自我Bug分析与找院友Bug方法" class="headerlink" title="四.自我Bug分析与找院友Bug方法"></a>四.自我Bug分析与找院友Bug方法</h2><p>由于搭建了评测机进行了详尽的测试(Bug在测试里出麻了)，在三次强测与互测中，笔者均未出现Bug，而互测中笔者秉持人不犯我我不犯人的和平主义者思想，仅浅浅出刀五次刀中五次。</p><p>若问为何准确率那么高，因为哥们采用了评测机硬测的方法，说来惭愧并未细细品读房友的代码，但在一长段表达式中一点点截取出房友出Bug的地方的过程中也明白了一些易错的点，与本单元自己犯下的错结合，一并与大家分享。</p><ul><li>存常数时要使用BigInteger，因为题目中并无常数范围</li><li>注意自定义函数形参实参替换时左右加上”()”来保证运算顺序不变。</li><li>若化简了$sin(0)$,请注意 $sin(0)^0$ 的问题，或者说注意三角函数指数是0的问题，我出的两刀都来源于这个Bug。</li><li><strong>遇事不决深克隆</strong> 深克隆很关键，避免破坏原有结构时应使用深克隆，对HashMap进行增删操作时应使用迭代器遍历。</li><li><strong>不要过度优化</strong> 过度优化将会给你带来意想不到的错误(来自一位朋友的惨烈教训)，圈复杂度越高出Bug的概率应当越高。</li></ul><h2 id="五-评测机搭建"><a href="#五-评测机搭建" class="headerlink" title="五.评测机搭建"></a>五.评测机搭建</h2><p>本次作业的高效准确的完成离不开评测姬的鼎力支持，同时每个单元对于评测机的迭代开发也成了一个不简单的”作业”，甚至在第三次作业时搭评测机的时间超过了完成作业的时间。</p><p>简要来说，评测机是使用Python搭建，根据提供的文法为每一个结构(例如空格，符号，各种因子等)使用随机数随机生成的方法对其结构进行生成，并最后生成一个符合文法的字符串，将其传给python利用从事数学计算的<strong>Sympy</strong>包进行表达式运算同时传给我们所写的程序，python会通过代数值验算的方法比较二者是否相等，进而完成评测。换句话说，我们的程序便是完成了一个玩具版的Sympy。</p><p>我们需要将所有代码打包成JAR格式的工件，在Python中配置好参数并传入，完成Python到Java的沟通，具体操作请参考笔者未来也许会上传的源码。</p><h2 id="六-心得体会"><a href="#六-心得体会" class="headerlink" title="六.心得体会"></a>六.心得体会</h2><p>在略带微凉的初春悄然降临时，第一单元也迎来了尾声。历经三次代码的迭代训练，两次研讨课，两次实验课，以及最后的一篇总结，笔者在这万里长征的第一步中窥探到了面向对象的魅力。老师以及指导书的讲解，两次实验课代码精巧的结构设计，加以自己动手coding的课程作业向我们展现了面向对象层次化程序设计的优雅，并企图教会我们这一深邃的思想。第二次研讨课上伙伴们细致讨论了OO的五大核心原则，即S(单一责任原则)O(开放封闭原则)L(里氏替换原则)I(接口分离原则)D(依赖倒置原则)原则，这对我启发很大，并一条一条的尝试往自己的代码中匹配，并加以反思写过的代码的不足与改进之处，这些在上文略有提及。</p><p>尽管笔者上学期上过OO先导课，尽管早就知道第一次作业是递归下降法解析表达式，尽管上学期第七次作业已经练习过递归下降法的实现，笔者在真正拿到第一单元的指导书并研究一个小时后，仍是不免发出一阵叹息，并转身投入到第一单元训练的怀抱中去，后对着训练任务照猫画虎完成了解析表达式后，又为计算发了愁(实际第一次作业的计算有了思路后较为简单)。思前想后，笔者认为本单元的难点在于化简计算，并非是递归下降法的实现，依然记得第二次作业设计架构时的纠结，既想保留现有架构，又要容纳的下三角函数因子，想过用ArrayList，想过开两个HashMap表示sin&amp;cos，想过HashMap里存Factor，从当初到如今思路的定型期间经历了无数次思考与尝试。相信大家有同感，本单元最难点在于三角函数的化简，不考虑花活的化简，其实完成基础的化简后，实现出平方和，诱导公式等花活也并非难事。笔者在第二周一整周几乎都在研究化简工作(并不完全为了卷性能分)，边化简边生怕化出Bug，化简到神志不清，化简到后面一周都不想碰OO，功夫不负有心人，即使仍有一些化简不完全的Bug，但基本可以实现化简且并不影响正确性。当看到自己写的程序被大家挑不出毛病时，当和大家在侃侃而谈自己的设计实现思路时，当学到大开眼界的JAVA用法以及面向对象思想时，我想我收获到了来自OO这门课的快乐，也希望大家在每个单元的学习中不断提高境界，不断成长!</p><p>听说第二单元很多人边写边哭，边哭边写，已经迫不及待想被多线程电梯虐了捏(误。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『操作系统』操作系统第六次理论作业</title>
      <link href="/post/b799ff9.html"/>
      <url>/post/b799ff9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『操作系统』操作系统第六次理论作业"><a href="#『操作系统』操作系统第六次理论作业" class="headerlink" title="『操作系统』操作系统第六次理论作业"></a>『操作系统』操作系统第六次理论作业</h1><h2 id="一-文件系统的性能对整体系统的性能影响很大，请总结在实现文件系统时可以从哪些方面提高文件系统的性能，简要给出这些手段的具体解决思路。"><a href="#一-文件系统的性能对整体系统的性能影响很大，请总结在实现文件系统时可以从哪些方面提高文件系统的性能，简要给出这些手段的具体解决思路。" class="headerlink" title="一. 文件系统的性能对整体系统的性能影响很大，请总结在实现文件系统时可以从哪些方面提高文件系统的性能，简要给出这些手段的具体解决思路。"></a>一. 文件系统的性能对整体系统的性能影响很大，请总结在实现文件系统时可以从哪些方面提高文件系统的性能，简要给出这些手段的具体解决思路。</h2><p>目录项分解，当前目录，磁盘碎片整理，块高速缓存，磁盘调度，提前读取，合理分配磁盘空间，信息的优化分布，RAID技术等。</p><p>（1）目录管理：改进文件的目录结构以及检索目录的方法，来减少对文件的查找时间；<br>（2）文件存储方式，访问方式：选择性能更优异的文件存储结构，以提高对文件的访问速度；<br>（3）提高磁盘读写速度：通过采用磁盘高速缓存、优化物理块的分布、利用提前读、延迟写、优化物理块分布、并行交叉存取或虚拟盘等方法来提高磁盘I/O速度，以提高对数据的传送速度。 </p><h2 id="二-简述文件控制块（FCB）的主要内容。"><a href="#二-简述文件控制块（FCB）的主要内容。" class="headerlink" title="二. 简述文件控制块（FCB）的主要内容。"></a>二. 简述文件控制块（FCB）的主要内容。</h2><p>虽然不同的系统,其文件控制块的内容和格式不完全相同,但通常都包括以下三类信息:基本信息、存取控制信息和使用信息。</p><p>(1)基本信息。包括文件名、文件号、用户名、文件类型、文件的物理地址、文件长度、文件的逻辑结构和物理结构等。其中用户名主要是指文件主和授权用户;而物理地址的内容通常与文件的物理结构有关,对于连续文件和链接文件,应说明起始盘块号,而对于索引文件,应给出其索引块号。</p><p>(2)存取控制信息。分别给出文件主、伙伴用户、一般用户的存取权限。</p><p>(3)使用信息。包括文件的建立日期及时间、上次存取文件的日期及时间、当前的使用信息等。</p><h2 id="三-在I-O系统中引入缓冲的主要原因是什么？某文件占10个磁盘块，现要把该文件的磁盘块逐个读入主存缓冲区，并送用户区进行分析。一个缓冲区与磁盘块大小相等。把一个磁盘块读入缓冲区的时间为100μs-1过程-，缓冲区数据传送到用户区的时间是50μs-2过程-，CPU对一块数据进行分析的时间为50μs-3过程-。分别计算在单缓冲区和双缓冲区结构下，分析完该文件的时间是多少？"><a href="#三-在I-O系统中引入缓冲的主要原因是什么？某文件占10个磁盘块，现要把该文件的磁盘块逐个读入主存缓冲区，并送用户区进行分析。一个缓冲区与磁盘块大小相等。把一个磁盘块读入缓冲区的时间为100μs-1过程-，缓冲区数据传送到用户区的时间是50μs-2过程-，CPU对一块数据进行分析的时间为50μs-3过程-。分别计算在单缓冲区和双缓冲区结构下，分析完该文件的时间是多少？" class="headerlink" title="三. 在I/O系统中引入缓冲的主要原因是什么？某文件占10个磁盘块，现要把该文件的磁盘块逐个读入主存缓冲区，并送用户区进行分析。一个缓冲区与磁盘块大小相等。把一个磁盘块读入缓冲区的时间为100μs(1过程)，缓冲区数据传送到用户区的时间是50μs(2过程)，CPU对一块数据进行分析的时间为50μs(3过程)。分别计算在单缓冲区和双缓冲区结构下，分析完该文件的时间是多少？"></a>三. 在I/O系统中引入缓冲的主要原因是什么？某文件占10个磁盘块，现要把该文件的磁盘块逐个读入主存缓冲区，并送用户区进行分析。一个缓冲区与磁盘块大小相等。把一个磁盘块读入缓冲区的时间为100μs(1过程)，缓冲区数据传送到用户区的时间是50μs(2过程)，CPU对一块数据进行分析的时间为50μs(3过程)。分别计算在单缓冲区和双缓冲区结构下，分析完该文件的时间是多少？</h2><p>引入缓冲的主要原因:</p><p>(1)缓和CPU与I/O 设备间速度不匹配的矛盾;</p><p>(2)减少对CPU的中断频率,放宽对中断响应时间的限制;</p><p>(3)提高CPU与I/O 设备之间的并行性。</p><p>1过程不需CPU，23过程需CPU</p><p><strong>单缓冲</strong>：<br>当磁盘块数据读入缓冲区的同时，CPU可以对一块数据进行处理，因此1，3过程可同步进行，由于1过程时间&gt;3过程时间，每个磁盘块需要150微秒，共需要$150*10 + 50 = 1550$微秒。2过程不能和1过程同时进行，因为只有一片缓冲区，必须等CPU读取完缓冲区的内容再进行下一个磁盘块的读入。</p><p><strong>双缓冲</strong>：<br>由于有两个缓冲区，则2过程也可和1过程同步进行，保证CPU和磁盘读写的不是一个缓冲区即可，因此处理每个磁盘块只需要100微秒，共需要$100*10 + 100 = 1100$微秒。<br><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/HW6_2.jpg" alt></p><h2 id="四-分析磁盘访问数据的时间。假设磁盘请求以柱面10、35、20、70、2、3和38的次序进入磁盘驱动器。寻道时磁头每移动一个柱面需要6ms，以下各算法所需的寻道时间是多少：a-先来先服务-b-最短寻道时间优先-c-扫描算法-说明：假设以上三种情况磁头初始位置为-15。对于扫描算法，磁头当前向大柱面号方向运行，磁盘最大柱面号为-85，分别讨论-SCAN和-LOOK-算法的寻道时间。"><a href="#四-分析磁盘访问数据的时间。假设磁盘请求以柱面10、35、20、70、2、3和38的次序进入磁盘驱动器。寻道时磁头每移动一个柱面需要6ms，以下各算法所需的寻道时间是多少：a-先来先服务-b-最短寻道时间优先-c-扫描算法-说明：假设以上三种情况磁头初始位置为-15。对于扫描算法，磁头当前向大柱面号方向运行，磁盘最大柱面号为-85，分别讨论-SCAN和-LOOK-算法的寻道时间。" class="headerlink" title="四. 分析磁盘访问数据的时间。假设磁盘请求以柱面10、35、20、70、2、3和38的次序进入磁盘驱动器。寻道时磁头每移动一个柱面需要6ms，以下各算法所需的寻道时间是多少：a) 先来先服务 b) 最短寻道时间优先 c) 扫描算法 说明：假设以上三种情况磁头初始位置为 15。对于扫描算法，磁头当前向大柱面号方向运行，磁盘最大柱面号为 85，分别讨论 SCAN和 LOOK 算法的寻道时间。"></a>四. 分析磁盘访问数据的时间。假设磁盘请求以柱面10、35、20、70、2、3和38的次序进入磁盘驱动器。寻道时磁头每移动一个柱面需要6ms，以下各算法所需的寻道时间是多少：a) 先来先服务 b) 最短寻道时间优先 c) 扫描算法 说明：假设以上三种情况磁头初始位置为 15。对于扫描算法，磁头当前向大柱面号方向运行，磁盘最大柱面号为 85，分别讨论 SCAN和 LOOK 算法的寻道时间。</h2><p><strong>先来先服务</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/HW6_3.jpg" alt><br>$(5+25+15+50+68+1+35)*6 = 1194ms$</p><p><strong>最短寻道(若一样选择来得早的)</strong>：<br><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/HW6_4.jpg" alt><br>$(5+7+1+18+15+3+32)*6 = 486ms$</p><p><strong>扫描算法</strong>：<br><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/HW6_5.jpg" alt><br>scan算法：$(70+83)*6 = 918ms$</p><p>look算法：$(55+68)*6 = 738ms$</p><h2 id="五-在文件系统中，访问一个文件-f-时首先需要从目录中找到与-f-对应的目录项。假设磁盘物理块的大小为-1KB，一个目录项的大小为-128-字节，文件的平均大小为100KB。该文件系统的目录结构如图所示。假定不考虑磁盘块的提前读和缓存等加速磁盘访问的技术。回答以下问题：1）-按照当前的目录结构，且采用串联文件方式对数据块进行组织，并且根目录的目录项已读入内存中。如果目标文件f-在第三级目录下，且其对应的第三级目录的目录项可以一次从磁盘读出，访问文件f中的一个块平均需要访问几次磁盘？2）如果采用-i-节点的方法来构建文件目录，假定文件名占-14-个字节，i-节点的指针占-2-个字节。如果仅采用直接索引，每个第三级目录下的文件数不超过-50-个，且根目录的-i-节点已读入内存，访问第三级目录下的一个文件的一个块平均需要访问几次磁盘？3）假设该文件系统的空间最大容量为-16ZB-1ZB-2-70-B-。如果文件的-FCB-中包括512-字节的索引区，且允许采用一级索引进行组织，那么该文件系统支持的最大文件是多少字节？"><a href="#五-在文件系统中，访问一个文件-f-时首先需要从目录中找到与-f-对应的目录项。假设磁盘物理块的大小为-1KB，一个目录项的大小为-128-字节，文件的平均大小为100KB。该文件系统的目录结构如图所示。假定不考虑磁盘块的提前读和缓存等加速磁盘访问的技术。回答以下问题：1）-按照当前的目录结构，且采用串联文件方式对数据块进行组织，并且根目录的目录项已读入内存中。如果目标文件f-在第三级目录下，且其对应的第三级目录的目录项可以一次从磁盘读出，访问文件f中的一个块平均需要访问几次磁盘？2）如果采用-i-节点的方法来构建文件目录，假定文件名占-14-个字节，i-节点的指针占-2-个字节。如果仅采用直接索引，每个第三级目录下的文件数不超过-50-个，且根目录的-i-节点已读入内存，访问第三级目录下的一个文件的一个块平均需要访问几次磁盘？3）假设该文件系统的空间最大容量为-16ZB-1ZB-2-70-B-。如果文件的-FCB-中包括512-字节的索引区，且允许采用一级索引进行组织，那么该文件系统支持的最大文件是多少字节？" class="headerlink" title="五. 在文件系统中，访问一个文件 f 时首先需要从目录中找到与 f 对应的目录项。假设磁盘物理块的大小为 1KB，一个目录项的大小为 128 字节，文件的平均大小为100KB。该文件系统的目录结构如图所示。假定不考虑磁盘块的提前读和缓存等加速磁盘访问的技术。回答以下问题：1） 按照当前的目录结构，且采用串联文件方式对数据块进行组织，并且根目录的目录项已读入内存中。如果目标文件f 在第三级目录下，且其对应的第三级目录的目录项可以一次从磁盘读出，访问文件f中的一个块平均需要访问几次磁盘？2）如果采用 i 节点的方法来构建文件目录，假定文件名占 14 个字节，i 节点的指针占 2 个字节。如果仅采用直接索引，每个第三级目录下的文件数不超过 50 个，且根目录的 i 节点已读入内存，访问第三级目录下的一个文件的一个块平均需要访问几次磁盘？3）假设该文件系统的空间最大容量为 16ZB(1ZB=2^70 B)。如果文件的 FCB 中包括512 字节的索引区，且允许采用一级索引进行组织，那么该文件系统支持的最大文件是多少字节？"></a>五. 在文件系统中，访问一个文件 f 时首先需要从目录中找到与 f 对应的目录项。假设磁盘物理块的大小为 1KB，一个目录项的大小为 128 字节，文件的平均大小为100KB。该文件系统的目录结构如图所示。假定不考虑磁盘块的提前读和缓存等加速磁盘访问的技术。回答以下问题：1） 按照当前的目录结构，且采用串联文件方式对数据块进行组织，并且根目录的目录项已读入内存中。如果目标文件f 在第三级目录下，且其对应的第三级目录的目录项可以一次从磁盘读出，访问文件f中的一个块平均需要访问几次磁盘？2）如果采用 i 节点的方法来构建文件目录，假定文件名占 14 个字节，i 节点的指针占 2 个字节。如果仅采用直接索引，每个第三级目录下的文件数不超过 50 个，且根目录的 i 节点已读入内存，访问第三级目录下的一个文件的一个块平均需要访问几次磁盘？3）假设该文件系统的空间最大容量为 16ZB(1ZB=2^70 B)。如果文件的 FCB 中包括512 字节的索引区，且允许采用一级索引进行组织，那么该文件系统支持的最大文件是多少字节？</h2><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/HW6_1.jpg" alt></p><ol><li><p><strong>访问二级目录</strong>：根目录的目录项已经读入内存，那么读取二级目录不需要访问磁盘。</p><p><strong>访问三级目录</strong>：一个磁盘块1KB，每个目录项128B，那么一个磁盘块可以放$1KB/128B=8$个目录项；而如图所示每个二级目录下有128个三级目录，这些三级目录分布在$128/8=16$个磁盘块上。串联文件形式，访问一个三级目录项至少访问1次磁盘，至多访问16次磁盘，平均8.5次。</p><p><strong>访问三级目录内容</strong>：由于对应三级目录项可以一次从磁盘读出，故访问一次即可。</p><p><strong>访问文件块</strong>：文件平均大小100KB，每个磁盘块1KB，每个文件平均要分布在$100KB/1KB=100$个磁盘块上。串联文件形式，访问一个块至少访问1次磁盘，至多访问100次，平均50.5次。</p><p>综上，平均共需要访问磁盘$0+8.5+1+50.5=60$次。</p></li><li><p>由图中可知，第三级目录位于usr2下面。一个目录项占16个字节，因此一个磁盘块可以放$2 ^ {10}/2 ^ 4=2^6=64$ 个目录项。</p><p><strong>读取根目录的内容需读取1次磁盘</strong>：根目录inode已在内存中，根目录下只有3个目录项，可以1次读取。</p><p><strong>读取usr2的inode需读取1次磁盘</strong>：从对应usr2的目录项中可获得usr2的inode号，进而通过读取磁盘可获得usr2的inode。</p><p><strong>读取usr2目录的内容（即对应d0-d127的目录项）需读取1.5次磁盘</strong>：读取整个第三级目录所对应的目录项需要访问磁盘128/64=2次，因此平均需要读取(1+2)/2=1.5次。</p><p><strong>读取第三级目录的inode需读取1次磁盘</strong>。</p><p><strong>读取第三级目录的内容需读取1次磁盘</strong>：由于第三级目录下的文件不超过50个，因此读取1次磁盘即可将对应全部文件的目录项读出。</p><p><strong>读取文件的inode需要读取1次磁盘</strong>。</p><p><strong>读取文件的1个块需要读取1次磁盘</strong>：由于采用直接索引，故根据inode可直接读取磁盘上文件的一个块。</p><p> 综上，访问第三级目录下一个文件的一个块平均需要 $1+1+1.5+1+1+1+1=7.5$ 次磁盘。</p></li><li><p>文件系统最多允许记录的磁盘块数为$16ZB/1KB=2^{64}$个磁盘块。为表示这些磁盘块，需要64位，即8字节空间。inode中的索引区可以存放 $512B/8B=64$个磁盘块，一级索引指向的磁盘块中可存储$1KB/8B=128$个磁盘块号，在采用一级索引的情况下，支持的最大文件为$64\times128\times1KB=8MB$。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『操作系统』操作系统第五次理论作业</title>
      <link href="/post/3738fa77.html"/>
      <url>/post/3738fa77.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『操作系统』操作系统第五次理论作业"><a href="#『操作系统』操作系统第五次理论作业" class="headerlink" title="『操作系统』操作系统第五次理论作业"></a>『操作系统』操作系统第五次理论作业</h1><h2 id="一-有五个进程P1、P2、P3、P4、P5，它们同时依次进入就绪队列，它们的优先数和需要的处理器时间如下表，忽略进行调度等所花费的时间，回答下列问题"><a href="#一-有五个进程P1、P2、P3、P4、P5，它们同时依次进入就绪队列，它们的优先数和需要的处理器时间如下表，忽略进行调度等所花费的时间，回答下列问题" class="headerlink" title="一. 有五个进程P1、P2、P3、P4、P5，它们同时依次进入就绪队列，它们的优先数和需要的处理器时间如下表，忽略进行调度等所花费的时间，回答下列问题:"></a>一. 有五个进程P1、P2、P3、P4、P5，它们同时依次进入就绪队列，它们的优先数和需要的处理器时间如下表，忽略进行调度等所花费的时间，回答下列问题:</h2><h2 id="a-写出采用“先来先服务”、“短作业（进程）优先”、“非抢占式的优先数”和“轮转法”等调度算法，进程执行的次序。（其中轮转法的时间片为2）"><a href="#a-写出采用“先来先服务”、“短作业（进程）优先”、“非抢占式的优先数”和“轮转法”等调度算法，进程执行的次序。（其中轮转法的时间片为2）" class="headerlink" title="a. 写出采用“先来先服务”、“短作业（进程）优先”、“非抢占式的优先数”和“轮转法”等调度算法，进程执行的次序。（其中轮转法的时间片为2）"></a>a. 写出采用“先来先服务”、“短作业（进程）优先”、“非抢占式的优先数”和“轮转法”等调度算法，进程执行的次序。（其中轮转法的时间片为2）</h2><h2 id="b-分别计算上述算法中各进程的周转时间和等待时间，以及平均周转时间。"><a href="#b-分别计算上述算法中各进程的周转时间和等待时间，以及平均周转时间。" class="headerlink" title="b. 分别计算上述算法中各进程的周转时间和等待时间，以及平均周转时间。"></a>b. 分别计算上述算法中各进程的周转时间和等待时间，以及平均周转时间。</h2><div class="table-container"><table><thead><tr><th style="text-align:center">进程</th><th style="text-align:center">处理器时间</th><th style="text-align:center">优先级（数小优先级高）</th></tr></thead><tbody><tr><td style="text-align:center">P1</td><td style="text-align:center">10</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">P2</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">P3</td><td style="text-align:center">2</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">P4</td><td style="text-align:center">1</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">P5</td><td style="text-align:center">5</td><td style="text-align:center">2</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/HW5_1.jpg" alt></p><p>先来先服务：</p><div class="table-container"><table><thead><tr><th style="text-align:center">进程</th><th style="text-align:center">周转时间</th><th style="text-align:center">等待时间</th></tr></thead><tbody><tr><td style="text-align:center">P1</td><td style="text-align:center">10</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">P2</td><td style="text-align:center">11</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">P3</td><td style="text-align:center">13</td><td style="text-align:center">11</td></tr><tr><td style="text-align:center">P4</td><td style="text-align:center">14</td><td style="text-align:center">13</td></tr><tr><td style="text-align:center">P5</td><td style="text-align:center">19</td><td style="text-align:center">14</td></tr><tr><td style="text-align:center">平均周转时间：13.4</td><td style="text-align:center"></td></tr></tbody></table></div><p>短作业优先：</p><div class="table-container"><table><thead><tr><th style="text-align:center">进程</th><th style="text-align:center">周转时间</th><th style="text-align:center">等待时间</th></tr></thead><tbody><tr><td style="text-align:center">P1</td><td style="text-align:center">19</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">P2</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">P3</td><td style="text-align:center">4</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">P4</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">P5</td><td style="text-align:center">9</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">平均周转时间：7</td><td style="text-align:center"></td></tr></tbody></table></div><p>非抢占优先数：</p><div class="table-container"><table><thead><tr><th style="text-align:center">进程</th><th style="text-align:center">周转时间</th><th style="text-align:center">等待时间</th></tr></thead><tbody><tr><td style="text-align:center">P1</td><td style="text-align:center">16</td><td style="text-align:center">6</td></tr><tr><td style="text-align:center">P2</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">P3</td><td style="text-align:center">18</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">P4</td><td style="text-align:center">19</td><td style="text-align:center">18</td></tr><tr><td style="text-align:center">P5</td><td style="text-align:center">6</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">平均周转时间：12</td><td style="text-align:center"></td></tr></tbody></table></div><p>时间片轮转：</p><div class="table-container"><table><thead><tr><th style="text-align:center">进程</th><th style="text-align:center">周转时间</th><th style="text-align:center">等待时间</th></tr></thead><tbody><tr><td style="text-align:center">P1</td><td style="text-align:center">19</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">P2</td><td style="text-align:center">3</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">P3</td><td style="text-align:center">5</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">P4</td><td style="text-align:center">6</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">P5</td><td style="text-align:center">15</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">平均周转时间：9.6</td><td style="text-align:center"></td></tr></tbody></table></div><h2 id="二-死锁产生的四个必要条件是什么？"><a href="#二-死锁产生的四个必要条件是什么？" class="headerlink" title="二. 死锁产生的四个必要条件是什么？"></a>二. 死锁产生的四个必要条件是什么？</h2><ol><li>互斥条件</li><li>请求与保持条件</li><li>不剥夺条件</li><li>循环等待条件</li></ol><h2 id="三-某系统中有n个进程和m台打印机，系统约定：打印机只能一台一台地申请、一台一台地释放，每个进程需要同时使用的打印机台数不超过m。如果n个进程同时需要使用打印机的总数小于m-n，试讨论，该系统可能发生死锁吗-并简述理由。"><a href="#三-某系统中有n个进程和m台打印机，系统约定：打印机只能一台一台地申请、一台一台地释放，每个进程需要同时使用的打印机台数不超过m。如果n个进程同时需要使用打印机的总数小于m-n，试讨论，该系统可能发生死锁吗-并简述理由。" class="headerlink" title="三. 某系统中有n个进程和m台打印机，系统约定：打印机只能一台一台地申请、一台一台地释放，每个进程需要同时使用的打印机台数不超过m。如果n个进程同时需要使用打印机的总数小于m+n，试讨论，该系统可能发生死锁吗?并简述理由。"></a>三. 某系统中有n个进程和m台打印机，系统约定：打印机只能一台一台地申请、一台一台地释放，每个进程需要同时使用的打印机台数不超过m。如果n个进程同时需要使用打印机的总数小于m+n，试讨论，该系统可能发生死锁吗?并简述理由。</h2><p>证明：<br>设第i个进程最大打印机需求量为$R_i(1 ≤ R_i ≤ m)$，考虑最坏情况，所有进程都已经得到了$R_i-1$个资源，都还差一个资源即可满足最大要求开始执行，此时若还剩下至少一个资源，则分配给任何一个进程皆可开始运行，则系统不会产生死锁。</p><p>$∑(R_i - 1)+ 1 = m$<br>$∑R_i - n + 1 = m$<br>$∑R_i = m + n - 1$<br>$∑R_i &lt; m + n$</p><p>满足题目要求，因此不会产生死锁。</p><h2 id="四-线程的基本概念是什么？引入线程的好处是什么？"><a href="#四-线程的基本概念是什么？引入线程的好处是什么？" class="headerlink" title="四. 线程的基本概念是什么？引入线程的好处是什么？"></a>四. 线程的基本概念是什么？引入线程的好处是什么？</h2><p>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><p>好处：</p><ol><li>创建一个新线程的代价比创建一个新进程要小的多；</li><li>与进程相比，线程之间的切换需要操作系统做的工作要少很多；</li><li>线程占用的资源要比进程少很多；</li><li>能充分利用多处理器的可并行数量；</li><li>在等待慢速I/O操作结束的同时，程序可执行其他的计算任务；</li><li>计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现；</li><li>I/O密集型应用，为了能提高性能，将I/O操作重叠。线程可以同时等待不同的I/O操作。</li></ol><h2 id="五-一个系统有4个进程和5个可分配资源，当前分配和最大需求如下，若保持该状态是安全状态，那么x的最小值是多少？"><a href="#五-一个系统有4个进程和5个可分配资源，当前分配和最大需求如下，若保持该状态是安全状态，那么x的最小值是多少？" class="headerlink" title="五. 一个系统有4个进程和5个可分配资源，当前分配和最大需求如下，若保持该状态是安全状态，那么x的最小值是多少？"></a>五. 一个系统有4个进程和5个可分配资源，当前分配和最大需求如下，若保持该状态是安全状态，那么x的最小值是多少？</h2><div class="table-container"><table><thead><tr><th style="text-align:center">进程</th><th style="text-align:center">已分配资源</th><th style="text-align:center">最大需求量</th><th style="text-align:center">可用资源</th></tr></thead><tbody><tr><td style="text-align:center">进程A</td><td style="text-align:center">10211</td><td style="text-align:center">11213</td><td style="text-align:center">00x12</td></tr><tr><td style="text-align:center">进程B</td><td style="text-align:center">20110</td><td style="text-align:center">22210</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">进程C</td><td style="text-align:center">11010</td><td style="text-align:center">21310</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">进程D</td><td style="text-align:center">11110</td><td style="text-align:center">11221</td></tr></tbody></table></div><p>各进程需求矩阵<br>A 01002<br>B 02100<br>C 10300<br>D 00111</p><p>分类讨论：</p><p>若x为0，则可用资源无法满足任何请求，发生死锁；<br>若x为1，则可用资源可以满足D请求，D执行完后可用资源为11222，A可执行，A执行完后可用资源为10220+11213=21433，C可执行，C执行完后可用资源为11133+21310=32443，B可执行，故皆可执行结束。x最小为1。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『操作系统』操作系统实验LAB2附——页表自映射</title>
      <link href="/post/5d68e32d.html"/>
      <url>/post/5d68e32d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『操作系统』操作系统实验LAB2附——页表自映射"><a href="#『操作系统』操作系统实验LAB2附——页表自映射" class="headerlink" title="『操作系统』操作系统实验LAB2附——页表自映射"></a>『操作系统』操作系统实验LAB2附——页表自映射</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>笔者在写LAB2时便对该问题不解，拖到LAB4写完才有功夫想起来解决这个问题。在LAB2时，我以为的自映射机制是指页目录的一项映射到他自身，1024个二级页表中有一张是页目录，而把这个“自映射”的前提<strong>整个页表在虚拟空间是连续的，且有一个固定的起始虚拟地址值</strong>想的理所当然，当然后面我很快发现了这一问题，然而一直想不通究竟如何实现，写LAB3为进程块初始化虚拟空间时，有这么一条语句：</p><pre><code>e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V;</code></pre><p>解释说是实现了自映射，可笔者仍不解，为什么单靠一句话就将页表变成“连续”的呢?</p><p>特别鸣谢：guo-hy哥哥的博客</p><h2 id="虚实转化"><a href="#虚实转化" class="headerlink" title="虚实转化"></a>虚实转化</h2><p>在我们完成实验所采用的R3000上，软件访存的虚拟地址会先被 MMU 硬件映射到物理地址，随后使用物理地址来访问内存或其他外设。虚实转化这一步是由硬件帮我们进行，页表填充等工作都是OS在辅助进行，硬件只需要知道一个信息即可，即<strong>页目录物理地址</strong>，在x86架构下存储在CR3寄存器中，在本实验中由于并未涉及硬件，笔者也不是很清楚，但总之硬件一定会得知这个信息，并根据高十位偏移量找到二级页表的物理地址，接着去访问对应的二级页表，再根据中十位偏移量找到需要寻找的物理地址，加上页偏移量，即完成了虚实转化。</p><p>然而这些过程对于软件是不可见的(内核态下可以通过e-&gt;pgdir访问)，换句话说，用户无法直接访问到页目录，乃至二级页表，这便造成了一定的局限性，我们有没有方法令用户也能通过一个确定的虚拟地址(UVPT)访问到页表呢，这便需要自映射机制了。</p><h2 id="自映射机制"><a href="#自映射机制" class="headerlink" title="自映射机制"></a>自映射机制</h2><ol><li>UVPT = 0x7fc0 0000，后22位皆为0，是4MB对齐的地址</li><li>在页表初始化时，e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V，这句话的含义为<strong>页目录的第511(UVPT前十位)项中填充的物理页号是页目录自身的物理页号</strong>。</li></ol><p>以上两个条件是核心中的核心。</p><p>在用户虚拟空间，页表被存储在[UVPT,UVPT+4MB)之中，当我们访问UVPT时，硬件会找到页目录物理首地址并找到511项，因此我们访问到的是页目录自身的物理地址(页目录也是特殊的二级页表)，接着由于中十位偏移量为0，我们会访问到第一张二级页表的物理地址，<strong>即使二级页表之间物理地址是不连续的，即使甚至第一张二级页表都还没有对应的物理页面，在用户看来，我们是通过UVPT这一虚拟地址访问到了一个看似连续的二级页表的首地址</strong>。</p><p>我们同样可以通过 UVPT＋虚拟页号 的方式访问到任何想访问的页表项。值得注意的是，UVPT在这里是int<em>的指针，因此虚拟页号在地址计算上需\</em>4才可(虚拟页号有22位偏移)。由于4MB对齐的限制，UVPT高十位永远不变，因此高十位将<strong>永远</strong>访问到页目录，根据中十位的偏移找到页目录中对应的二级页表的物理地址，再根据页偏移找到想要访问的二级页表对应的页表项。这样我们便<strong>使用一段连续的虚拟地址，访问到了页表的各项，实现了自映射</strong>。</p><p>再来观察UVPD = UVPT + UVPT &gt;&gt; 10，计算方式就不多赘述。经过上述流程，不难发现，高十位访问到了页目录，中十位又访问到了页目录，页偏移量为0，因此最后的效果为<strong>访问到了页目录的起始地址</strong>。</p><p>记录下来以后豁然开朗，萦绕心头多年的乌云终于消散。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『操作系统』操作系统实验LAB6 Challenge</title>
      <link href="/post/318802fe.html"/>
      <url>/post/318802fe.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="操作系统LAB6挑战性任务实验报告"><a href="#操作系统LAB6挑战性任务实验报告" class="headerlink" title="操作系统LAB6挑战性任务实验报告"></a>操作系统LAB6挑战性任务实验报告</h1><h2 id="一-实现需求"><a href="#一-实现需求" class="headerlink" title="一.实现需求"></a>一.实现需求</h2><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/C_1.jpg" alt></p><p>指导书要求实现的功能：</p><ul><li>一行多命令</li><li>后台任务操作符 <strong>&amp;</strong></li><li>引号支持 <strong>“”</strong></li><li>光标交互的完善，上下左右BACKSPACE功能实现以及协作交互</li><li>程序名称 .b 的省略</li><li>记录历史命令</li><li>更丰富的命令：支持tree; mkdir [-p]; touch [-p]; history</li><li>选做一：实现shell环境变量，支持declare [-xr]; unset</li><li>选做二：支持相对路径, 支持内部命令cd，pwd</li></ul><p>自己额外实现的功能：</p><ul><li>追加重定向 <strong>&gt;&gt;</strong></li><li>转义符 <strong>\</strong></li><li>支持上级目录 <strong>..</strong> , 当前目录 <strong>.</strong></li><li>更丰富的命令：支持 cp [-r]; mv; rm [-rf]; rmdir [-p]</li><li>命令与路径自动补全</li></ul><p>上述所有功能皆以 Linux 的行为作为参照，某些地方存在差异。</p><h2 id="二-实现思路"><a href="#二-实现思路" class="headerlink" title="二. 实现思路"></a>二. 实现思路</h2><h3 id="1-一行多命令"><a href="#1-一行多命令" class="headerlink" title="1. 一行多命令"></a>1. 一行多命令</h3><p>核心代码如下，同管道机制，令父进程执行右面，子进程执行左面，父进程等待子进程结束后再开始执行。</p><p><strong>sh.c</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span>: <span class="comment">//依次执行左右两边的指令</span></span><br><span class="line">    <span class="keyword">if</span> ((r = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">debugf</span>(<span class="string">&quot;fork error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">0</span>) &#123; <span class="comment">//父进程</span></span><br><span class="line">        <span class="built_in">wait</span>(r); <span class="comment">//等待子进程结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parsecmd</span>(argv, rightpipe);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> argc;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>测试如下：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/C_2.jpg" alt></p><h3 id="2-后台命令"><a href="#2-后台命令" class="headerlink" title="2. 后台命令"></a>2. 后台命令</h3><p>基本同一行多命令，只不过父进程不再等待子进程结束，而是同步执行。由于在父进程执行完命令后shell便会开始读取新一行的指令，而控制台读取字符的方式是忙等，即CPU轮询，因此会出现父进程执行完后子进程还未执行完，直到输入下一条命令后子进程的输出才会显示出来的现象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> ((r = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">debugf</span>(<span class="string">&quot; &amp; fork error!!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">0</span>) &#123; <span class="comment">//父进程执行右面，当右面执行完毕，即可开始下一次轮询获取指令 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parsecmd</span>(argv, rightpipe);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//子进程执行左面</span></span><br><span class="line">        <span class="keyword">return</span> argc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>测试如下：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/C_4.jpg" alt></p><h3 id="3-引号支持"><a href="#3-引号支持" class="headerlink" title="3. 引号支持"></a>3. 引号支持</h3><p>支持引号，支持转义 \ 和 “ ，由于转义会忽略 \ ，使用原先的输入序列进行字符串切割分割为许多子串的方法会出现问题，因此开了二维字符串数组来存储处理过的token。</p><p><strong>_gettoken</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> w[<span class="number">128</span>][<span class="number">128</span>];</span><br><span class="line"><span class="type">int</span> wcnt;</span><br><span class="line"></span><br><span class="line">wcnt++;</span><br><span class="line"><span class="keyword">while</span> (*s &amp;&amp; !<span class="built_in">strchr</span>(WHITESPACE SYMBOLS, *s)) &#123; <span class="comment">//读过整个单词</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">strchr</span>(<span class="string">&quot;\&quot;&quot;</span>, *s)) &#123;</span><br><span class="line">s++;</span><br><span class="line"><span class="keyword">while</span>(*s &amp;&amp; !<span class="built_in">strchr</span>(<span class="string">&quot;\&quot;&quot;</span>, *s)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strchr</span>(<span class="string">&quot;\\&quot;</span>, *s) &amp;&amp; <span class="built_in">strchr</span>(<span class="string">&quot;\&quot;\\&quot;</span>, *(s + <span class="number">1</span>))) &#123; <span class="comment">// \\ \&quot; </span></span><br><span class="line">s++;</span><br><span class="line">&#125;</span><br><span class="line">w[wcnt][c++] = *s;</span><br><span class="line">s++;</span><br><span class="line">&#125;</span><br><span class="line">s++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strchr</span>(<span class="string">&quot;\\&quot;</span>, *s) &amp;&amp; <span class="built_in">strchr</span>(<span class="string">&quot;\&quot;\\&quot;</span>, *(s + <span class="number">1</span>))) &#123;</span><br><span class="line">s++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//debugf(&quot; %c &quot;, *s);</span></span><br><span class="line">w[wcnt][c++] = *s;</span><br><span class="line">s++;</span><br><span class="line">&#125;</span><br><span class="line">*p2 = s;</span><br><span class="line">w[wcnt][c] = <span class="number">0</span>; <span class="comment">//封0</span></span><br><span class="line">*p1 = w[wcnt];</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;w&#x27;</span>;</span><br></pre></td></tr></table></figure><p>基本功能与linux保持一致，测试如下：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/C_3.jpg" alt></p><h3 id="4-光标交互"><a href="#4-光标交互" class="headerlink" title="4. 光标交互"></a>4. 光标交互</h3><p><strong>这一部分是本实验第一大难点。</strong>课程组给好的shell无法删除，也只能在光标处进行修改字符，而且修改后也无法正常运行，这是由于<strong>输入逻辑与内部逻辑不匹配</strong>导致的，为方便后续功能的实现与测试，做好用户交互是重要的，因此笔者完全按照Linux的逻辑修改了光标交互，具体来说，按BACKSPACE可以删除光标后的字符，按LEFT和RIGHT可以调整光标的位置，输入字符时会<strong>增加</strong>而非<strong>替换</strong>，按UP和DOWN可以翻滚历史命令，并同样支持修改，总的来说与跳板机Linux无异。</p><p>首先，控制台有几个基本逻辑，这些逻辑不体现在代码上，应当是外设的逻辑：</p><ol><li>输出一个字符就在光标处的原本字符替换为该字符 且光标前移一个，控制符包括\0不会改变光标位置</li><li>right left 只会让光标左移右移，backspace 对光标无影响</li><li>上键光标会往上一格 而下键不会往下一格</li></ol><p>用到的ASCII码，其中上下左右键由三个ASCII码组成</p><ul><li>up: 27 91 65</li><li>down: 27 91 66</li><li>left: 27 91 68</li><li>right: 27 91 67</li><li>backspace: 127。</li></ul><p>刚刚提到逻辑不匹配的问题，因此我们除了维护<strong>输入序列</strong>外还需维护一个<strong>真正待执行的指令字符串序列</strong>，并维护字符串长度 max 以及当前光标的位置 pointer。在显示上，使用输出空格和\b退格的方式调整光标的位置和可视化指令序列，其重点在于既要修改外部显示又要修改内部指令序列，确保<strong>眼见必定为实</strong>。</p><p>核心代码如下，经过后续大量测试正确性得以保证：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">readline</span><span class="params">(<span class="type">char</span> *buf, <span class="type">char</span> *buf1, u_int n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf1, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">    <span class="type">int</span> pointer = <span class="number">0</span>; <span class="comment">//指向光标所在位置</span></span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> history = <span class="built_in">open</span>(<span class="string">&quot;cmd.history&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="type">int</span> hispointer = <span class="built_in">get_file_size</span>(history); <span class="comment">//记录file的屁股</span></span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = <span class="built_in">read</span>(<span class="number">0</span>, buf + i, <span class="number">1</span>)) != <span class="number">1</span>) &#123; <span class="comment">//从标准读入中读取数据</span></span><br><span class="line">            <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">debugf</span>(<span class="string">&quot;read error: %d\n&quot;</span>, r);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">exit</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (buf[i] == <span class="string">&#x27;\b&#x27;</span> || buf[i] == <span class="number">0x7f</span>) &#123; <span class="comment">//三种特殊情况</span></span><br><span class="line">            <span class="comment">//buf1[pointer] = &#x27; &#x27;;</span></span><br><span class="line">            <span class="keyword">if</span> (pointer != <span class="number">0</span>) &#123; <span class="comment">//删除 max--</span></span><br><span class="line">                <span class="type">char</span> tmp[<span class="number">128</span>];</span><br><span class="line">                <span class="built_in">strcpy</span>(tmp, buf1 + pointer); <span class="comment">//从pointer到最后暂存起来</span></span><br><span class="line">                <span class="keyword">if</span> (buf[i] != <span class="string">&#x27;\b&#x27;</span>) &#123; <span class="comment">//输出一个回退字符 回退光标同步</span></span><br><span class="line">                    <span class="built_in">debugf</span>(<span class="string">&quot;\b&quot;</span>); <span class="comment">//到后面一格</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; max - pointer; j++) &#123;</span><br><span class="line">                    <span class="built_in">debugf</span>(<span class="string">&quot;%c&quot;</span>, tmp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; max - pointer + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    <span class="built_in">debugf</span>(<span class="string">&quot;\b&quot;</span>);</span><br><span class="line">                &#125; <span class="comment">//多回退一个</span></span><br><span class="line">                pointer--;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>, k = pointer; tmp[j] != <span class="number">0</span>; j++, k++) &#123;</span><br><span class="line">                    buf1[k] = tmp[j]; <span class="comment">//修改buf1中内容</span></span><br><span class="line">                &#125;</span><br><span class="line">                buf1[k] = <span class="number">0</span>;</span><br><span class="line">                max--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (buf[i] == <span class="number">27</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            r = <span class="built_in">read</span>(<span class="number">0</span>, buf+i, <span class="number">1</span>);</span><br><span class="line">            i++;</span><br><span class="line">            r = <span class="built_in">read</span>(<span class="number">0</span>, buf+i, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (buf[i] == <span class="number">68</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pointer != <span class="number">0</span>) &#123;</span><br><span class="line">                    pointer--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">debugf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buf[i] == <span class="number">67</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pointer &lt; max) &#123;</span><br><span class="line">                    pointer++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">debugf</span>(<span class="string">&quot;\b&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buf[i] == <span class="number">65</span>) &#123; <span class="comment">//up</span></span><br><span class="line">                <span class="comment">//debugf(&quot;\n21373037:(%s)$ &quot;, env-&gt;env_workingpath); //往上滚了 所以要换行一下到原来的位置</span></span><br><span class="line">                <span class="built_in">debugf</span>(<span class="string">&quot;%c%c%c&quot;</span>, <span class="number">27</span>, <span class="number">91</span>, <span class="number">66</span>); <span class="comment">//下移</span></span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; pointer; j++) &#123;</span><br><span class="line">                    <span class="built_in">debugf</span>(<span class="string">&quot;\b&quot;</span>); <span class="comment">//没刷掉</span></span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; max; j++) &#123;</span><br><span class="line">                    <span class="built_in">debugf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; max; j++) &#123;</span><br><span class="line">                    <span class="built_in">debugf</span>(<span class="string">&quot;\b&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">uphistory</span>(buf1, &amp;hispointer);</span><br><span class="line">                pointer = <span class="built_in">strlen</span>(buf1);</span><br><span class="line">                max = pointer;</span><br><span class="line">                <span class="comment">//debugf(&quot;poi : %d\n &quot;, pointer);</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buf[i] == <span class="number">66</span>) &#123;</span><br><span class="line">                <span class="comment">//debugf(&quot;%c%c%c&quot;, 27, 91, 65); //上移</span></span><br><span class="line">                <span class="comment">//debugf(&quot;\n21373037:(%s)$ &quot;, env-&gt;env_workingpath);</span></span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; pointer; j++) &#123;</span><br><span class="line">                    <span class="built_in">debugf</span>(<span class="string">&quot;\b&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; max; j++) &#123;</span><br><span class="line">                    <span class="built_in">debugf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; max; j++) &#123;</span><br><span class="line">                    <span class="built_in">debugf</span>(<span class="string">&quot;\b&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">downhistory</span>(buf1, &amp;hispointer);</span><br><span class="line">                pointer = <span class="built_in">strlen</span>(buf1);</span><br><span class="line">                max = pointer;</span><br><span class="line">                <span class="comment">//debugf(&quot;poi : %d\n&quot;, pointer);</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (buf[i] == <span class="string">&#x27;\r&#x27;</span> || buf[i] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            buf[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> tmp[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(tmp, buf1 + pointer); <span class="comment">//暂存指针之后所有内容</span></span><br><span class="line">        <span class="comment">//printf(&quot;%c&quot;, buf[i]); //正常情况</span></span><br><span class="line">        buf1[pointer] = buf[i];</span><br><span class="line">        pointer++;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>, k = pointer; j &lt; <span class="built_in">strlen</span>(tmp); j++, k++) &#123;</span><br><span class="line">            <span class="built_in">debugf</span>(<span class="string">&quot;%c&quot;</span>, tmp[j]);</span><br><span class="line">            buf1[k] = tmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(tmp); j++) &#123;</span><br><span class="line">            <span class="built_in">debugf</span>(<span class="string">&quot;\b&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        max++; <span class="comment">//记录最大长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本功能用图不好展示，可以实际展示，使用时<strong>与Linux一模一样</strong>。</p><h3 id="5-程序名称-b的省略"><a href="#5-程序名称-b的省略" class="headerlink" title="5. 程序名称.b的省略"></a>5. 程序名称.b的省略</h3><p>最简单的一项，判断$argv[0]$（指令名称）结尾是否为$.b$，若不是，加上后缀即可。需要注意的是，若仍使用在原本字符串上切割的方式得到$argv[i]$的方法(即自带的方法)，则往后追加$.b$会占用到别的$argv$的空间，造成严重的错误，将$argv[0]$拷贝一份再追加是正确的选择。</p><h3 id="6-记录历史命令"><a href="#6-记录历史命令" class="headerlink" title="6. 记录历史命令"></a>6. 记录历史命令</h3><p>在shell执行开始时创建 cmd.history 文件，在每次读入命令后将该行命令追加到文件尾，以\n作为分隔符，追加写入即使用文件控制块得到文件大小再使用 seek 函数找到文件尾写入即可，追加重定向 &gt;&gt; 也是同样思路。</p><p>上下键的翻滚，需要动态维护一颗指针(永远指向\n的后一个字符)，初始时指向文件尾，向上翻滚则找到上一个\n，并读取两个\n中间的内容，向下翻滚则找到下一个\n，并读取再向下一行的内容。重点在于上下的临界情况要考虑清楚，若到达上下界再翻滚应当无事发生。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">uphistory</span><span class="params">(<span class="type">char</span> *buf1, <span class="type">int</span> *hispointer)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(buf1, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (*hispointer == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//debugf(&quot;no up!&quot;);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> history = <span class="built_in">open</span>(<span class="string">&quot;cmd.history&quot;</span>, O_RDWR); <span class="comment">//从0开始</span></span><br><span class="line">    <span class="type">char</span> file[*hispointer];</span><br><span class="line">    <span class="type">int</span> last = <span class="number">0</span>, i;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>(history, file, *hispointer); <span class="comment">//file找临近末尾的\n</span></span><br><span class="line">    <span class="comment">//debugf(&quot; %d &quot;, file[*hispointer - 1]); 换行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = *hispointer - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (file[i] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            last = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从Last 到 hispointer</span></span><br><span class="line">    <span class="keyword">for</span> (i = last; i &lt; *hispointer - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">debugf</span>(<span class="string">&quot;%c&quot;</span>, file[i]);</span><br><span class="line">        buf1[i - last] = file[i];</span><br><span class="line">    &#125;</span><br><span class="line">    buf1[i - last] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//把\n读走</span></span><br><span class="line">    *hispointer = last;</span><br><span class="line">    <span class="built_in">close</span>(history);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">downhistory</span><span class="params">(<span class="type">char</span> *buf1, <span class="type">int</span> *hispointer)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(buf1, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">    <span class="type">int</span> history = <span class="built_in">open</span>(<span class="string">&quot;cmd.history&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="built_in">seek</span>(history, *hispointer);</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">int</span> i, tmp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">        r = <span class="built_in">read</span>(history, buf1 + i, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//debugf(&quot; %d &quot;, buf1[i]);</span></span><br><span class="line">        <span class="keyword">if</span> (buf1[i] == <span class="number">0</span>) &#123; <span class="comment">//适用于一开始便在文件末尾处</span></span><br><span class="line">            <span class="comment">//debugf(&quot;no down!&quot;);</span></span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">debugf</span>(<span class="string">&quot;down wrong!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (buf1[i] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//debugf(&quot; nextline &quot;);</span></span><br><span class="line">            tmp = *hispointer + i + <span class="number">1</span>; <span class="comment">//给pointer赋上值</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(buf1, <span class="number">0</span>, <span class="number">1024</span>); <span class="comment">//要回显的是再下一条</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">        r = <span class="built_in">read</span>(history, buf1 + i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (buf1[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//debugf(&quot;no down!&quot;);</span></span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">debugf</span>(<span class="string">&quot;doen wrong!\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (buf1[i] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            *hispointer = tmp;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">debugf</span>(<span class="string">&quot;%c&quot;</span>, buf1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    buf1[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">close</span>(history);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>展示如下：<br><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/C_5.jpg" alt></p><h3 id="7-更丰富的命令"><a href="#7-更丰富的命令" class="headerlink" title="7. 更丰富的命令"></a>7. 更丰富的命令</h3><p>与文件系统交互的指令大致分为两种，一种是只读文件结构，在用户进程便可处理，比如ls，tree；另一种需要对文件结构进行写入，笔者通过已经写到麻木的与文件服务进程交互的方式，通过文件服务进程对其修改。</p><h4 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h4><p>tree是输出文件系统树状结构，不涉及改变文件结构，仿照ls递归输出即可，笔者特别对目录和文件在输出时做出了区分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> deepth = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tree</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *name)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">int</span> fd, n;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">File</span> f;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Stat</span> st;</span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">stat</span>(path, &amp;st)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">user_panic</span>(<span class="string">&quot;stat fail!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">user_panic</span>(<span class="string">&quot;open fail!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!st.st_isdir) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; deepth; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;----&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name);</span><br><span class="line">        deepth--;</span><br><span class="line">        <span class="built_in">close</span>(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((n = <span class="built_in">readn</span>(fd, &amp;f, <span class="keyword">sizeof</span> f)) == <span class="keyword">sizeof</span> f) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f.f_name[<span class="number">0</span>]) &#123; <span class="comment">//寻找dir的下层 只有是目录时要输出名字 文件时在上面输出</span></span><br><span class="line">            deepth++;</span><br><span class="line">            <span class="keyword">if</span> (f.f_type == FTYPE_DIR) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; deepth; i++) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;----&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;*%s\n&quot;</span>, f.f_name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">strlen</span>(f.f_name) + <span class="built_in">strlen</span>(path) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">char</span> newpath[len + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(newpath, path);</span><br><span class="line">            <span class="built_in">strcpy</span>(newpath + <span class="built_in">strlen</span>(path), <span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="built_in">strcpy</span>(newpath + <span class="built_in">strlen</span>(path) + <span class="number">1</span>, f.f_name);</span><br><span class="line">            newpath[len+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">tree</span>(newpath, f.f_name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    deepth--;</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里实现的tree的展示逻辑和Linux的树状展示逻辑存在较大区别，算是挑战性任务中的较大瑕疵。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/C_7.jpg" alt></p><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>mkdir是增加文件结构的指令，根据能不能创建多级目录(一口气创建两个及以上)用-p符号作出了区分，同时考虑到了Linux中诸如mkdir -p a/../b 会创建a和b两个目录的情况，即<strong>路径并非提前处理好而是边创建边解析</strong>，代码按照 walk_path 仿写，<strong>利用了文件控制块中未使用过的 f_dir 记录父节点</strong>，极大简化了实现。<br>在此展示fs/fs.c的核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkdir</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="type">char</span> name[MAXNAMELEN];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">File</span> *dir, *file;  <span class="comment">//解决 /a/../b</span></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    path = <span class="built_in">skip_slash</span>(path);</span><br><span class="line">    file = &amp;super-&gt;s_root;</span><br><span class="line">    <span class="comment">//addFileName(file, &quot;/&quot;);</span></span><br><span class="line">    dir = <span class="number">0</span>;</span><br><span class="line">    name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*path!= <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        dir = file;</span><br><span class="line">        p = path;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(*path != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *path != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            path++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (path - p &gt;= MAXNAMELEN) &#123;</span><br><span class="line">            <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(name, p, path - p); <span class="comment">//path在后 p在前</span></span><br><span class="line">        name[path - p] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        path = <span class="built_in">skip_slash</span>(path);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">strcmp</span>(name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123; <span class="comment">//处理.. </span></span><br><span class="line">            dir = dir-&gt;f_dir;  <span class="comment">//指向他的父亲dir</span></span><br><span class="line">            p = path;</span><br><span class="line">            <span class="keyword">while</span>(*path != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *path != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">                path++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (path - p &gt;= MAXNAMELEN) &#123;</span><br><span class="line">                <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memcpy</span>(name, p, path - p);</span><br><span class="line">            name[path - p] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            path = <span class="built_in">skip_slash</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dir-&gt;f_type != FTYPE_DIR) &#123;</span><br><span class="line">            <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">        &#125;</span><br><span class="line">        r = <span class="built_in">dir_lookup</span>(dir, name, &amp;file);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span> &amp;&amp; *path == <span class="number">0</span> &amp;&amp; file-&gt;f_type == FTYPE_REG) &#123;</span><br><span class="line">            <span class="built_in">debugf</span>(<span class="string">&quot;target is a reg file!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span> &amp;&amp; *path == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">debugf</span>(<span class="string">&quot;dir already exist!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123; <span class="comment">//该创建了 还需要判断最后一层若存在是否为reg</span></span><br><span class="line">            <span class="keyword">if</span> (r == -E_NOT_FOUND) &#123;</span><br><span class="line">                <span class="keyword">if</span> (*path == <span class="number">0</span> || op == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">dir_alloc_file</span>(dir, &amp;file) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> r;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">strcpy</span>(file-&gt;f_name, name);</span><br><span class="line">                    <span class="comment">//file-&gt;f_dir = dir;</span></span><br><span class="line">                    file-&gt;f_type = FTYPE_DIR;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">debugf</span>(<span class="string">&quot;can&#x27;t find dir : %s!\n&quot;</span>, name);</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，mkdir若不使用 -p 命令则最多只能创建一个目录，多于一个目录会报错；而使用 -p 命令可以创建多级目录</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/C_6.jpg" alt></p><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p>touch是用来更新文件日期的指令(文件日期感觉也可以实现，奈何时间有限)，也可以用来创建文件。touch整体思路同mkdir，linux中并没有创建多级目录后再创建文件的 -p 选项，然而我们的YangOS总要有其与众不同之处，因此也支持了类似 mkdir 的 -p 选项。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">touch</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> op)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="type">char</span> name[MAXNAMELEN];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">File</span> *dir, *file;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    path = <span class="built_in">skip_slash</span>(path);</span><br><span class="line">    file = &amp;super-&gt;s_root;</span><br><span class="line">    dir = <span class="number">0</span>;</span><br><span class="line">    name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*path != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        dir = file;</span><br><span class="line">        p = path;</span><br><span class="line">        <span class="keyword">while</span> (*path != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *path != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            path++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (path - p &gt;= MAXNAMELEN) &#123;</span><br><span class="line">            <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memcpy</span>(name, p, path - p);</span><br><span class="line">        name[path - p] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        path = <span class="built_in">skip_slash</span>(path);</span><br><span class="line">        <span class="keyword">if</span> (dir-&gt;f_type != FTYPE_DIR) &#123;</span><br><span class="line">            <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">        &#125;</span><br><span class="line">        r = <span class="built_in">dir_lookup</span>(dir, name, &amp;file);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span> &amp;&amp; *path == <span class="number">0</span> &amp;&amp; file-&gt;f_type != FTYPE_REG) &#123; <span class="comment">//找到且最后一级 准确来说是路径有误</span></span><br><span class="line">            <span class="built_in">debugf</span>(<span class="string">&quot;path wrong can&#x27;t touch!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r == -E_NOT_FOUND) &#123;</span><br><span class="line">                <span class="keyword">if</span> (*path == <span class="number">0</span> || op == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">dir_alloc_file</span>(dir, &amp;file) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> r;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">strcpy</span>(file-&gt;f_name, name);</span><br><span class="line">                    <span class="keyword">if</span> (*path != <span class="number">0</span>) &#123;</span><br><span class="line">                        file-&gt;f_type = FTYPE_DIR;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        file-&gt;f_type = FTYPE_REG;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">debugf</span>(<span class="string">&quot;can&#x27;t find dir : %s!\n&quot;</span>, name);</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>课程组在头文件中给出了CREAT，MKDIR等文件打开方式，但笔者认为创建与打开无关，所以并未使用，不过大体思路无异，通过 ipc 与文件服务进程通信达到创建文件的目的。</p><p>演示如下：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/C_8.jpg" alt></p><h3 id="8-支持相对路径"><a href="#8-支持相对路径" class="headerlink" title="8. 支持相对路径"></a>8. 支持相对路径</h3><p>在进程控制块中维护当前工作目录，初始化为 \ ，并在创建子进程时令子进程继承该值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">env.h:</span><br><span class="line"><span class="type">char</span> env_workingpath[<span class="number">1024</span>];</span><br><span class="line">u_int env_shid;</span><br></pre></td></tr></table></figure><p>实现系统调用 syscall_changing_workingpath，顾名思义改变工作目录。</p><p><strong>提前声明</strong>：除了mkdir a/../b 这个特殊情况，其他所有涉及路径的指令均采用提前处理的方式，即 a/../b 会当成 b 处理。</p><p>由于实现了支持上级目录 .. 和 当前目录 . ，则路径转换需要分两步走，第一步将工作目录和输入的路径拼接，需要考虑拼接处和结尾处 / 的问题；第二步处理拼接后的序列中存在的 .. 以及 . 的情况，最后得到真正可被文件系统识别的路径，cd指令如此，其余涉及路径转化的指令亦是如此。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> truepath[<span class="number">1024</span>];</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">path_switch</span><span class="params">(<span class="type">char</span> *path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path[<span class="number">0</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memset</span>(truepath, <span class="number">0</span>, <span class="keyword">sizeof</span> truepath);</span><br><span class="line">        <span class="built_in">strcpy</span>(truepath, env-&gt;env_workingpath);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (truepath[<span class="built_in">strlen</span>(truepath) - <span class="number">1</span>] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            truepath[<span class="built_in">strlen</span>(truepath)] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(truepath + <span class="built_in">strlen</span>(truepath), path);</span><br><span class="line">        <span class="keyword">return</span> truepath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> finalpath[<span class="number">1024</span>];</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">parsepath</span><span class="params">(<span class="type">char</span> *path)</span> </span>&#123; <span class="comment">//path是组装好的路径</span></span><br><span class="line">    <span class="type">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(path); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path[i<span class="number">-1</span>] == <span class="string">&#x27;/&#x27;</span> &amp;&amp; path[i] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; ((path[i+<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; (path[i+<span class="number">2</span>] == <span class="string">&#x27;/&#x27;</span> || path[i+<span class="number">2</span>] == <span class="number">0</span>)) || (path[i+<span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span> || path[i+<span class="number">1</span>] == <span class="number">0</span>))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (path[i+<span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                p1 = p1 - <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (p1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">debugf</span>(<span class="string">&quot;root is first level!\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (; p1 &gt;= <span class="number">0</span>; p1--) &#123;</span><br><span class="line">                    <span class="comment">//debugf(&quot;p1 : %d\n&quot;, p1);</span></span><br><span class="line">                    <span class="keyword">if</span> (finalpath[p1] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (path[i+<span class="number">2</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    i = i + <span class="number">2</span>;</span><br><span class="line">                    p1++;</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// /a/../c</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path[i+<span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path[i+<span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                p1--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (path[i+<span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                i++; <span class="comment">// /a/./c p1指向.</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            finalpath[p1] = path[i];</span><br><span class="line">                p1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p1 != <span class="number">0</span>) &#123;</span><br><span class="line">        finalpath[p1] = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        finalpath[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> finalpath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cd 指令并不复杂，因此是一个内部指令，即不需要spawn出子进程专门处理，而是在原shell中执行。pwd 也是如此，直接输出进程控制块中工作目录的内容即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">chdir</span><span class="params">(<span class="type">char</span> *path)</span> </span>&#123;</span><br><span class="line">    path = <span class="built_in">parsepath</span>(<span class="built_in">path_switch</span>(path));</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Stat</span> st;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">stat</span>(path, &amp;st)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">debugf</span>(<span class="string">&quot;cd path wrong!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (st.st_isdir == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">debugf</span>(<span class="string">&quot;cd path is reg file!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> -E_NOT_FILE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">syscall_change_workingpath</span>(<span class="number">0</span>, path);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于在用户态获取到的内核态的信息，可读，但不可写(应当是硬件约束)，若想写则必须通过系统调用，同时 printf 不允许访问内核地址，两种解决办法，第一种将其在用户态复制一份，第二种把printf的地址检查注释掉(笑。</p><p>测试如下:</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/C_10.jpg" alt></p><h3 id="9-支持环境变量"><a href="#9-支持环境变量" class="headerlink" title="9. 支持环境变量"></a>9. 支持环境变量</h3><p>declare 可声明的变量包括局部变量(对当前shell可见)以及环境变量(对子shell可见)，对于环境变量笔者实现的是全局可见，应当是有所瑕疵。</p><p>为区分局部变量和环境变量，在进程控制块中新增了shid，来区分不同的shell，每当创建新shell时为其赋予不同的id，而当创建其他子进程时继承原shid。在内核态开全局结构体 Environment 来存储所有变量，shid为0时代表环境变量，否则为对应shell的局部变量。在系统调用中实现了 sys_set_env_var 和 sys_get_env_var 实现变量的装载与获取。</p><p><strong>env.h</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u_int env_shid;</span><br></pre></td></tr></table></figure><p><strong>syscall_all.c</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Environment</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">128</span>];</span><br><span class="line">    <span class="type">char</span> value[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> shid; <span class="comment">//0 global; other local</span></span><br><span class="line">    <span class="type">char</span> isread; <span class="comment">//0 rdwr; 1 rdonly</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sys_set_env_var</span><span class="params">(u_int envid, <span class="type">int</span> op, <span class="type">char</span> *name, <span class="type">char</span> *value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Env</span> *env;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">envid2env</span>(envid, &amp;env, <span class="number">1</span>) == -E_BAD_ENV) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> shid = env-&gt;env_shid;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Environment</span> *envir;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXVAR; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (environ[i].name[<span class="number">0</span>] != <span class="number">0</span> &amp;&amp; (environ[i].shid == <span class="number">0</span> || environ[i].shid == shid)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (environ[i].shid == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printk</span>(<span class="string">&quot;GLOBAL NAME : %s, VALUE : %s\n&quot;</span>, environ[i].name, environ[i].value);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (environ[i].shid == shid) &#123;</span><br><span class="line">                    <span class="built_in">printk</span>(<span class="string">&quot;LOCAL NAME : %s, VALUE : %s\n&quot;</span>, environ[i].name, environ[i].value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">1</span> || op == <span class="number">2</span> || op == <span class="number">3</span> || op == <span class="number">4</span>) &#123; <span class="comment">//global rdly</span></span><br><span class="line">        <span class="keyword">if</span> ((envir = <span class="built_in">isexist</span>(name, shid)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (envir-&gt;isread == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">printk</span>(<span class="string">&quot;readonly can&#x27;t change!\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//更改</span></span><br><span class="line">                <span class="built_in">strcpy</span>(envir-&gt;value, value);</span><br><span class="line">                <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">                    envir-&gt;isread = <span class="number">1</span>;</span><br><span class="line">                    envir-&gt;shid = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">                    envir-&gt;isread = <span class="number">0</span>;</span><br><span class="line">                    envir-&gt;shid = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">                    envir-&gt;isread = <span class="number">1</span>;</span><br><span class="line">                    envir-&gt;shid = shid;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) &#123;</span><br><span class="line">                    envir-&gt;isread = <span class="number">0</span>;</span><br><span class="line">                    envir-&gt;shid = shid;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">set_envir</span>(<span class="number">1</span>, <span class="number">0</span>, name, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="built_in">set_envir</span>(<span class="number">0</span>, <span class="number">0</span>, name, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="built_in">set_envir</span>(<span class="number">1</span>, shid, name, value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="built_in">set_envir</span>(<span class="number">0</span>, shid, name, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">5</span>) &#123; <span class="comment">//clear</span></span><br><span class="line">        <span class="keyword">struct</span> Environment *envir = <span class="built_in">isexist</span>(name, shid);</span><br><span class="line">        <span class="keyword">if</span> (envir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;name no exist!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (envir-&gt;isread == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printk</span>(<span class="string">&quot;can&#x27;t change readonly!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            envir-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> * <span class="title">sys_get_env_var</span><span class="params">(u_int envid, <span class="type">char</span> *name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Env</span> *env;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">envid2env</span>(envid, &amp;env, <span class="number">1</span>) == -E_BAD_ENV) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> shid = env-&gt;env_shid;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Environment</span> *envir = <span class="built_in">isexist</span>(name, shid);</span><br><span class="line">    <span class="keyword">if</span> (envir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> envir-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>set 函数根据不同选项分为六种操作(将unset也融合在内)，包括<strong>全局只读，全局可写，局部只读，局部可写，解除变量，输出变量信息</strong>。需要重点注意对于可读变量的操作的限制，不可解除，不可重写，当错误发生时应输出相应信息告知用户。</p><p>支持通过 $ 获取环境变量，在解析完一行命令后，需要遍历一遍 argv，若以 $ 开头则尝试获取环境变量值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (argv[i][<span class="number">0</span>] == <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line"><span class="type">char</span> *tmp = <span class="built_in">syscall_get_env_var</span>(<span class="number">0</span>, argv[i] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">debugf</span>(<span class="string">&quot;can&#x27;t parse env var!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(argv[i], tmp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试如图，首先在启动的shell里进行测试：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/C_11.jpg" alt></p><p>接着启动子shell进行验证，中间的空行是按了 ctrl+d 终止了子shell回到原始shell：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/C_12.jpg" alt></p><h3 id="10-额外指令"><a href="#10-额外指令" class="headerlink" title="10. 额外指令"></a>10. 额外指令</h3><p>笔者自行添加了四个最常用的指令，分别为rm，rmdir，cp，mv ，各有千秋。</p><p>首先是一组相似的删除指令 <strong>rm</strong> 和 <strong>rmdir</strong>：</p><ul><li>rm：删除文件； -r 递归删除目录及下级所有文件；文件若不为空则需要再次确认是否删除；-f 无需确认</li><li>rmdir：删除空目录；-p 依次删除路径中所有空目录，例如 rmdir -p a/b/c，先判断 c 是否为空，若空则删除，再判断 b 是否为空，若空则删除，如此判断到指令开始的路径 a。</li></ul><p>代码中已有对文件删除相关的函数，彷佛就是为额外新增指令准备的，的确适用于普通的删除操作，然而当涉及判断目录是否为空时存在漏洞。通过阅读代码我们可知，一个文件被删除，将该文件大小 ftruncate 为0，该收回的磁盘块收回，并将该文件控制块的 name 置0，然而该文件控制块并非真正被回收，这导致其父目录的文件大小不能很好的同步(值得一提的是，文件的大小是随字节数的变化而变化，而目录的大小永远都是磁盘块大小的整倍数)。即使由于这次的 remove 导致父目录空了，他的size仍然不为0，因此在remove的时候 f_size 便不可信，需要手动遍历该目录的进程控制块，若 name 都为0，则目录才是真的<strong>空</strong>了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">syn_dir_size</span><span class="params">(<span class="keyword">struct</span> File *dir)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    u_int nblock;</span><br><span class="line">    nblock = dir-&gt;f_size / BY2BLK;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nblock; i++) &#123;</span><br><span class="line">        <span class="type">void</span> *blk;</span><br><span class="line">        <span class="keyword">if</span> ((r = <span class="built_in">file_get_block</span>(dir, i, &amp;blk)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">File</span> *files = (<span class="keyword">struct</span> File *)blk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">struct</span> File *f = files; f &lt; files + FILE2BLK; ++f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f-&gt;f_name[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">file_remove</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> force, <span class="type">int</span> rec, <span class="type">int</span> dir)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">File</span> *f;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1: find the file on the disk.</span></span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">walk_path</span>(path, <span class="number">0</span>, &amp;f, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;f_type == FTYPE_DIR &amp;&amp; rec == <span class="number">0</span> &amp;&amp; dir == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">debugf</span>(<span class="string">&quot;dir can&#x27;t remove!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="number">1</span> &amp;&amp; f-&gt;f_type == FTYPE_REG) &#123;</span><br><span class="line">        <span class="built_in">debugf</span>(<span class="string">&quot;rmdir can&#x27;t rm file!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="number">1</span> &amp;&amp; f-&gt;f_type == FTYPE_DIR &amp;&amp; <span class="built_in">syn_dir_size</span>(f) == <span class="number">0</span>) &#123; <span class="comment">//0 size &gt;0; 1 size = 0</span></span><br><span class="line">        <span class="built_in">debugf</span>(<span class="string">&quot;rmdir can&#x27;t rm no empty dir!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (((f-&gt;f_type == FTYPE_REG &amp;&amp; f-&gt;f_size != <span class="number">0</span>) || (f-&gt;f_type == FTYPE_DIR &amp;&amp; <span class="built_in">syn_dir_size</span>(f) == <span class="number">0</span>)) &amp;&amp; force == <span class="number">0</span> &amp;&amp; dir == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">debugf</span>(<span class="string">&quot;you will delate %s, y or n? &quot;</span>, path);</span><br><span class="line">            <span class="type">int</span> c1, c2;</span><br><span class="line">            c1 = <span class="built_in">syscall_cgetc</span>();</span><br><span class="line">            <span class="built_in">debugf</span>(<span class="string">&quot;%c&quot;</span>, c1);</span><br><span class="line">            c2 = <span class="built_in">syscall_cgetc</span>();</span><br><span class="line">            <span class="built_in">debugf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> ((c1 == <span class="string">&#x27;y&#x27;</span> || c1 == <span class="string">&#x27;Y&#x27;</span>) &amp;&amp; c2 == <span class="number">13</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((c1 == <span class="string">&#x27;n&#x27;</span> || c1 == <span class="string">&#x27;N&#x27;</span>) &amp;&amp; c2 == <span class="number">13</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">debugf</span>(<span class="string">&quot; think more!\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Step 2: truncate it&#x27;s size to zero.</span></span><br><span class="line">    <span class="built_in">file_truncate</span>(f, <span class="number">0</span>); <span class="comment">//只是把当前文件的内容清空 若上层父目录由于此次删除导致文件夹目录也为空 则并没有对父目录进行减小文件大小操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 3: clear it&#x27;s name.</span></span><br><span class="line">    f-&gt;f_name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 4: flush the file.</span></span><br><span class="line">    <span class="built_in">file_flush</span>(f);</span><br><span class="line">    <span class="keyword">if</span> (f-&gt;f_dir) &#123;</span><br><span class="line">        <span class="built_in">file_flush</span>(f-&gt;f_dir);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">free_block新增：</span><br><span class="line"><span class="built_in">memset</span>((<span class="type">void</span> *)<span class="built_in">diskaddr</span>(blockno), <span class="number">0</span>, BY2PG);</span><br><span class="line"><span class="built_in">write_block</span>(blockno);</span><br></pre></td></tr></table></figure><p>验证如下：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/C_13.jpg" alt></p><p>接下来又是一组颇为相似的 <strong>cp</strong>，<strong>mv</strong> 指令，可能出现的情况总结如下。</p><ul><li>文件 ➡ 存在的文件：改写文件名</li><li>文件 ➡ 存在的目录：将文件置于该目录下</li><li>文件 ➡ 不存在的路径：合法情况下，默认touch文件并改写文件名</li><li>目录 ➡ 不存在的路径：合法情况下，默认mkdir目录并改写目录名</li><li>目录 ➡ 存在的目录：将左目录置于在右目录下</li><li>目录 ➡ 存在的文件：非法</li><li>不存在的路径 ➡ 任何路径：非法</li></ul><p>cp 若复制目录需使用 -r 选项，mv 则不需要。</p><p>cp 指令涉及到深克隆，即要完成对目录的递归拷贝，在深克隆时应注意目录与文件的区别以及进程控制块中变与不变的地方。</p><p>mv 实现并不难，完成对文件控制块的<strong>偷天换日</strong>即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">copy_deep</span><span class="params">(<span class="keyword">struct</span> File *file, <span class="keyword">struct</span> File *targetf)</span> </span>&#123; <span class="comment">//dir都是整倍数 reg未必整倍数</span></span><br><span class="line">    <span class="type">int</span> nblock = targetf-&gt;f_size / BY2BLK;</span><br><span class="line">    <span class="keyword">if</span> (targetf-&gt;f_size % BY2BLK != <span class="number">0</span>) &#123;</span><br><span class="line">        nblock++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(file-&gt;f_name, targetf-&gt;f_name);</span><br><span class="line">    file-&gt;f_size = targetf-&gt;f_size;</span><br><span class="line">    file-&gt;f_type = targetf-&gt;f_type;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">void</span> *blk, *blk1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nblock; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = <span class="built_in">file_get_block</span>(targetf, i, &amp;blk)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">debugf</span>(<span class="string">&quot;can&#x27;t get targetf!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r = <span class="built_in">file_get_block</span>(file, i, &amp;blk1)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">debugf</span>(<span class="string">&quot;can&#x27;t get file!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (targetf-&gt;f_type == FTYPE_REG) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(blk1, blk, BY2PG);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetf-&gt;f_type == FTYPE_DIR) &#123;</span><br><span class="line">            <span class="keyword">struct</span> File *files = (<span class="keyword">struct</span> File *)blk;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">struct</span> File *f = files; f &lt; files + FILE2BLK; ++f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f-&gt;f_name[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">struct</span> <span class="title class_">File</span> *newfile;</span><br><span class="line">                    <span class="built_in">dir_alloc_file</span>(file, &amp;newfile); <span class="comment">//父子绑定</span></span><br><span class="line">                    <span class="built_in">copy_deep</span>(newfile, f);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">copy</span><span class="params">(<span class="type">char</span> *name, <span class="type">char</span> *path, <span class="type">int</span> n)</span> </span>&#123; <span class="comment">//前提 必须都已经存在 复制根目录？</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">File</span> *target2, *file, *targetf, *tmp;</span><br><span class="line">    <span class="built_in">walk_path</span>(path, <span class="number">0</span>, &amp;target2, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">walk_path</span>(name, <span class="number">0</span>, &amp;targetf, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((target2-&gt;f_type == FTYPE_REG &amp;&amp; targetf-&gt;f_type == FTYPE_REG) || (target2-&gt;f_type == FTYPE_DIR &amp;&amp; targetf-&gt;f_type == FTYPE_DIR &amp;&amp; n == <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="type">char</span> tmp[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(tmp, target2-&gt;f_name);</span><br><span class="line">        <span class="built_in">copy_deep</span>(target2, targetf);</span><br><span class="line">        <span class="built_in">strcpy</span>(target2-&gt;f_name, tmp);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> r = <span class="built_in">dir_lookup</span>(target2, targetf-&gt;f_name, &amp;tmp); <span class="comment">//先查看目标目录下有无同名文件</span></span><br><span class="line">    <span class="keyword">if</span> (r != -E_NOT_FOUND) &#123;</span><br><span class="line">        <span class="built_in">debugf</span>(<span class="string">&quot;%s has same name file %s!\n&quot;</span>, path, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dir_alloc_file</span>(target2, &amp;file);</span><br><span class="line">    <span class="built_in">copy_deep</span>(file, targetf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">move</span><span class="params">(<span class="type">char</span> *name, <span class="type">char</span> *path, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">File</span> *target2, *targetf, *file, *tmp;</span><br><span class="line">    <span class="built_in">walk_path</span>(path, <span class="number">0</span>, &amp;target2, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">walk_path</span>(name, <span class="number">0</span>, &amp;targetf, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((target2-&gt;f_type == FTYPE_REG &amp;&amp; targetf-&gt;f_type == FTYPE_REG) || (target2-&gt;f_type == FTYPE_DIR &amp;&amp; targetf-&gt;f_type == FTYPE_DIR &amp;&amp; n == <span class="number">1</span>)) &#123;</span><br><span class="line">        target2-&gt;f_size = targetf-&gt;f_size;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NDIRECT; i++) &#123;</span><br><span class="line">            target2-&gt;f_direct[i] = targetf-&gt;f_direct[i];</span><br><span class="line">        &#125;</span><br><span class="line">        target2-&gt;f_indirect = targetf-&gt;f_indirect;</span><br><span class="line">        targetf-&gt;f_name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> r = <span class="built_in">dir_lookup</span>(target2, targetf-&gt;f_name, &amp;tmp);</span><br><span class="line">    <span class="keyword">if</span> (r != -E_NOT_FOUND) &#123;</span><br><span class="line">        <span class="built_in">debugf</span>(<span class="string">&quot;%s has same name file %s!\n&quot;</span>, path, name);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dir_alloc_file</span>(target2, &amp;file);</span><br><span class="line">    <span class="built_in">memcpy</span>(file, targetf, BY2FILE);</span><br><span class="line">    file-&gt;f_dir = target2;</span><br><span class="line">    targetf-&gt;f_name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mv验证：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/C_14.jpg" alt></p><p>cp验证：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/C_15.jpg" alt></p><p>原有代码的 remove 实现存在些许问题(也许是没有打算令大家实现 remove 操作，总之无论如何，在 remove 后应当对磁盘中相关内容进行同步，同时在释放缓存块时，若不解除映射的话，应该要将页清空。</p><h3 id="11-命令自动补全"><a href="#11-命令自动补全" class="headerlink" title="11. 命令自动补全"></a>11. 命令自动补全</h3><p>使用tab键进行代码补全，添加的比较仓促，可以支持命令的补全和路径的补全，但只限于存在唯一解的情况，倘若前缀有多个匹配项则无能为力，但可以支持将所有匹配项打印出来用于提醒(连按两下 tab)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> cmd[<span class="number">1024</span>][<span class="number">16</span>] = &#123;<span class="string">&quot;cd&quot;</span>, <span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;mv&quot;</span>, <span class="string">&quot;cp&quot;</span>, <span class="string">&quot;rm&quot;</span>, <span class="string">&quot;rmdir&quot;</span>, <span class="string">&quot;touch&quot;</span>, <span class="string">&quot;mkdir&quot;</span>, <span class="string">&quot;tree&quot;</span>, <span class="string">&quot;declare&quot;</span>, <span class="string">&quot;unset&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;echo&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;ls&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> cmd_cnt = <span class="number">15</span>;</span><br><span class="line"><span class="type">char</span> level[<span class="number">1024</span>][<span class="number">64</span>];</span><br><span class="line"><span class="type">char</span> may[<span class="number">1024</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> may_cnt;</span><br><span class="line"><span class="type">int</span> level_cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search_maybe_string</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//n = 0 代表搜cmd和Level，n = 1代表前面有/ 只搜索level</span></span><br><span class="line">    may_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(s) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> tmp1[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; level_cnt; j++) &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(tmp1, level[j]);</span><br><span class="line">        tmp1[<span class="built_in">strlen</span>(s)] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(tmp1, s) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">strcpy</span>(may[may_cnt], level[j]);</span><br><span class="line">            may_cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">15</span>; j++) &#123;</span><br><span class="line">            <span class="comment">//debugf(&quot;cmd[j] %s\n&quot;, cmd[j]);</span></span><br><span class="line">            <span class="built_in">strcpy</span>(tmp1, cmd[j]);</span><br><span class="line">            tmp1[<span class="built_in">strlen</span>(s)] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(tmp1, s) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">strcpy</span>(may[may_cnt], cmd[j]);</span><br><span class="line">                may_cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_level</span><span class="params">(<span class="type">char</span> *path)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fd, r, n;</span><br><span class="line">    level_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Stat</span> st;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">File</span> f;</span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">stat</span>(path, &amp;st)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!st.st_isdir) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fd = <span class="built_in">open</span>(path, O_RDONLY);</span><br><span class="line">        <span class="keyword">while</span> ((n = <span class="built_in">readn</span>(fd, &amp;f, <span class="keyword">sizeof</span> f)) == <span class="keyword">sizeof</span> f) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.f_name[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="built_in">strcpy</span>(level[level_cnt], f.f_name);</span><br><span class="line">                level_cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当识别到 TAB 时，仍然是一通对字符串的操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (buf[i] == <span class="number">9</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">debugf</span>(<span class="string">&quot;\nyou maybe want: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; may_cnt; j++) &#123;</span><br><span class="line">            <span class="built_in">debugf</span>(<span class="string">&quot;%s &quot;</span>, may[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">debugf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        buf1[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//封0</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> search_path[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">char</span> lack_str[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">char</span> para1[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> tmp1 = pointer, firstcut = pointer;</span><br><span class="line">    <span class="type">int</span> i1;</span><br><span class="line">    <span class="type">int</span> mode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; buf1[firstcut] != <span class="string">&#x27; &#x27;</span> &amp;&amp; buf1[firstcut] != <span class="string">&#x27;/&#x27;</span> &amp;&amp; firstcut &gt;= <span class="number">0</span>; firstcut--) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (buf1[firstcut] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        mode = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    firstcut++;</span><br><span class="line">    <span class="keyword">for</span> (; buf1[tmp1] != <span class="string">&#x27; &#x27;</span> &amp;&amp; tmp1 &gt;= <span class="number">0</span>; tmp1--) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i1 = <span class="number">0</span>, tmp1 = tmp1 + <span class="number">1</span>; tmp1 &lt; pointer; tmp1++, i1++) &#123;</span><br><span class="line">        para1[i1] = buf1[tmp1];</span><br><span class="line">    &#125; </span><br><span class="line">    para1[i1] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *t = <span class="built_in">parsepath</span>(<span class="built_in">path_switch</span>(para1)); <span class="comment">// /yang/b</span></span><br><span class="line">    <span class="keyword">for</span> (i1 = <span class="built_in">strlen</span>(t); t[i1] != <span class="string">&#x27;/&#x27;</span>; i1--) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(lack_str, t + i1 + <span class="number">1</span>);</span><br><span class="line">    t[i1] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(search_path, t);</span><br><span class="line">    <span class="keyword">if</span> (search_path[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        search_path[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        search_path[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">get_level</span>(search_path);</span><br><span class="line">    <span class="built_in">search_maybe_string</span>(lack_str, mode);</span><br><span class="line">    <span class="keyword">for</span> (i1 = <span class="number">0</span>; i1 &lt; may_cnt; i1++) &#123;</span><br><span class="line">        <span class="comment">//debugf(&quot;%s\n&quot;, may[i1]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (may_cnt == <span class="number">1</span>) &#123; <span class="comment">//有唯一解</span></span><br><span class="line">        <span class="type">int</span> diff = <span class="built_in">strlen</span>(may[<span class="number">0</span>]) - <span class="built_in">strlen</span>(lack_str);</span><br><span class="line">        <span class="type">char</span> tmp[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(tmp, buf1 + pointer);</span><br><span class="line">        <span class="built_in">strcpy</span>(buf1 + firstcut, may[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">strcpy</span>(buf1 + firstcut + <span class="built_in">strlen</span>(may[<span class="number">0</span>]), tmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = firstcut; k &lt; pointer; k++) &#123;</span><br><span class="line">            <span class="built_in">debugf</span>(<span class="string">&quot;\b&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="built_in">strlen</span>(may[<span class="number">0</span>]); k++) &#123;</span><br><span class="line">            <span class="built_in">debugf</span>(<span class="string">&quot;%c&quot;</span>, may[<span class="number">0</span>][k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="built_in">strlen</span>(tmp); k++) &#123;</span><br><span class="line">            <span class="built_in">debugf</span>(<span class="string">&quot;%c&quot;</span>, tmp[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="built_in">strlen</span>(tmp); k++) &#123;</span><br><span class="line">            <span class="built_in">debugf</span>(<span class="string">&quot;\b&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pointer = pointer + diff;</span><br><span class="line">        max = max + diff;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-实验难点"><a href="#三-实验难点" class="headerlink" title="三. 实验难点"></a>三. 实验难点</h2><p>本任务的验证无需一段C代码，而是通过人机交互验证，做起来较为方便且直观。</p><p>可以通过代码看出，笔者在实现指令基本功能之外，还在两个方面额外做出了大量工作，第一是指令执行异常时提醒，针对不同的错误情况会输出不同的信息进行提醒，以mkdir为例，当指定路径是一个普通文件时，会提醒 “target is a reg file!”，当没有使用 -p 还企图创建多级目录时，会提醒 “can’t find dir : %s!”；第二便是指令子选项 [-x] 的实现，比如 rm 的 -rf，mkdir，touch 的 -p 等。用户可根据实际需要自由选择想要使用的功能，若错误使用也会出现相应的错误信息进行提醒，十分人性化。</p><p>笔者认为 LAB6-challenge 核心挑战点在于<strong>对于字符串的操作与理解</strong>，<strong>对于文件系统与磁盘的各功能的理解与组合</strong>，<strong>对C语言底层逻辑诸如指针和内存间联系的理解</strong>，以及<strong>由于人工输入导致的输入多样性，涉及到的多种情况的处理</strong>，像是oo的第三单元异常处理一样（比如输入路径时结尾带不带/，路径能否被找到，若指令执行出错则是由于哪种错误等等）。shell 重点是人机交互，因此在保证正确性的前提下保证用户的体验是至关重要的，对于既是开发者又是用户的我来说，体感良好。</p><p>对于指令的添加，重点难点在于理解 fs.c 中写好的函数，比如 dir_lookup，file_block_walk，file_get_block 等，静下心来去思考每个函数的用途，只要将这些核心函数拼装再进行小小改造，即可实现绝大部分的功能。</p><p>笔者一直对于 mos 模拟的磁盘抱有疑问，磁盘在退出后为何不能保留 shell 交互时对磁盘文件的改变。现在的理解是，模拟磁盘终究只是模拟，在上电交互时会保持同步，然而退出后下次会重新初始化磁盘，一开始装载的文件存放在 fs/Makefile 中，可通过修改 Makefile 来调整装载进磁盘的文件。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">fs/Makefile:</span></span><br><span class="line">FSIMGFILES := rootfs/motd rootfs/newmotd <span class="variable">$(USERAPPS)</span> $(fs-files)</span><br></pre></td></tr></table></figure><h2 id="四-最终总结"><a href="#四-最终总结" class="headerlink" title="四. 最终总结"></a>四. 最终总结</h2><p>随着挑战性任务的结束，北航操作系统课程终将迎来尾声，在这一学期中，从学习Linux，到启动 mos 操作系统，再到内存管理，进程管理，系统调用，文件系统，shell，基于以往的LAB层层递进，课程设计合理(不愧是计院老三样)，在这一步一个脚印的学习中笔者收获到大量的OS知识，以及对C语言狠狠的查缺补漏了一番。后面的LAB往往要用到前面LAB的内容，有时候你正在写的这部分内容不知道有什么用处，然而等到了下次下下次，当上下文产生联系时你便会豁然开朗，尤其是选择LAB6挑战性任务的笔者更加有体会，在实现 shell 的功能时，要与进程控制块打交道，要与系统调用与进程间通信打交道，更多的要与文件系统打交道，这令我更加理解了由低至高的OS层次架构。</p><p>本次实验共用时30h+，在你6并不算繁忙的期末周里，有着足够的时间去静下心去钻研去思考，经常一写一debug就忘记了时间。至于为何选择LAB6挑战性任务，一方面是因为刚刚写完LAB6，认为对其印象更为深刻，另一方面则是认为LAB6的实验效果更为直观，且可以阶段性进行测试，频繁激发自己的成就感，也正是这种成就感会成为我继续完成更多额外工作的动力。诚然，本实验不像其余实验过多的接触内核，实现一套新的算法机制，这一点比较可惜，如果有时间的话很想把每个挑战性任务都完成一遍，但无论如何，笔者在LAB6挑战性任务中耗费了大量的心血，甚至一度找到了当年几个日夜写 P8 的感觉，痛并快乐着的时光总是弥足珍贵。</p><p>最后再次感谢一学期以来在OS理论与实验上帮助过我的老师，助教，伙伴们，感谢你们的倾囊相授，也感谢自己坚持到了最后，若如有机会，我也愿意把自己的所学传递给更多的人。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『操作系统』操作系统实验LAB6——管道与Shell</title>
      <link href="/post/4f174a3f.html"/>
      <url>/post/4f174a3f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『操作系统』操作系统实验LAB6——管道与Shell"><a href="#『操作系统』操作系统实验LAB6——管道与Shell" class="headerlink" title="『操作系统』操作系统实验LAB6——管道与Shell"></a>『操作系统』操作系统实验LAB6——管道与Shell</h1><h2 id="一-思考题"><a href="#一-思考题" class="headerlink" title="一. 思考题"></a>一. 思考题</h2><h4 id="Question1-示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想让父进程作为“读者”，代码应当如何修改？"><a href="#Question1-示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想让父进程作为“读者”，代码应当如何修改？" class="headerlink" title="Question1. 示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想让父进程作为“读者”，代码应当如何修改？"></a>Question1. 示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想让父进程作为“读者”，代码应当如何修改？</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程 - 作为管道的写者 */</span></span><br><span class="line"><span class="built_in">close</span>(fildes[<span class="number">0</span>]); <span class="comment">/* 关闭不用的读端 */</span></span><br><span class="line"><span class="built_in">write</span>(fildes[<span class="number">1</span>], <span class="string">&quot;Hello world\n&quot;</span>, <span class="number">12</span>); <span class="comment">/* 向管道中写数据 */</span></span><br><span class="line"><span class="built_in">close</span>(fildes[<span class="number">1</span>]); <span class="comment">/* 写入结束，关闭写端 */</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">/* 父进程 - 作为管道的读者 */</span></span><br><span class="line"><span class="built_in">close</span>(fildes[<span class="number">1</span>]); <span class="comment">/* 关闭不用的写端 */</span></span><br><span class="line"><span class="built_in">read</span>(fildes[<span class="number">0</span>], buf, <span class="number">100</span>); <span class="comment">/* 从管道中读数据 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child-process read:%s&quot;</span>,buf); <span class="comment">/* 打印读到的数据 */</span></span><br><span class="line"><span class="built_in">close</span>(fildes[<span class="number">0</span>]); <span class="comment">/* 读取结束，关闭读端 */</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br></pre></td></tr></table></figure><p>颠倒一下父子进程操作即可。</p><h4 id="Question2-上面这种不同步修改-pp-ref-而导致的进程竞争问题在-user-lib-fd-c-中的-dup-函数中也存在。请结合代码模仿上述情景，分析一下我们的-dup-函数中为什么会出现预想之外的情况？"><a href="#Question2-上面这种不同步修改-pp-ref-而导致的进程竞争问题在-user-lib-fd-c-中的-dup-函数中也存在。请结合代码模仿上述情景，分析一下我们的-dup-函数中为什么会出现预想之外的情况？" class="headerlink" title="Question2. 上面这种不同步修改 pp_ref 而导致的进程竞争问题在 user/lib/fd.c 中的 dup 函数中也存在。请结合代码模仿上述情景，分析一下我们的 dup 函数中为什么会出现预想之外的情况？"></a>Question2. 上面这种不同步修改 pp_ref 而导致的进程竞争问题在 user/lib/fd.c 中的 dup 函数中也存在。请结合代码模仿上述情景，分析一下我们的 dup 函数中为什么会出现预想之外的情况？</h4><p>dup函数的用途是复制文件，包括复制文件控制块和文件内容两个步骤，即会令原文件控制块和文件次数的物理页面引用次数加一，算是指导书提到的close的逆操作，自然顺序值得考究。原代码中，先完成控制块的映射再完成内容的映射。</p><p>考虑如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子进程</span></span><br><span class="line"><span class="built_in">close</span>(p[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">read</span>(p[<span class="number">0</span>], buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">close</span>(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程    </span></span><br><span class="line"><span class="built_in">dup</span>(p[<span class="number">0</span>], newfd);</span><br><span class="line"><span class="built_in">close</span>(p[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">write</span>(p[<span class="number">1</span>], <span class="string">&quot;Hello&quot;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">close</span>(p[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>fork结束后，父进程先运行，在 dup 中，已经完成了p[0]的映射，还没完成pipe的映射，这时发生了中断。</p><p>切换到子进程运行，进入 read 函数时，发现 <code>ref(p[0]) == ref(pipe) == 3</code> ( <code>p[0]</code> 由于 dup 了一次且父进程还没<code>close(p[0])</code>，因此是3；而pipe由于子进程<code>close(p[1])</code>减了1，因此也是3)，满足退出条件，子进程退出，造成错误。</p><h4 id="Question3-阅读上述材料并思考：为什么系统调用一定是原子操作呢？如果你觉得不是所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析说明。"><a href="#Question3-阅读上述材料并思考：为什么系统调用一定是原子操作呢？如果你觉得不是所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析说明。" class="headerlink" title="Question3. 阅读上述材料并思考：为什么系统调用一定是原子操作呢？如果你觉得不是所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析说明。"></a>Question3. 阅读上述材料并思考：为什么系统调用一定是原子操作呢？如果你觉得不是所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析说明。</h4><p>原子操作即在内核状态完成，操作时不会被时钟中断打断而切换进程的操作，所有系统调用都是原子操作，因为在进入内核时便关闭了全局中断，这部分是由CPU硬件完成的，可参见计组P7。系统调用是原子操作一方面是为了不可打断性，另一方面是为了保护操作系统，避免最底层的函数暴露在用户态下。</p><h4 id="Question4-仔细阅读上面这段话，并思考下列问题"><a href="#Question4-仔细阅读上面这段话，并思考下列问题" class="headerlink" title="Question4. 仔细阅读上面这段话，并思考下列问题"></a>Question4. 仔细阅读上面这段话，并思考下列问题</h4><h4 id="1-按照上述说法控制-pipe-close-中-fd-和-pipe-unmap-的顺序，是否可以解决上述场景的进程竞争问题？给出你的分析过程。"><a href="#1-按照上述说法控制-pipe-close-中-fd-和-pipe-unmap-的顺序，是否可以解决上述场景的进程竞争问题？给出你的分析过程。" class="headerlink" title="(1) 按照上述说法控制 pipe_close 中 fd 和 pipe unmap 的顺序，是否可以解决上述场景的进程竞争问题？给出你的分析过程。"></a>(1) 按照上述说法控制 pipe_close 中 fd 和 pipe unmap 的顺序，是否可以解决上述场景的进程竞争问题？给出你的分析过程。</h4><h4 id="2-我们只分析了-close-时的情形，在-fd-c-中有一个-dup-函数，用于复制文件描述符。试想，如果要复制的文件描述符指向一个管道，那么是否会出现与-close-类似的问题？请模仿上述材料写写你的理解。"><a href="#2-我们只分析了-close-时的情形，在-fd-c-中有一个-dup-函数，用于复制文件描述符。试想，如果要复制的文件描述符指向一个管道，那么是否会出现与-close-类似的问题？请模仿上述材料写写你的理解。" class="headerlink" title="(2) 我们只分析了 close 时的情形，在 fd.c 中有一个 dup 函数，用于复制文件描述符。试想，如果要复制的文件描述符指向一个管道，那么是否会出现与 close 类似的问题？请模仿上述材料写写你的理解。"></a>(2) 我们只分析了 close 时的情形，在 fd.c 中有一个 dup 函数，用于复制文件描述符。试想，如果要复制的文件描述符指向一个管道，那么是否会出现与 close 类似的问题？请模仿上述材料写写你的理解。</h4><p>可以解决，由于在不该退出的条件下<code>ref(pipe)</code>恒大于<code>ref(fd)</code>，因此先解除fd的映射令<code>ref(fd)--</code>，再解除pipe的映射令<code>ref(pipe)--</code>，<strong>小者更小</strong>，仍然满足 <code>ref(pipe) &gt; ref(fd)</code>。</p><p>dup 应使用同样的解决方法，先复制文件内容令<code>ref(pipe)++</code>，再复制文件控制块令<code>ref(fd)++</code>，<strong>大者更大</strong>，仍然满足 <code>ref(pipe) &gt; ref(fd)</code>，如此便不会造成错判。</p><h4 id="Question5-思考以下三个问题。"><a href="#Question5-思考以下三个问题。" class="headerlink" title="Question5. 思考以下三个问题。"></a>Question5. 思考以下三个问题。</h4><h4 id="1-认真回看-Lab5-文件系统相关代码，弄清打开文件的过程。"><a href="#1-认真回看-Lab5-文件系统相关代码，弄清打开文件的过程。" class="headerlink" title="(1) 认真回看 Lab5 文件系统相关代码，弄清打开文件的过程。"></a>(1) 认真回看 Lab5 文件系统相关代码，弄清打开文件的过程。</h4><h4 id="2-回顾-Lab1-与-Lab3，思考如何读取并加载-ELF-文件。"><a href="#2-回顾-Lab1-与-Lab3，思考如何读取并加载-ELF-文件。" class="headerlink" title="(2) 回顾 Lab1 与 Lab3，思考如何读取并加载 ELF 文件。"></a>(2) 回顾 Lab1 与 Lab3，思考如何读取并加载 ELF 文件。</h4><h4 id="3-在-Lab1-中我们介绍了-data-text-bss-段及它们的含义，data-段存放初始化过的全局变量，bss-段存放未初始化的全局变量。关于-memsize-和-filesize-，我们在-Note-1-3-4中也解释了它们的含义与特点。关于-Note-1-3-4，注意其中关于“bss-段并不在文件中占数据”表述的含义。回顾-Lab3-并思考：elf-load-seg-和-load-icode-mapper-函数是如何确保加载ELF文件时，bss-段数据被正确加载进虚拟内存空间。bss-段在-ELF-中并不占空间，但-ELF-加载进内存后，bss-段的数据占据了空间，并且初始值都是-0。请回顾-elf-load-seg-和-load-icode-mapper-的实现，思考这一点是如何实现的？"><a href="#3-在-Lab1-中我们介绍了-data-text-bss-段及它们的含义，data-段存放初始化过的全局变量，bss-段存放未初始化的全局变量。关于-memsize-和-filesize-，我们在-Note-1-3-4中也解释了它们的含义与特点。关于-Note-1-3-4，注意其中关于“bss-段并不在文件中占数据”表述的含义。回顾-Lab3-并思考：elf-load-seg-和-load-icode-mapper-函数是如何确保加载ELF文件时，bss-段数据被正确加载进虚拟内存空间。bss-段在-ELF-中并不占空间，但-ELF-加载进内存后，bss-段的数据占据了空间，并且初始值都是-0。请回顾-elf-load-seg-和-load-icode-mapper-的实现，思考这一点是如何实现的？" class="headerlink" title="(3) 在 Lab1 中我们介绍了 data text bss 段及它们的含义，data 段存放初始化过的全局变量，bss 段存放未初始化的全局变量。关于 memsize 和 filesize ，我们在 Note 1.3.4中也解释了它们的含义与特点。关于 Note 1.3.4，注意其中关于“bss 段并不在文件中占数据”表述的含义。回顾 Lab3 并思考：elf_load_seg() 和 load_icode_mapper()函数是如何确保加载ELF文件时，bss 段数据被正确加载进虚拟内存空间。bss 段在 ELF 中并不占空间，但 ELF 加载进内存后，bss 段的数据占据了空间，并且初始值都是 0。请回顾 elf_load_seg() 和 load_icode_mapper() 的实现，思考这一点是如何实现的？"></a>(3) 在 Lab1 中我们介绍了 data text bss 段及它们的含义，data 段存放初始化过的全局变量，bss 段存放未初始化的全局变量。关于 memsize 和 filesize ，我们在 Note 1.3.4中也解释了它们的含义与特点。关于 Note 1.3.4，注意其中关于“bss 段并不在文件中占数据”表述的含义。回顾 Lab3 并思考：elf_load_seg() 和 load_icode_mapper()函数是如何确保加载ELF文件时，bss 段数据被正确加载进虚拟内存空间。bss 段在 ELF 中并不占空间，但 ELF 加载进内存后，bss 段的数据占据了空间，并且初始值都是 0。请回顾 elf_load_seg() 和 load_icode_mapper() 的实现，思考这一点是如何实现的？</h4><ul><li>打开文件的流程：<ol><li>用户进程申请文件描述符，发送请求(文件的路径以及打开模式) </li><li>文件服务系统收到open请求，申请Open符表，在磁盘中根据路径寻找文件，将对应磁盘块读取到块缓存中，填充好Filefd发回</li><li>用户进程根据文件内容大小，使用 fsipc_map 在 fd 对应的 data 地址映射文件服务进程的文件内容，自此在用户进程地址空间有了该文件的基本信息与内容。</li></ol></li><li>Lab3 中我们创建进程，并且通过 ENV_CREATE(…) 在内核态加载了初始进程，而我们的 spawn 函数则是通过和文件系统交互，取得文件描述块，进而找到 ELF 在“硬盘”中的位置，进而读取。针对spawn的读取流程如下：<ol><li>根据文件路径读取文件进父进程地址空间。</li><li>读文件头找到段表首地址等信息。</li><li>根据段表首地址与段表项大小遍历所有段表项，每个段表项包含段起始地址(在文件中的偏移)，加载到的地址以及段大小信息，使用 elf_load_seg 将需要加载的段的内容加载进子进程地址空间。</li></ol></li><li>我们可以通过段表读取到filesz和memsz，因此若<code>memsz &gt; filesz</code>，则在最后补上相应的0即可。</li></ul><p>​    <strong>lib/elfloader.c</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; sgsize) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">map_page</span>(data, va + i, <span class="number">0</span>, perm, <span class="literal">NULL</span>, <span class="built_in">MIN</span>(bin_size - i, BY2PG))) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    i += BY2PG;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question6-通过阅读代码空白段的注释我们知道，将标准输入或输出定向到文件，需要我们将其-dup-到-0-或-1-号文件描述符（fd）。那么问题来了：在哪步，0-和-1-被“安排”为标准输入和标准输出？请分析代码执行流程，给出答案。"><a href="#Question6-通过阅读代码空白段的注释我们知道，将标准输入或输出定向到文件，需要我们将其-dup-到-0-或-1-号文件描述符（fd）。那么问题来了：在哪步，0-和-1-被“安排”为标准输入和标准输出？请分析代码执行流程，给出答案。" class="headerlink" title="Question6. 通过阅读代码空白段的注释我们知道，将标准输入或输出定向到文件，需要我们将其 dup 到 0 或 1 号文件描述符（fd）。那么问题来了：在哪步，0 和 1 被“安排”为标准输入和标准输出？请分析代码执行流程，给出答案。"></a>Question6. 通过阅读代码空白段的注释我们知道，将标准输入或输出定向到文件，需要我们将其 dup 到 0 或 1 号文件描述符（fd）。那么问题来了：在哪步，0 和 1 被“安排”为标准输入和标准输出？请分析代码执行流程，给出答案。</h4><p>在 <strong>user/init.c</strong> 中，使用<code>opencons + dup(0, 1)</code>将0号和1号文件安排为标准输入和输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">user/init.c:</span><br><span class="line"><span class="keyword">if</span> ((r = <span class="built_in">opencons</span>()) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">user_panic</span>(<span class="string">&quot;opencons: %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// stdout</span></span><br><span class="line"><span class="keyword">if</span> ((r = <span class="built_in">dup</span>(<span class="number">0</span>, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">user_panic</span>(<span class="string">&quot;dup: %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user/lib/console.c:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">opencons</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Fd</span> *fd;</span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">fd_alloc</span>(&amp;fd)) &lt; <span class="number">0</span>) &#123; <span class="comment">//由于一开始无其他文件，所以一定申请到0号文件</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = <span class="built_in">syscall_mem_alloc</span>(<span class="number">0</span>, fd, PTE_D | PTE_LIBRARY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    fd-&gt;fd_dev_id = devcons.dev_id;</span><br><span class="line">    fd-&gt;fd_omode = O_RDWR;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fd2num</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Question7-在-shell-中执行的命令分为内置命令和外部命令。在执行内置命令时-shell-不需要-fork-一个子-shell，如-Linux-系统中的-cd-命令。在执行外部命令时-shell-需要-fork一个子-shell，然后子-shell-去执行这条命令。据此判断，在-MOS-中我们用到的-shell-命令是内置命令还是外部命令？请思考为什么Linux-的-cd-命令是内部命令而不是外部命令？"><a href="#Question7-在-shell-中执行的命令分为内置命令和外部命令。在执行内置命令时-shell-不需要-fork-一个子-shell，如-Linux-系统中的-cd-命令。在执行外部命令时-shell-需要-fork一个子-shell，然后子-shell-去执行这条命令。据此判断，在-MOS-中我们用到的-shell-命令是内置命令还是外部命令？请思考为什么Linux-的-cd-命令是内部命令而不是外部命令？" class="headerlink" title="Question7. 在 shell 中执行的命令分为内置命令和外部命令。在执行内置命令时 shell 不需要 fork 一个子 shell，如 Linux 系统中的 cd 命令。在执行外部命令时 shell 需要 fork一个子 shell，然后子 shell 去执行这条命令。据此判断，在 MOS 中我们用到的 shell 命令是内置命令还是外部命令？请思考为什么Linux 的 cd 命令是内部命令而不是外部命令？"></a>Question7. 在 shell 中执行的命令分为内置命令和外部命令。在执行内置命令时 shell 不需要 fork 一个子 shell，如 Linux 系统中的 cd 命令。在执行外部命令时 shell 需要 fork一个子 shell，然后子 shell 去执行这条命令。据此判断，在 MOS 中我们用到的 shell 命令是内置命令还是外部命令？请思考为什么Linux 的 cd 命令是内部命令而不是外部命令？</h4><p>都是外部命令，因为每读入一条命令便fork出来一个子shell。</p><p>linux中的内部命令实际上是shell程序的一部分，其中包含的是一些比较简单的linux系统命令，这些命令由shell程序识别并在shell程序内部完成运行，通常在linux系统加载运行时shell就被加载并驻留在系统内存中。因为cd指令非常简单，将其作为内部命令写在bash源码里面的，可以避免每次执行都需要fork并加载程序，提高执行效率。</p><h4 id="Question8-在你的-shell-中输入命令-ls-b-cat-b-gt-motd。"><a href="#Question8-在你的-shell-中输入命令-ls-b-cat-b-gt-motd。" class="headerlink" title="Question8. 在你的 shell 中输入命令 ls.b | cat.b &gt; motd。"></a>Question8. 在你的 shell 中输入命令 ls.b | cat.b &gt; motd。</h4><h4 id="（1）请问你可以在你的-shell-中观察到几次-spawn-？分别对应哪个进程？"><a href="#（1）请问你可以在你的-shell-中观察到几次-spawn-？分别对应哪个进程？" class="headerlink" title="（1）请问你可以在你的 shell 中观察到几次 spawn ？分别对应哪个进程？"></a>（1）请问你可以在你的 shell 中观察到几次 spawn ？分别对应哪个进程？</h4><h4 id="（2）请问你可以在你的-shell-中观察到几次进程销毁？分别对应哪个进程？"><a href="#（2）请问你可以在你的-shell-中观察到几次进程销毁？分别对应哪个进程？" class="headerlink" title="（2）请问你可以在你的 shell 中观察到几次进程销毁？分别对应哪个进程？"></a>（2）请问你可以在你的 shell 中观察到几次进程销毁？分别对应哪个进程？</h4><ul><li><p>两次spawn，分别对应执行ls.b和cat.b的进程。</p></li><li><p>四次进程销毁，分别是spawn出来的ls.b和cat.b被销毁，以及它们的父进程(调用spawn的进程)被销毁。</p></li></ul><h2 id="二-实验难点"><a href="#二-实验难点" class="headerlink" title="二. 实验难点"></a>二. 实验难点</h2><p>本次实验难点主要在于对管道和重定向机制的理解，更具体来说在于虚拟与物理的对应关系。</p><h3 id="Shell机制"><a href="#Shell机制" class="headerlink" title="Shell机制"></a>Shell机制</h3><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB6_1.jpg" alt></p><p>借用指导书的图，有几个关键点。</p><ol><li><p>在init.c中将0，1文件设置为输入输出。然而通过阅读代码我们可以发现，该控制台文件并没有“内容”，输入输出以读写01号文件实现，然而console的read，write函数也是直接系统调用控制台输入输出，相当于中间加了一层过渡，看似没有意义，但却为重定向和管道打下铺垫。<br><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB6_2.jpg" alt></p></li><li><p>在系统启动时spawn出来一个shell，后每执行一条命令fork一个子进程，在子进程中再spawn出来子进程填充对应的命令代码执行，一条命令执行完后，两个子进程随之消亡。</p></li></ol><h3 id="重定向机制"><a href="#重定向机制" class="headerlink" title="重定向机制"></a>重定向机制</h3><p>实现shell中重定向输出的机制如图：<br><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB6_2.jpg" alt><br><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB6_4.jpg" alt></p><p>与下文shell管道的原理相同，核心都是<strong>改变了输入输出文件的类型导致改变了read，write函数</strong>。以本图为例，改变输出文件类型为File，当输出内容时，由于stdout变为了File文件，则会调用File类型文件的write函数，将内容写入文件中。</p><h3 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h3><p>实现shell中管道机制如图：<br><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB6_5.jpg" alt><br><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB6_6.jpg" alt><br>它改变了输入输出文件的类型为Pipe，当输入输出内容时，会调用实现过的Pipe read/write，完成了管道内容的读写，效果好似将两个进程<strong>串联</strong>了起来。</p><h2 id="三-心得体会"><a href="#三-心得体会" class="headerlink" title="三. 心得体会"></a>三. 心得体会</h2><p>行文至此，也便意味着OS实验课也即将彻底落下帷幕。本LAB一共用时20h左右，填写代码难度较为简单，但理解代码十分不易，且在管道读写的机制上出现了一些问题耽误了笔者很长时间。我们实现了管道机制并制作了简单的Shell，其中重定向的实现机制令笔者称奇，当shell界面出现在眼前时，一学期的一切努力都转化成了满满的成就感。然而目前实现的功能仅有ls，cat，echo等简单命令，笔者正在进行LAB6挑战性任务的实验，完成一个加强shell实现更多的命令，想必会更加有趣(且苦难。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『操作系统』操作系统实验LAB5——文件系统与外存</title>
      <link href="/post/9c179b0b.html"/>
      <url>/post/9c179b0b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『操作系统』操作系统实验LAB5——文件系统与外存"><a href="#『操作系统』操作系统实验LAB5——文件系统与外存" class="headerlink" title="『操作系统』操作系统实验LAB5——文件系统与外存"></a>『操作系统』操作系统实验LAB5——文件系统与外存</h1><h2 id="一-思考题"><a href="#一-思考题" class="headerlink" title="一. 思考题"></a>一. 思考题</h2><h4 id="Question1-如果通过-kseg0-读写设备，那么对于设备的写入会缓存到-Cache-中。这是一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请思考：这么做会引发什么问题？对于不同种类的设备（如我们提到的串口设备和-IDE-磁盘）的操作会有差异吗？可以从缓存的性质和缓存更新的策略来考虑。"><a href="#Question1-如果通过-kseg0-读写设备，那么对于设备的写入会缓存到-Cache-中。这是一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请思考：这么做会引发什么问题？对于不同种类的设备（如我们提到的串口设备和-IDE-磁盘）的操作会有差异吗？可以从缓存的性质和缓存更新的策略来考虑。" class="headerlink" title="Question1. 如果通过 kseg0 读写设备，那么对于设备的写入会缓存到 Cache 中。这是一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请思考：这么做会引发什么问题？对于不同种类的设备（如我们提到的串口设备和 IDE 磁盘）的操作会有差异吗？可以从缓存的性质和缓存更新的策略来考虑。"></a>Question1. 如果通过 kseg0 读写设备，那么对于设备的写入会缓存到 Cache 中。这是一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请思考：这么做会引发什么问题？对于不同种类的设备（如我们提到的串口设备和 IDE 磁盘）的操作会有差异吗？可以从缓存的性质和缓存更新的策略来考虑。</h4><p>当我们与内存交互时使用Cache没有问题，因为内存中的数据只依赖CPU的写操作而改变，使用Cache可以保证访存数据一致性；而当我们与外设交互时，由于外设中的数据的更新并不只依赖于CPU的写操作，还会由外设自己更新(比如计时器的中断位)，这会导致出现<strong>缓存数据和此刻实际外设数据不一致的情况</strong>，即Cache里仍是老数据，而实际的数据外设自身已经更新却无法及时通知给Cache。</p><p>有区别，串口是<strong>字符设备</strong>，只支持顺序读取，无需经过缓存，直接以字符（字节）为单位进行读写；而IDE磁盘是<strong>块设备</strong>，支持随机读取。<strong>内存是磁盘的缓存</strong>，如LAB5文件服务进程将磁盘空间映射到进程虚拟空间中，在访问块设备时会经过内存这一层缓存，更高效的对数据进行访问。</p><h4 id="Question2-查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为多大？"><a href="#Question2-查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为多大？" class="headerlink" title="Question2. 查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为多大？"></a>Question2. 查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为多大？</h4><p>一个磁盘块与一页大小相同，为4KB，一个文件控制块大小 BY2FILE=256B，因此一个磁盘块最多存储16个文件控制块。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">File</span> &#123;</span><br><span class="line">    u_char f_name[MAXNAMELEN];</span><br><span class="line">    u_int f_size;</span><br><span class="line">    u_int f_type;</span><br><span class="line">    u_int f_direct[NDIRECT];</span><br><span class="line">    u_int f_indirect;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">File</span> *f_dir;</span><br><span class="line">    u_char f_pad[BY2FILE - MAXNAMELEN - <span class="number">4</span> - <span class="number">4</span> - NDIRECT * <span class="number">4</span> - <span class="number">4</span> - <span class="number">4</span>]; <span class="comment">//对齐</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个目录下最多拥有直接指针 + 间接指针指向的1024个磁盘块，每个磁盘块可以存储16个文件，共能存储16384个文件。</p><p>同理，一个普通文件最多也可指向1024个磁盘块，最大容纳数据为$1024*4KB=4MB$。</p><h4 id="Question3-请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？"><a href="#Question3-请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？" class="headerlink" title="Question3. 请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？"></a>Question3. 请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？</h4><p>文件服务进程将 DISKMAP 到 DISKMAP+DISKMAX 这一段虚存地址空间 (0x10000000-0x4fffffff) 作为缓冲区，可计算得出内核最大支持1GB的磁盘，而本实验磁盘大小仅仅为$1024*4KB=4MB$。</p><h4 id="Question4-在本实验中，fs-serv-h、user-include-fs-h-等文件中出现了许多宏定义，试列举你认为较为重要的宏定义，同时进行解释，并描述其主要应用之处。"><a href="#Question4-在本实验中，fs-serv-h、user-include-fs-h-等文件中出现了许多宏定义，试列举你认为较为重要的宏定义，同时进行解释，并描述其主要应用之处。" class="headerlink" title="Question4. 在本实验中，fs/serv.h、user/include/fs.h 等文件中出现了许多宏定义，试列举你认为较为重要的宏定义，同时进行解释，并描述其主要应用之处。"></a>Question4. 在本实验中，fs/serv.h、user/include/fs.h 等文件中出现了许多宏定义，试列举你认为较为重要的宏定义，同时进行解释，并描述其主要应用之处。</h4><p><strong>serv.h</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_DIRTY 0x0002 <span class="comment">//脏位 用来判断内存中的磁盘内容需不需要写回磁盘</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISKNO 1 <span class="comment">//磁盘号 固定为1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BY2SECT 512  <span class="comment">//一个扇区大小 512字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECT2BLK (BY2BLK / BY2SECT) <span class="comment">//一个磁盘块有8个扇区</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISKMAP 0x10000000 <span class="comment">//磁盘映射的起始虚拟地址 针对文件服务进程</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISKMAX 0x40000000 <span class="comment">//磁盘映射空间大小</span></span></span><br></pre></td></tr></table></figure><p><strong>fs.h</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BY2BLK BY2PG  <span class="comment">//磁盘块大小 与一页相等（字节）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT2BLK (BY2BLK * 8) <span class="comment">//磁盘块大小（比特）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNAMELEN 128 <span class="comment">//文件名最大长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXPATHLEN 1024 <span class="comment">//路径名最大长度（包含数个用/连接的文件名）</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDIRECT 10 <span class="comment">//直接指针数量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NINDIRECT (BY2BLK / 4) <span class="comment">//间接指针数量 一个指针4字节 一个磁盘块BY2BLK字节</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXFILESIZE (NINDIRECT * BY2BLK) <span class="comment">//文件最大大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BY2FILE 256 <span class="comment">//文件控制块大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">File</span> &#123;</span><br><span class="line">    <span class="type">char</span> f_name[MAXNAMELEN]; <span class="comment">// 文件名</span></span><br><span class="line">    <span class="type">uint32_t</span> f_size;         <span class="comment">// 文件大小       uint32_t f_type;         // 文件类型，目录文件或普通文件</span></span><br><span class="line">    <span class="type">uint32_t</span> f_direct[NDIRECT]; <span class="comment">//直接指针</span></span><br><span class="line">    <span class="type">uint32_t</span> f_indirect; <span class="comment">//间接指针 指向另一磁盘块</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">File</span> *f_dir; <span class="comment">// 指向自己的上级目录（当此控制块可用时）</span></span><br><span class="line">    <span class="type">char</span> f_pad[BY2FILE - MAXNAMELEN - (<span class="number">3</span> + NDIRECT) * <span class="number">4</span> - <span class="built_in">sizeof</span>(<span class="type">void</span> *)]; <span class="comment">//填充</span></span><br><span class="line">&#125; __attribute__((<span class="built_in">aligned</span>(<span class="number">4</span>), packed));</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILE2BLK (BY2BLK / sizeof(struct File)) <span class="comment">//一个磁盘块可容纳多少文件控制块 16</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTYPE_REG 0 <span class="comment">// Regular file</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTYPE_DIR 1 <span class="comment">// Directory</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_MAGIC 0x68286097 <span class="comment">// Everyone&#x27;s favorite OS class 魔数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Super</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> s_magic;   <span class="comment">// Magic number: FS_MAGIC 魔数</span></span><br><span class="line">    <span class="type">uint32_t</span> s_nblocks; <span class="comment">// Total number of blocks on disk 磁盘块数量</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">File</span> s_root; <span class="comment">// Root directory node 根目录控制块</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主要应用在文件服务进程与磁盘镜像的交互中。</p><h4 id="Question5-在-Lab4“系统调用与-fork”的实验中我们实现了极为重要的-fork-函数。那么-fork-前后的父子进程是否会共享文件描述符和定位指针呢？请在完成上述练习的基础上编写一个程序进行验证。"><a href="#Question5-在-Lab4“系统调用与-fork”的实验中我们实现了极为重要的-fork-函数。那么-fork-前后的父子进程是否会共享文件描述符和定位指针呢？请在完成上述练习的基础上编写一个程序进行验证。" class="headerlink" title="Question5. 在 Lab4“系统调用与 fork”的实验中我们实现了极为重要的 fork 函数。那么 fork 前后的父子进程是否会共享文件描述符和定位指针呢？请在完成上述练习的基础上编写一个程序进行验证。"></a>Question5. 在 Lab4“系统调用与 fork”的实验中我们实现了极为重要的 fork 函数。那么 fork 前后的父子进程是否会共享文件描述符和定位指针呢？请在完成上述练习的基础上编写一个程序进行验证。</h4><p>会共享文件描述符和定位指针，在serve_open中可以看到</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ipc_send</span>(envid, <span class="number">0</span>, o-&gt;o_ff, PTE_D | PTE_LIBRARY);</span><br></pre></td></tr></table></figure><p>即将文件描述符在用户虚拟空间映射的权限设置为 <code>PTE_D | PTE_LIBRARY</code>，在LAB4中我们知道这种页面是<strong>不会被设置为写时复制</strong>的，因此父子进程共享。</p><p>测试程序如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> r, fdnum, n;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">200</span>];</span><br><span class="line">    <span class="type">char</span> *w = <span class="string">&quot;yangbowen&quot;</span>; </span><br><span class="line">    fdnum = <span class="built_in">open</span>(<span class="string">&quot;/newmotd&quot;</span>, O_RDWR);</span><br><span class="line">    n = <span class="built_in">write</span>(fdnum, w, <span class="built_in">strlen</span>(w));</span><br><span class="line">    <span class="built_in">close</span>(r);</span><br><span class="line">    fdnum = <span class="built_in">open</span>(<span class="string">&quot;/newmotd&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> ((r = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        n = <span class="built_in">read</span>(fdnum, buf, <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">debugf</span>(<span class="string">&quot;child buffer is %s\n&quot;</span>, buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n = <span class="built_in">read</span>(fdnum, buf, <span class="number">5</span>);</span><br><span class="line">        <span class="built_in">debugf</span>(<span class="string">&quot;father buffer is %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------</span><br><span class="line">reselt:</span><br><span class="line">father buffer is yang</span><br><span class="line">child buffer is bowen</span><br><span class="line">----------------------</span><br></pre></td></tr></table></figure><h4 id="Question6-请解释-File-Fd-Filefd-结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架。"><a href="#Question6-请解释-File-Fd-Filefd-结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架。" class="headerlink" title="Question6. 请解释 File, Fd, Filefd 结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架。"></a>Question6. 请解释 File, Fd, Filefd 结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架。</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Fd</span> &#123;</span><br><span class="line">    u_int fd_dev_id; <span class="comment">//设备</span></span><br><span class="line">    u_int fd_offset; <span class="comment">//文件</span></span><br><span class="line">    u_int fd_omode; <span class="comment">//文件打开模式</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Filefd</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Fd</span> f_fd;  <span class="comment">//上述结构</span></span><br><span class="line">    u_int f_fileid;  <span class="comment">//文件特有id</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">File</span> f_file; <span class="comment">//对应的文件控制块</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">File见前思考题</span><br></pre></td></tr></table></figure><p>File结构体是文件控制块，用来在磁盘中存储文件信息，是磁盘上的物理实体，自然也会被读入文件服务进程中；其他是单纯的内存数据，保存在用户进程中，用户与文件交互的任何操作都要使用Filefd，其不仅包含了File，还包含了一些其他方便我们与文件进行交互的信息，比如id，位置，打开状态等，这些信息对于磁盘内文件来说是不需要的，只有当我们使用时才需要，因此文件系统数据结构设计成既包含物理实体，又含有用户信息的结构，服务进程使用File，用户进程使用Filefd。</p><p>file_id在与服务进程交互中使用，而在用户进程我们使用 fd2num 也可唯一的表示一个文件。</p><h4 id="Question7-图5-7中有多种不同形式的箭头，请解释这些不同箭头的差别，并思考我们的操作系统是如何实现对应类型的进程间通信的。"><a href="#Question7-图5-7中有多种不同形式的箭头，请解释这些不同箭头的差别，并思考我们的操作系统是如何实现对应类型的进程间通信的。" class="headerlink" title="Question7. 图5.7中有多种不同形式的箭头，请解释这些不同箭头的差别，并思考我们的操作系统是如何实现对应类型的进程间通信的。"></a>Question7. 图5.7中有多种不同形式的箭头，请解释这些不同箭头的差别，并思考我们的操作系统是如何实现对应类型的进程间通信的。</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB5_5.jpg" alt></p><p>黑三角箭头且黑色实线，是同步消息；</p><p>开三角箭头且黑色虚线，是返回消息；</p><p>返回消息和同步消息结合使用时(黑框中IPC过程)，同步消息的发送者把进程控制权交给消息的接收者，然后暂停活动，等待消息接收者的返回消息，收到后继续执行。</p><p>在本LAB中同步消息的发送者是用户进程，返回消息的发送者是文件服务进程，用户进程通过 fsipc 函数，服务进程通过 serve_* 函数实现双向通信。服务进程通过轮询的方式不停探寻来自用户进程的发送信息，并根据请求号执行相应的操作，并返回信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fsipc:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">fsipc</span><span class="params">(u_int type, <span class="type">void</span> *fsreq, <span class="type">void</span> *dstva, u_int *perm)</span> </span>&#123;</span><br><span class="line">    u_int whom;</span><br><span class="line">    <span class="comment">// Our file system server must be the 2nd env.</span></span><br><span class="line">    <span class="built_in">ipc_send</span>(envs[<span class="number">1</span>].env_id, type, fsreq, PTE_D);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ipc_recv</span>(&amp;whom, dstva, perm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">serve:</span><br><span class="line">req = <span class="built_in">ipc_recv</span>(&amp;whom, (<span class="type">void</span> *)REQVA, &amp;perm);</span><br><span class="line"></span><br><span class="line">以serve_open为例:</span><br><span class="line"><span class="built_in">ipc_send</span>(envid, <span class="number">0</span>, o-&gt;o_ff, PTE_D | PTE_LIBRARY);</span><br></pre></td></tr></table></figure><h2 id="二-实验难点"><a href="#二-实验难点" class="headerlink" title="二. 实验难点"></a>二. 实验难点</h2><h3 id="MMIO映射"><a href="#MMIO映射" class="headerlink" title="MMIO映射"></a>MMIO映射</h3><p>我们访问外设是以访问其寄存器（控制寄存器、状态寄存器和数据寄存器）的形式进行数据通信的，每种外设都被映射到了指定的<strong>物理地址空间</strong>，我们使用KSEG1段的不经过Cache和MMU的虚拟地址来访问外设寄存器，通过简单的读写固定的内核虚拟地址即可实现驱动外设程序的功能。磁盘被映射到0x13000000。</p><h3 id="文件系统结构"><a href="#文件系统结构" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>基于该图：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB5_1.jpg" alt></p><p>我们向用户进程提供了许多文件操作的接口，大致分为两类，一类是在用户进程就可完成的操作，比如 read，write，stat，seek 由于他们操作的信息已经存在于用户空间中；另一类是需要与文件服务进程交互的操作，即需要调用 fsipc_* -&gt; fsipc 使用 IPC 与文件服务进程通信，而文件服务进程根据不同的操作码在serve中执行相应的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_OPEN 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_MAP 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_SET_SIZE 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_CLOSE 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_DIRTY 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_REMOVE 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_SYNC 7</span></span><br></pre></td></tr></table></figure><p>几个关键操作解析：</p><ul><li><p>write：调用 file_write（将内容写入内存）</p></li><li><p>read：调用 file_read（从内存读取内容）<br>这两个操作不涉及与文件服务程序的交互</p></li><li><p>open：申请一个文件描述符，并使用 fsipe_open 获得磁盘中对应的文件控制块(无对应路径则创建一个新的文件)，然后使用 fsipe_map 将磁盘内容读出到服务进程，再映射到用户进程虚拟空间中，方便读写。</p></li><li><p>close：调用file_close ，使用 fsipc_dirty 告知文件服务进程需要写回的磁盘块（疑似是所有），再使用 fsipc_close 关闭这个文件，即找到该文件对应的所有磁盘块写回磁盘，最后取消文件和文件描述符在用户虚拟空间的映射，自然服务进程的映射同样取消。</p></li><li><p>remove：调用fsipc_remove -&gt; file_remove，将文件名清空，对应磁盘块释放，写回磁盘</p></li><li><p>seek：找到对应的文件控制块，将其位置指针自定义，一般用来重置到文件头或尾</p></li></ul><p>上述操作除 remove 皆用于<strong>普通文件</strong>，即是文件树的最底层，而 remove 需要对一棵文件子树进行处理。</p><h3 id="一些机制"><a href="#一些机制" class="headerlink" title="一些机制"></a>一些机制</h3><ul><li><p>先在服务进程空间中申请创建新文件，读写文件等，在close时再将其统一写回磁盘。</p></li><li><p>不用担心用户进程和服务进程文件信息不同步，因为 fsipc_map 中使用的IPC将他们映射到同一物理地址空间上，只需考虑将内存中的文件写回磁盘即可。</p></li><li><p>在我们实现的文件系统中，<strong>读写共享一个位置指针</strong>，因此在write之后若想读出，需要先将文件close后再open，或者使用seek重置到文件头。</p></li><li><p>tools/fsformat.c是一个镜像，用disk数组模拟了磁盘，镜像指将Linux下的文件拷贝到disk数组中，再输出到Linux环境下的某个文件里，可以在main函数中自由的指定拷贝路径以及输出路径等。这里面涉及到使用数组对磁盘的虚拟，以及Linux环境下的文件操作。</p></li></ul><h2 id="三-心得体会"><a href="#三-心得体会" class="headerlink" title="三.心得体会"></a>三.心得体会</h2><p>操作系统实验即将结尾，在LAB5中，我们完成了一个简易的文件系统，并学习到了外设，镜像相关的知识，整体难度较高，总计用时20小时左右。</p><p>完成本次实验最明显的感受是，代码量极大，结构极其复杂，涉及许多个文件间的协同配合，同时我们完成的仅仅是很少一部分代码，很多与磁盘交互的核心代码都已给出，若是只完成填充的代码，甚至不说理解其中的细节，连整体架构都很难理解，我在填充时存在大量的疑惑。在完成后，我又花了时间结合结构图去梳理各个文件，并试图理解其中的内容，到现在就算懂了个大概(也许)，对于磁盘路径的一些操作仍云里雾里，因此更加佩服能设计操作系统的设计者，再次对微内核的基本设计思想和结构感到震撼orz，令我受益匪浅。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『操作系统』操作系统实验LAB4——系统调用与Fork</title>
      <link href="/post/74d1b4fb.html"/>
      <url>/post/74d1b4fb.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『操作系统』操作系统实验LAB4——系统调用与Fork"><a href="#『操作系统』操作系统实验LAB4——系统调用与Fork" class="headerlink" title="『操作系统』操作系统实验LAB4——系统调用与Fork"></a>『操作系统』操作系统实验LAB4——系统调用与Fork</h1><h2 id="一-思考题"><a href="#一-思考题" class="headerlink" title="一. 思考题"></a>一. 思考题</h2><h4 id="Question1-思考并回答下面的问题："><a href="#Question1-思考并回答下面的问题：" class="headerlink" title="Question1. 思考并回答下面的问题："></a>Question1. 思考并回答下面的问题：</h4><h4 id="•-内核在保存现场的时候是如何避免破坏通用寄存器的？"><a href="#•-内核在保存现场的时候是如何避免破坏通用寄存器的？" class="headerlink" title="• 内核在保存现场的时候是如何避免破坏通用寄存器的？"></a>• 内核在保存现场的时候是如何避免破坏通用寄存器的？</h4><p>• 系统陷入内核调用后可以直接从当时的 $a0-$a3 参数寄存器中得到用户调用 msyscall<br>留下的信息吗？<br>• 我们是怎么做到让 sys 开头的函数“认为”我们提供了和用户调用 msyscall 时同样<br>的参数的？<br>• 内核处理系统调用的过程对 Trapframe 做了哪些更改？这种修改对应的用户态的变<br>化是什么？</p><p>(1) 每当发生异常需要进入内核时，OS都会先使用SAVE_ALL将上下文保存进Trapframe中，其中便包括32个通用寄存器，具体来说，首先将指向用户栈的sp赋值给k0，再将32个寄存器及其他保存，最后将sp指向Trapframe的栈顶。在返回用户态时再调用ret_from_exception，首先执行RESTORE_SOME宏将寄存器内容归还，再将k0赋值上EPC，再将sp指向原先的用户栈，最后返回用户态，实现了对通用寄存器(除k0,k1)的保护。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB4_1.jpg" alt></p><p>(2) 可以，系统陷入内核后$a0~$a3寄存器没有发生变动，即使它们也被保存进了Trapframe中，因此自然可以通过直接使用a0到a3来获取参数。但是仅局限于刚进入内核态，在执行handle_sys之前可以，因为在handle_sys中，为给do_syscall传参，$a0被赋予了*tf的值。</p><p>(3) 通过在刚进入内核态就拷贝好的Trapframe，do<em>syscall从Trapframe中获取参数并传递给sys</em>*。</p><p>(4) 主要更改了两个地方，第一更改了epc，具体来说令其加4，即返回用户态时继续执行系统调用后的<strong>下一条</strong>指令；第二更改了$v0，系统调用得到的结果(若有)存放于$v0中，以供用户态使用。整体对用户态来说就像是执行了一个普通的有返回值的函数一般。</p><h4 id="Question2-思考-envid2env-函数-为什么-envid2env-中需要判断-e-gt-env-id-envid的情况？如果没有这步判断会发生什么情况？"><a href="#Question2-思考-envid2env-函数-为什么-envid2env-中需要判断-e-gt-env-id-envid的情况？如果没有这步判断会发生什么情况？" class="headerlink" title="Question2. 思考 envid2env 函数: 为什么 envid2env 中需要判断 e-&gt;env_id != envid的情况？如果没有这步判断会发生什么情况？"></a>Question2. 思考 envid2env 函数: 为什么 envid2env 中需要判断 e-&gt;env_id != envid的情况？如果没有这步判断会发生什么情况？</h4><p>笔者也不确定，也许是为了防止用户访问其他的进程而作出的保护。</p><h4 id="Question3-思考下面的问题，并对这个问题谈谈你的理解：请回顾-kern-env-c-文件中-mkenvid-函数的实现，该函数不会返回-0，请结合系统调用和-IPC-部分的实现与envid2env-函数的行为进行解释。"><a href="#Question3-思考下面的问题，并对这个问题谈谈你的理解：请回顾-kern-env-c-文件中-mkenvid-函数的实现，该函数不会返回-0，请结合系统调用和-IPC-部分的实现与envid2env-函数的行为进行解释。" class="headerlink" title="Question3. 思考下面的问题，并对这个问题谈谈你的理解：请回顾 kern/env.c 文件中 mkenvid() 函数的实现，该函数不会返回 0，请结合系统调用和 IPC 部分的实现与envid2env() 函数的行为进行解释。"></a>Question3. 思考下面的问题，并对这个问题谈谈你的理解：请回顾 kern/env.c 文件中 mkenvid() 函数的实现，该函数不会返回 0，请结合系统调用和 IPC 部分的实现与envid2env() 函数的行为进行解释。</h4><p>makenvid 中返回的 envid 永远不会是0，这是由于在 envid2env 函数中，传进来的 envid 为0时，返回的是当前进程的进程块，这样避免了进程块冲突。</p><p>因为在用户态下无法直接得到当前进程块指针，因此在用户态下处理写时复制，以及执行 fork 时会出现得不到 curenv 的情况(就本LAB而言)。用户态下系统调用时给 envid 传入0的意思便是使用当前进程控制块，便于系统调用访问。当然一些其他的情况使用0也更加的简单便捷。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB4_2.jpg" alt></p><h4 id="Question4-关于-fork-函数的两个返回值，下面说法正确的是："><a href="#Question4-关于-fork-函数的两个返回值，下面说法正确的是：" class="headerlink" title="Question4. 关于 fork 函数的两个返回值，下面说法正确的是："></a>Question4. 关于 fork 函数的两个返回值，下面说法正确的是：</h4><h4 id="•-A、fork-在父进程中被调用两次，产生两个返回值"><a href="#•-A、fork-在父进程中被调用两次，产生两个返回值" class="headerlink" title="• A、fork 在父进程中被调用两次，产生两个返回值"></a>• A、fork 在父进程中被调用两次，产生两个返回值</h4><h4 id="•-B、fork-在两个进程中分别被调用一次，产生两个不同的返回值"><a href="#•-B、fork-在两个进程中分别被调用一次，产生两个不同的返回值" class="headerlink" title="• B、fork 在两个进程中分别被调用一次，产生两个不同的返回值"></a>• B、fork 在两个进程中分别被调用一次，产生两个不同的返回值</h4><h4 id="•-C、fork-只在父进程中被调用了一次，在两个进程中各产生一个返回值"><a href="#•-C、fork-只在父进程中被调用了一次，在两个进程中各产生一个返回值" class="headerlink" title="• C、fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值"></a>• C、fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值</h4><h4 id="•-D、fork-只在子进程中被调用了一次，在两个进程中各产生一个返回值"><a href="#•-D、fork-只在子进程中被调用了一次，在两个进程中各产生一个返回值" class="headerlink" title="• D、fork 只在子进程中被调用了一次，在两个进程中各产生一个返回值"></a>• D、fork 只在子进程中被调用了一次，在两个进程中各产生一个返回值</h4><p>选C。</p><h4 id="Question5-我们并不应该对所有的用户空间页都使用-duppage-进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？请结合-kern-env-c-中-env-init-函数进行的页面映射、include-mmu-h-里的内存布局图以及本章的后续描述进行思考。"><a href="#Question5-我们并不应该对所有的用户空间页都使用-duppage-进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？请结合-kern-env-c-中-env-init-函数进行的页面映射、include-mmu-h-里的内存布局图以及本章的后续描述进行思考。" class="headerlink" title="Question5. 我们并不应该对所有的用户空间页都使用 duppage 进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？请结合 kern/env.c 中 env_init 函数进行的页面映射、include/mmu.h 里的内存布局图以及本章的后续描述进行思考。"></a>Question5. 我们并不应该对所有的用户空间页都使用 duppage 进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？请结合 kern/env.c 中 env_init 函数进行的页面映射、include/mmu.h 里的内存布局图以及本章的后续描述进行思考。</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB4_4.jpg" alt><br>内核内存部分不需要映射，所有进程共享。</p><p>UTOP和ULIM之间储存三部分内容，分别是总进程控制块信息，总物理页面信息，以及当前进程和内核相关的页表信息。在执行env_alloc()函数时，这一部分的映射关系直接从base_pgdir拷贝到进程页表中，因此不需要进行映射。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(e-&gt;env_pgdir + <span class="built_in">PDX</span>(UTOP), base_pgdir + <span class="built_in">PDX</span>(UTOP), <span class="built_in">sizeof</span>(Pde) * (<span class="built_in">PDX</span>(UVPT) - <span class="built_in">PDX</span>(UTOP)));</span><br><span class="line">e-&gt;env_pgdir[<span class="built_in">PDX</span>(UVPT)] = <span class="built_in">PADDR</span>(e-&gt;env_pgdir) | PTE_V;</span><br></pre></td></tr></table></figure><p>USTACKTOP到UTOP间是用户态下的异常处理栈和无用内存，父子进程显然不需要共享这部分内存。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB4_3.jpg" alt></p><p>因此如图所示，只需映射USTACKTOP以下的有效的页面。</p><h4 id="Question6-在遍历地址空间存取页表项时你需要使用到-vpd-和-vpt-这两个指针，请参考-user-include-lib-h-中的相关定义，思考并回答这几个问题："><a href="#Question6-在遍历地址空间存取页表项时你需要使用到-vpd-和-vpt-这两个指针，请参考-user-include-lib-h-中的相关定义，思考并回答这几个问题：" class="headerlink" title="Question6. 在遍历地址空间存取页表项时你需要使用到 vpd 和 vpt 这两个指针，请参考 user/include/lib.h 中的相关定义，思考并回答这几个问题："></a>Question6. 在遍历地址空间存取页表项时你需要使用到 vpd 和 vpt 这两个指针，请参考 user/include/lib.h 中的相关定义，思考并回答这几个问题：</h4><h4 id="•-vpt-和-vpd-的作用是什么？怎样使用它们？"><a href="#•-vpt-和-vpd-的作用是什么？怎样使用它们？" class="headerlink" title="• vpt 和 vpd 的作用是什么？怎样使用它们？"></a>• vpt 和 vpd 的作用是什么？怎样使用它们？</h4><p>• 从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？<br>• 它们是如何体现自映射设计的？<br>• 进程能够通过这种方式来修改自己的页表项吗？</p><p>(1) vpt指二级页表首地址的虚拟地址，即UVPT；vpd指页目录首地址的虚拟地址，即$UVPT + (PDX(UVPT) &lt;&lt; 12)$，可以用来对用户页表和页目录进行访问。以vpt为例，使用时先将其转化为指针形式，然后加上虚拟地址的页号，得到的地址中存储的便是对应的物理页号，再按地址进行读取即可。</p><p>(2) 因为vpt经由页表映射到了页表的首地址，vpd经由页表映射到了页目录的首地址。</p><p>(3) 页表自映射，即把所有页目录表和页表映射到一个连续的4MB虚拟地址空间中。在内核态中，访问页目录通过 e-&gt;pgdir 即可，因为在内核态下经由 page2kva 转换后可不经页表直接访问物理地址，而在用户态下访问页表需要经过页表转换，这时候vpt就派上用场，我们早在给进程页表初始化时便完成了自映射的设计，即:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e-&gt;env_pgdir[<span class="built_in">PDX</span>(UVPT)] = <span class="built_in">PADDR</span>(e-&gt;env_pgdir) | PTE_V</span><br></pre></td></tr></table></figure><p>这样我们可保证访问虚拟地址$[UVPT，UVPT+4MB)$即是访问当前进程的页表。</p><p>(4)不能，用户态下对页表只能读不能写。</p><h4 id="Question7-在-do-tlb-mod-函数中，你可能注意到了一个向异常处理栈复制-Trapframe运行现场的过程，请思考并回答这几个问题："><a href="#Question7-在-do-tlb-mod-函数中，你可能注意到了一个向异常处理栈复制-Trapframe运行现场的过程，请思考并回答这几个问题：" class="headerlink" title="Question7. 在 do_tlb_mod 函数中，你可能注意到了一个向异常处理栈复制 Trapframe运行现场的过程，请思考并回答这几个问题："></a>Question7. 在 do_tlb_mod 函数中，你可能注意到了一个向异常处理栈复制 Trapframe运行现场的过程，请思考并回答这几个问题：</h4><h4 id="•-这里实现了一个支持类似于“异常重入”的机制，而在什么时候会出现这种“异常重入”？"><a href="#•-这里实现了一个支持类似于“异常重入”的机制，而在什么时候会出现这种“异常重入”？" class="headerlink" title="• 这里实现了一个支持类似于“异常重入”的机制，而在什么时候会出现这种“异常重入”？"></a>• 这里实现了一个支持类似于“异常重入”的机制，而在什么时候会出现这种“异常重入”？</h4><p>• 内核为什么需要将异常的现场 Trapframe 复制到用户空间？</p><p>(1) 当父子进程需要对一个页面进行写操作时，会触发写时复制机制，这个时候陷入内核，在do_tlb_mod函数中进行配置(拷贝TF，设置a0和epc)后，跳转到用户态进行处理。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB4_5.jpg" alt></p><p><strong>补充</strong>: 笔者前面理解的不是很到位，”异常重入”应当是说，在COW_ENTRY执行过程中又写入了带有一个PTE_COW位的页面，又要进入内核态进入tlb_mod异常处理，又调用COW_ENTRY，如此反复……发生了”重入”的现象。</p><p>(2) 因为写时复制异常的真正处理是在用户态进行的，而用户态只能访问用户空间（低2G空间）内的数据，所以需要将现场保存在用户空间下。</p><h4 id="Question8-在用户态处理页写入异常，相比于在内核态处理有什么优势？"><a href="#Question8-在用户态处理页写入异常，相比于在内核态处理有什么优势？" class="headerlink" title="Question8. 在用户态处理页写入异常，相比于在内核态处理有什么优势？"></a>Question8. 在用户态处理页写入异常，相比于在内核态处理有什么优势？</h4><p>尽量减少内核出现错误的可能，即使程序崩溃，也不会影响系统的稳定。同时微内核的模式下，用户态进行新页面的分配映射也更加灵活方便。</p><h4 id="Question9-请思考并回答以下几个问题："><a href="#Question9-请思考并回答以下几个问题：" class="headerlink" title="Question9. 请思考并回答以下几个问题："></a>Question9. 请思考并回答以下几个问题：</h4><h4 id="•-为什么需要将-syscall-set-tlb-mod-entry-的调用放置在-syscall-exofork-之前？"><a href="#•-为什么需要将-syscall-set-tlb-mod-entry-的调用放置在-syscall-exofork-之前？" class="headerlink" title="• 为什么需要将 syscall_set_tlb_mod_entry 的调用放置在 syscall_exofork 之前？"></a>• 为什么需要将 syscall_set_tlb_mod_entry 的调用放置在 syscall_exofork 之前？</h4><p>• 如果放置在写时复制保护机制完成之后会有怎样的效果？</p><p>syscall_set_tlb_mod_entry 如果放置在写时复制保护机制完成之后会导致在父进程进行 duppage 的设置过程中遇到的 COW 缺页异常无法得到正确的处理，即在执行 syscall_set_tlb_mod_entry 之前就会发生 写时复制异常 ，此时还没有相应的 handler 进行处理，系统就会出现问题。</p><h2 id="二-实验难点"><a href="#二-实验难点" class="headerlink" title="二.实验难点"></a>二.实验难点</h2><p>本LAB介绍了系统调用，并重点实现了进程间通信与fork函数，在其中又涉及了大量的系统调用函数。本次实验难点较多，在此重点介绍系统调用流程和fork函数的实现流程。</p><h3 id="系统调用流程"><a href="#系统调用流程" class="headerlink" title="系统调用流程"></a>系统调用流程</h3><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB4_6.jpg" alt></p><p>函数追踪如下所示：</p><p><strong>syscall_*</strong>，调用 msyscall (参数)，根据不同的 syscall 统一使用 msyscall 传递不同的参数 ➡<br><strong>msyscall</strong>，汇编文件，使用syscall进入内核 ➡<br><strong><em>用户态内核态分界线</em></strong><br><strong>entry.S</strong>，进入内核入口，SAVE<em>ALL保存现场，并根据CP0_CAUSE中异常码分配给不同的 handle\</em><em> 函数，在本lab中处理中断异常为 handle<em>sys ➡<br><strong>handle_sys</strong>，将$a0赋值Trapframe指针，并调用 do<em>syscall ➡<br><em>_do_syscall</em></em>，从Trapframe中获取 msyscall 传入的参数，根据取到的第一个参数即系统调用号获取对应的 sys</em>\</em> 函数并传入参数调用 ➡<br><strong>sys_*</strong>，具体实现系统调用的流程，将函数结果返回 do<em>syscall ➡<br><strong>do_syscall</strong>，将返回结果保存到Trapframe($v0)处，并返回至 handle<em>int ➡<br><strong>handle_int</strong>，调用 ret_from_exception，恢复现场，并返回至用户态，即返回至 msyscall ➡<br>__mysyscall</em></em>，执行<code>jr $ra</code>，返回上层，继续用户态进程执行。</p><p>整体系统调用流程，或者说异常处理流程如上。</p><h3 id="Fork函数流程"><a href="#Fork函数流程" class="headerlink" title="Fork函数流程"></a>Fork函数流程</h3><p>fork函数作用为在当前进程下创建一个子进程，流程如下(不得不说课程组的流程图制作的很用心，感动坏了)。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB4_7.jpg" alt></p><p><strong>sys_exofork</strong>:</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB4_9.jpg" alt></p><p>该函数申请一个进程块，并为子进程初始化基本信息，包括继承父进程优先级，设置进程状态等，其中<strong>e-&gt;env_tf.reg[2]=0，即设置该进程块Trapframe($V0)处为0，这点是区分父子进程最关键的地方</strong>，由于子进程将当前Trapframe拷贝进进程块中，而Trapframe中Epc的位置即返回到用户态的位置，所以<strong>结合LAB3，当子进程被调度时将直接执行返回用户态后的第一条语句，即将返回值$v0=0赋值给child，而父函数会执行sys_exofork至结束并返回子进程id，由此区分出来了父子进程</strong>。</p><p><strong>fork</strong>:</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB4_8.jpg" alt></p><p>进程调用fork函数，首先为父进程设置写时复制函数，并执行syscall_exofork函数创建出还无法调度的子进程，接着为父子进程页表通过COW位设置写时复制机制，最后为子进程设置写时复制函数并使子进程就绪，等待对子进程的调度。</p><h3 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h3><p>经由fork设置，当父子进程在运行时首次写写时复制页面时，会陷入内核触发tlb_mod异常，但该异常处理仅是设置了参数并将其交给用户态的cow_entry函数真正处理。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB4_10.jpg" alt></p><p>在cow_entry中，使用了UCOW实现了<strong>间接复制</strong>，即将新分配的物理页面与UCOW映射，并通过memcpy将va拷贝到UCOW中，再使用syscall_mem_map将va与UCOW映射到同一物理页面并最后解除物理页面与UCOW的映射，经过一波互换操作完成了va与另一个与原先内容一致的物理页面的映射。</p><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>由于在LAB5中大量使用到进程间通信，在此简要说明，主要由发送和接受两个函数实现。</p><p><strong>sys_ipc_recv</strong>:</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB4_11.jpg" alt></p><p>接受方进程(文件服务进程)采用轮询的方式调用该函数，传递进待映射的虚拟地址，在该函数中，将等待发送位置1，同时阻塞该进程，移除调度队列，并立即调度其他进程，等待发送进程进行信息的发送。</p><p><strong>sys_ipc_send</strong>:</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB4_12.jpg" alt></p><p>发送方进程将接收方进程Id，待发送的值，待映射的虚拟地址，权限位传入该函数，首先检验接收方进程的等待发送位，若为0，则调度其他进程，等待轮转到发送方进程时再次尝试发送，若为1，则进行value的传递和页面的映射(若发送方虚拟地址为0代表只传递value)，并将接受方进程解除阻塞，重新加入到调度队列中。通过内核态实现了对非本进程的地址的映射以及进程控制块的修改，当调度到接收进程时，该进程已经收到了发送方进程传来的信息。</p><p>补充：当要复制另一个物理页面并建立用户虚拟地址与一个新物理页面的映射时，我们通常采用将新物理页面转化为内核态虚拟地址 page2kva，再使用memcpy拷贝，最后将新物理页面与用户虚拟地址映射page_insert。</p><h2 id="三-心得体会"><a href="#三-心得体会" class="headerlink" title="三.心得体会"></a>三.心得体会</h2><p>LAB4主要完成了系统调用相关函数的实现，并完成了一个巨大无比的fork函数的实现，数十个函数相互调用配合，一环套一环，有共同之处，比如陷入内核分发异常以及返回用户态的流程，但是更多的是不同，如分发异常后继续分发系统调用码以及种种，复杂度较之前大幅度提高，且debug难度也直线上升，笔者包括实验报告总计用时15小时左右，且写文章至此身心俱疲，渴望睡觉。</p><p>不得不说每次写实验报告都要花比写LAB更多的时间，写代码时总是关注着把当前函数写的无纰漏，最多考虑前后的一两个函数调用搭配，而写实验报告时则要关注整体的流程以及给出的代码中隐藏的细节，当静下心来细细思考时，仔细研读给出的每一行代码时，才会更加大悟操作系统的魅力，笔者愚笨，学到如今只觉得震撼。</p><p>晚安世界🌙。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『操作系统』操作系统实验LAB3——进程管理</title>
      <link href="/post/9af66719.html"/>
      <url>/post/9af66719.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『操作系统』操作系统实验LAB3——进程管理"><a href="#『操作系统』操作系统实验LAB3——进程管理" class="headerlink" title="『操作系统』操作系统实验LAB3——进程管理"></a>『操作系统』操作系统实验LAB3——进程管理</h1><h2 id="一-思考题"><a href="#一-思考题" class="headerlink" title="一. 思考题"></a>一. 思考题</h2><h4 id="Question1-请结合-MOS-中的页目录自映射应用解释代码中-e-gt-env-pgdir-PDX-UVPT-PADDR-e-gt-env-pgdir-PTE-V-的含义。"><a href="#Question1-请结合-MOS-中的页目录自映射应用解释代码中-e-gt-env-pgdir-PDX-UVPT-PADDR-e-gt-env-pgdir-PTE-V-的含义。" class="headerlink" title="Question1. 请结合 MOS 中的页目录自映射应用解释代码中 e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V 的含义。"></a>Question1. 请结合 MOS 中的页目录自映射应用解释代码中 e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_V 的含义。</h4><p>UVPT是kuseg中保存用户（当前进程）页表信息的虚拟内存区，大小为4MB（0x7fc00000-0x80000000），PDX(UVPT)取UVPT前10位，代表着UVPT位于第几个4MB内存区，而e-&gt;env_pgdir[PDX(UVPT)]即当前进程的页目录的第PDX(UVPT)项，写入当前页目录的物理地址并置入有效位，意义即完成自映射，当访问UVPT这一虚拟地址时，通过页表转换，可以得到页目录的物理地址。</p><h4 id="Question2-elf-load-seg-以函数指针的形式，接受外部自定义的回调函数-map-page。-请你找到与之相关的-data-这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？"><a href="#Question2-elf-load-seg-以函数指针的形式，接受外部自定义的回调函数-map-page。-请你找到与之相关的-data-这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？" class="headerlink" title="Question2. elf_load_seg 以函数指针的形式，接受外部自定义的回调函数 map_page。 请你找到与之相关的 data 这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？"></a>Question2. elf_load_seg 以函数指针的形式，接受外部自定义的回调函数 map_page。 请你找到与之相关的 data 这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？</h4><p>data来自kern/env.c的load_icode函数中，他的作用在于传递当前的进程块结构体的指针。我认为没有这个参数不可以，因为lib/elfloader.c中elf_load_seg还需要将data传递给map_page函数中(即load_icode_mapper)，涉及到跨文件的指针传递，作为参数传递应该是最好的选择。<br><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB3_2.jpg" alt><br><img src="/post/9af66719/Users\大二下\OS\LAB3\LAB3_3.jpg" alt="LAB3_1"><br><img src="/post/9af66719/Users\大二下\OS\LAB3\LAB3_1.jpg" alt="LAB3_1"></p><h4 id="Question3-结合-elf-load-seg-的参数和实现，考虑该函数需要处理哪些页面加载的情况。"><a href="#Question3-结合-elf-load-seg-的参数和实现，考虑该函数需要处理哪些页面加载的情况。" class="headerlink" title="Question3. 结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情况。"></a>Question3. 结合 elf_load_seg 的参数和实现，考虑该函数需要处理哪些页面加载的情况。</h4><p>一共要考虑va，va+bin_size,va+sg_size三个地址和对齐的一页的位置关系。(借用一下H哥的图)</p><p><strong>va和va+bin_size一共有六种情况</strong></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB3_4.png" alt></p><p><strong>va+bin_size和va+sg_size一共有六种情况</strong></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB3_5.png" alt></p><h4 id="Question4-你认为这里的-env-tf-cp0-epc-存储的是物理地址还是虚拟地址"><a href="#Question4-你认为这里的-env-tf-cp0-epc-存储的是物理地址还是虚拟地址" class="headerlink" title="Question4. 你认为这里的 env_tf.cp0_epc 存储的是物理地址还是虚拟地址?"></a>Question4. 你认为这里的 env_tf.cp0_epc 存储的是物理地址还是虚拟地址?</h4><p>虚拟地址，用户进程接触到的地址都应该是虚拟地址。</p><h4 id="Question5-试找出上述-5-个异常处理函数的具体实现位置。"><a href="#Question5-试找出上述-5-个异常处理函数的具体实现位置。" class="headerlink" title="Question5. 试找出上述 5 个异常处理函数的具体实现位置。"></a>Question5. 试找出上述 5 个异常处理函数的具体实现位置。</h4><p>0号异常的处理函数为handle_int，在kern/genex.S中实现。<img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB3_6.jpg" alt></p><p>1号异常的处理函数为handle_mod，23号异常的处理函数为handle_tlb，8号异常的处理函数为handle_sys，都是通过genex.S文件中的宏函数BUILD_HANDLER实现的</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB3_9.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB3_7.jpg" alt></p><h4 id="Question6-阅读-init-c、kclock-S、env-asm-S-和-genex-S-这几个文件，并尝试说出enable-irq-和-timer-irq-中每行汇编代码的作用。"><a href="#Question6-阅读-init-c、kclock-S、env-asm-S-和-genex-S-这几个文件，并尝试说出enable-irq-和-timer-irq-中每行汇编代码的作用。" class="headerlink" title="Question6. 阅读 init.c、kclock.S、env_asm.S 和 genex.S 这几个文件，并尝试说出enable_irq 和 timer_irq 中每行汇编代码的作用。"></a>Question6. 阅读 init.c、kclock.S、env_asm.S 和 genex.S 这几个文件，并尝试说出enable_irq 和 timer_irq 中每行汇编代码的作用。</h4><p><strong>enable_irq</strong>：<br><img src="/post/9af66719/Users\大二下\OS\LAB3\LAB3_10.jpg" alt="1"></p><p><strong>timer_irq</strong>:<br><img src="/post/9af66719/Users\大二下\OS\LAB3\LAB3_11.jpg" alt="1"></p><h4 id="Question7-阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的。"><a href="#Question7-阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的。" class="headerlink" title="Question7. 阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的。"></a>Question7. 阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的。</h4><p>env_sched_list 有一个双向队列存放就绪进程。当进程被创建时，我们将其插入队列的头部。</p><p>当时钟中断来临时，陷入内核，内核经由 handle_int 分配给 schedule 函数调度进程。首先让当前进程的时间片减1，然后有四种情况需要切换进程。</p><ul><li>当前进程为空</li><li>当前进程剩余时间片为0</li><li>yield 不为0</li><li>当前进程不再处于就绪状态</li></ul><p>若切换进程，且当前进程不为空，则将当前进程在 env_sched_list 队列头部移除，若仍处于就绪状态，则再将其插入队列的尾部。接着依据当前队列头部进程的优先级分配新的时间片(即一常数)，并运行该头部进程。若不需切换进程，则运行原本进程即可。</p><p>运行进程即 env_run，在 env_run 中，完成下述操作完成进程切换的预备工作。在用户空间KSTACKTOP以下的一个 <code>sizeof(TrapFrame)</code>用来保护当前进程的上下文信息。</p><ol><li>保存当前进程的上下文信息。</li><li>切换 curenv 为即将运行的进程。</li><li>设置全局变量 cur_pgdir 为当前进程页目录地址，在 TLB 重填时将用到该全局变量。</li><li>调用 env_pop_tf 函数，env_pop_tf 再调用 ret_from_exception 函数，恢复现场、异常返回。</li></ol><p>最后回归到用户态，执行切换后的进程的代码(若没有切换进程也会调用 env_run，只不过保存现场等操作做了一番无用功罢了)。<br><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB3_13.jpg" alt></p><h2 id="二-实验难点分析"><a href="#二-实验难点分析" class="headerlink" title="二. 实验难点分析"></a>二. 实验难点分析</h2><p>我认为本次实验的难点与LAB2相似，即理解清楚各函数间的调用关系以及理解这些函数组合起来完成最终的用途是本实验的最大难点。大致分为两部分，<strong>进程的建立</strong>与<strong>进程的切换与调度</strong>。借用指导书的图进行细致分析。<br><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/LAB3_12.jpg" alt></p><h3 id="进程的建立"><a href="#进程的建立" class="headerlink" title="进程的建立"></a>进程的建立</h3><p>本LAB进程的建立发生在内核的初始化过程中，即在初始化内核的同时完成了两个进程的建立，步骤如下。</p><ol><li>通过 env_init 函数完成进程控制块的初始化，完成空闲进程块链表和调度队列的初始化，并且完成模板页表的构建。</li><li>调用 env_create 函数完成一个进程的创建，具体来说首先通过 env_alloc 申请一个空闲PCB，完成参数初始化，并通过 env_setup_vm 函数完成进程页表初始化与自映射。</li><li>调用 load_icode 等一系列函数将二进制ELF文件加载进进程虚拟空间中，最后将该PCB装入调度队列中，准备调度。</li><li>时钟初始化并开启时钟中断，等待第一个时钟中断来临，开始第一次的进程调度。</li></ol><h3 id="进程的切换与调度"><a href="#进程的切换与调度" class="headerlink" title="进程的切换与调度"></a>进程的切换与调度</h3><p>详情参见思考题7。</p><h2 id="三-实验感受"><a href="#三-实验感受" class="headerlink" title="三. 实验感受"></a>三. 实验感受</h2><p>LAB3我们主要完成了进程的初始化，异常中断处理与时间片调度的操作，综合感受下来较LAB2简单一些。</p><p>本次实验总计用时7~8小时，主要在两个地方出现了Bug并折磨许久，其一是申请asid时传入的未经初始化的指针会报错，无法获得asid，但是提前初始化好指针又不够优雅，为此我重新学习了一遍C语言指针传参相关的内容，收获甚微。我最后认为可能是由于编译器版本的问题，DEVC上运行便能正常传参，因此最后还是无奈选择了先随便初始化后再传入指针的方法。其二是在进程调度时仅考虑了需要进程切换的情况，忽视了无需切换进程时也应让当前进程继续运行的操作，导致运行结果永远只有一行。当我发现了只有env_run才能使其从内核态返回用户态时，该问题也便迎刃而解了。</p><p>总体而言，本次LAB3令我收获颇丰，理解了进程的相关操作，并动手实践完成了代码。然而在为进程初始化虚拟空间时，对于虚拟空间和虚实转化的一些知识仍然抱有疑问，比如为什么页p总是可以使用page2kva转化为内核虚拟地址。笔者将在日后的学习过程中继续钻研，争取早日开悟操作系统。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『操作系统』操作系统实验LAB2——内存管理</title>
      <link href="/post/89db82dc.html"/>
      <url>/post/89db82dc.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『操作系统』操作系统实验LAB2——内存管理"><a href="#『操作系统』操作系统实验LAB2——内存管理" class="headerlink" title="『操作系统』操作系统实验LAB2——内存管理"></a>『操作系统』操作系统实验LAB2——内存管理</h1><h2 id="一-思考题"><a href="#一-思考题" class="headerlink" title="一. 思考题"></a>一. 思考题</h2><h4 id="Question1-在编写的C程序中，指针变量中存储的地址是虚拟地址，还是物理地址？MIPS-汇编程序中-lw-和-sw-使用的是虚拟地址，还是物理地址？"><a href="#Question1-在编写的C程序中，指针变量中存储的地址是虚拟地址，还是物理地址？MIPS-汇编程序中-lw-和-sw-使用的是虚拟地址，还是物理地址？" class="headerlink" title="Question1: 在编写的C程序中，指针变量中存储的地址是虚拟地址，还是物理地址？MIPS 汇编程序中 lw 和 sw 使用的是虚拟地址，还是物理地址？"></a>Question1: 在编写的C程序中，指针变量中存储的地址是虚拟地址，还是物理地址？MIPS 汇编程序中 lw 和 sw 使用的是虚拟地址，还是物理地址？</h4><p>代码在CPU内执行时得到的都是虚拟地址。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008144332608.png" alt></p><h4 id="Question2-从可重用性的角度，阐述用宏来实现链表的好处。查看实验环境中的-usr-include-sys-queue-h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。"><a href="#Question2-从可重用性的角度，阐述用宏来实现链表的好处。查看实验环境中的-usr-include-sys-queue-h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。" class="headerlink" title="Question2: 从可重用性的角度，阐述用宏来实现链表的好处。查看实验环境中的 /usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。"></a>Question2: 从可重用性的角度，阐述用宏来实现链表的好处。查看实验环境中的 /usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。</h4><p>用宏实现链表，主要是可以模拟出C语言不具有的泛型功能。因为宏的实现方式是字符串替换，替换时不会考虑到语法等等问题，因此只要给好参数，则任何结构体的链表均能由一组宏统一实现，简单便捷。</p><p><strong>插入操作(考虑先寻找，再插入)</strong></p><ul><li><p>双向链表:头部插入O(1)，尾部插入O(n)，指定节点前O(1)，指定节点后O(1)</p></li><li><p>单向链表:头部插入O(1)，尾部插入O(n)，指定节点前O(n)，指定节点后O(1)</p></li><li><p>双向循环链表:头部插入O(1)，尾部插入O(1)，指定节点前O(1，指定节点后O(1)</p></li></ul><p><strong>删除操作:</strong></p><ul><li><p>双向链表：头部节点删除O(1)，尾部节点删除O(n)，指定节点删除O(1)</p></li><li><p>单向链表: 头部节点删除O(1)，尾部节点删除O(n)，指定节点删除O(n)</p></li><li><p>双向循环链表: 头部节点删除O(1)，尾部节点删除O(1)，指定节点删除O(1)</p></li></ul><h4 id="Question3-请阅读-include-queue-h-以及-include-pmap-h-将-Page-list-的结构梳理清楚，选择正确的展开结构。"><a href="#Question3-请阅读-include-queue-h-以及-include-pmap-h-将-Page-list-的结构梳理清楚，选择正确的展开结构。" class="headerlink" title="Question3: 请阅读 include/queue.h 以及 include/pmap.h, 将 Page_list 的结构梳理清楚，选择正确的展开结构。"></a>Question3: 请阅读 include/queue.h 以及 include/pmap.h, 将 Page_list 的结构梳理清楚，选择正确的展开结构。</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008144556916.png" alt></p><p>选C，Page_list是Page结构体的头指针，里面包含一个指向Page结构体的指针即lh_first，Page结构体由引用次数pp_ref和链表项pp_link组成，故选C。</p><h4 id="Question4-请阅读上面有关-R3000-TLB-的描述，从虚拟内存的实现角度，阐述-ASID-的必要性。请阅读《IDT-R30xx-Family-Software-Reference-Manual》的-Chapter-6，结合-ASID段的位数，说明-R3000-中可容纳不同的地址空间的最大数量。"><a href="#Question4-请阅读上面有关-R3000-TLB-的描述，从虚拟内存的实现角度，阐述-ASID-的必要性。请阅读《IDT-R30xx-Family-Software-Reference-Manual》的-Chapter-6，结合-ASID段的位数，说明-R3000-中可容纳不同的地址空间的最大数量。" class="headerlink" title="Question4: 请阅读上面有关 R3000-TLB 的描述，从虚拟内存的实现角度，阐述 ASID 的必要性。请阅读《IDT R30xx Family Software Reference Manual》的 Chapter 6，结合 ASID段的位数，说明 R3000 中可容纳不同的地址空间的最大数量。"></a>Question4: 请阅读上面有关 R3000-TLB 的描述，从虚拟内存的实现角度，阐述 ASID 的必要性。请阅读《IDT R30xx Family Software Reference Manual》的 Chapter 6，结合 ASID段的位数，说明 R3000 中可容纳不同的地址空间的最大数量。</h4><p>ASID称作是地址空间，每个用户进程有一个专属的ASID码，用来区分不同进程。由于每个进程都有自己的虚拟地址空间且相同，在MIPS上都是0-4G,因此进程间会使用到相同的虚拟地址，但实际上他们对应的是不同的物理地址，若此刻不增加标志位来区分不同进程，TLB便分不出来不同的进程，出现严重错误，当然也可以每切换一次进程刷新所有TLB重新装填，但是这样效率会大大降低。</p><p>ASID共六位，一共最多容纳64个地址空间。</p><h4 id="Question5-tlb-invalidate-和-tlb-out-的调用关系？请用一句话概括-tlb-invalidate-的作用。逐行解释-tlb-out-中的汇编代码。"><a href="#Question5-tlb-invalidate-和-tlb-out-的调用关系？请用一句话概括-tlb-invalidate-的作用。逐行解释-tlb-out-中的汇编代码。" class="headerlink" title="Question5: tlb_invalidate 和 tlb_out 的调用关系？请用一句话概括 tlb_invalidate 的作用。逐行解释 tlb_out 中的汇编代码。"></a>Question5: tlb_invalidate 和 tlb_out 的调用关系？请用一句话概括 tlb_invalidate 的作用。逐行解释 tlb_out 中的汇编代码。</h4><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008144652707.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008144657722.png" alt></p><p>tlb_out 被 tlb_invalidate 调用，tlb_invalidate的作用是删除特定ASID码的虚拟地址在 TLB 中的旧表项。</p><p>PTE_ADDR作用是清空va虚拟地址后十二位偏移位，接着与位移到6到11位的ASID码进行拼接，生成TLB的Key部分，如下图。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008144740612.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008144816947.png" alt></p><p>结合相关指令,按行解读tlb_out代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mfc0  t0, CP0_ENTRYHI <span class="comment"># 将原EntryHi寄存器内容取出</span></span><br><span class="line">mtc0  a0, CP0_ENTRYHI <span class="comment"># 将tlb_invalidate向其传递的参数a0(这一步在编译器种执行)写进EntryHi寄存器</span></span><br><span class="line">tlbp <span class="comment"># 根据EntryHi中的Key查找对应的Value，并将查到的表项索引存入Index寄存器</span></span><br><span class="line">mfc0  t1, CP0_INDEX <span class="comment"># 将Index寄存器值存入t1寄存器</span></span><br><span class="line">bltz  t1, NO_SUCH_ENTRY <span class="comment"># 判断t1是否为负数，若为负数，意味着无对应表项，也就不需要清空，跳转到NO_SUCH_ENTRY。若不为负数，意味着查到表项，继续执行。</span></span><br><span class="line">mtc0  zero, CP0_ENTRYHI <span class="comment"># 将EntryHi清空</span></span><br><span class="line">mtc0  zero, CP0_ENTRYLO0 <span class="comment"># 将EntryLow清空</span></span><br><span class="line">tlbwi <span class="comment"># 根据上面Index查到的索引，用清空后的Hi和Low对相应表项清空，完成表项无效化操作。</span></span><br></pre></td></tr></table></figure><h4 id="Question6-在现代的-64-位系统中，提供了-64-位的字长，但实际上不是-64-位页式存储系统。假设在-64-位系统中采用三级页表机制，页面大小-4KB。由于-64-位系统中字长为8B，且页目录也占用一页，因此页目录中有-512-个页目录项，因此每级页表都需要-9-位。因此在-64-位系统下，总共需要-3-×-9-12-39-位就可以实现三级页表机制，并不需要-64位。现考虑上述-39-位的三级页式存储系统，虚拟地址空间为-512-GB，若三级页表的基地址为-PTbase，请计算："><a href="#Question6-在现代的-64-位系统中，提供了-64-位的字长，但实际上不是-64-位页式存储系统。假设在-64-位系统中采用三级页表机制，页面大小-4KB。由于-64-位系统中字长为8B，且页目录也占用一页，因此页目录中有-512-个页目录项，因此每级页表都需要-9-位。因此在-64-位系统下，总共需要-3-×-9-12-39-位就可以实现三级页表机制，并不需要-64位。现考虑上述-39-位的三级页式存储系统，虚拟地址空间为-512-GB，若三级页表的基地址为-PTbase，请计算：" class="headerlink" title="Question6: 在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存储系统。假设在 64 位系统中采用三级页表机制，页面大小 4KB。由于 64 位系统中字长为8B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表都需要 9 位。因此在 64 位系统下，总共需要 3 × 9 + 12 = 39 位就可以实现三级页表机制，并不需要 64位。现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若三级页表的基地址为 PTbase，请计算："></a>Question6: 在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存储系统。假设在 64 位系统中采用三级页表机制，页面大小 4KB。由于 64 位系统中字长为8B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表都需要 9 位。因此在 64 位系统下，总共需要 3 × 9 + 12 = 39 位就可以实现三级页表机制，并不需要 64位。现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若三级页表的基地址为 PTbase，请计算：</h4><p>• 三级页表页目录的基地址。<br>• 映射到页目录自身的页目录项（自映射）。</p><p>首先正如二级页表结构里页目录的自映射一样，三级页表结构中，512张二级页表一定有一张正是一级页表，而每张二级页表对应的512张三级页表也一定有一张正是二级页表，因此总共有$512<em>512</em>512=128M$页表项，每个页表项对应着4KB大小的页面，共512GB。</p><p>三级映射要经历三步。PTbase对应的⻚表项是第$PTbase&gt;&gt;12$个，⽽每个⻚表有512个⻚⽬录项，每个⻚表项的⼤⼩是8B（⻚⾯⼤⼩ 4KB，有512个⻚表项），所以PTbase在三级⻚表区中对应的偏移量是$PTbase&gt;&gt;9$。记作⼆级⻚表项基地址。</p><p>然后，三级⻚表区（1G）映射到⼆级⻚表区（$512*512=256K$个8B⻚表项，共2M⼤⼩）。每个⻚表项映射了4K的空间，则⼆级⻚表区基地址对应的⻚表项是第$(PTbase&gt;&gt;9)&gt;&gt;12$个，所以⼆级⻚表区基地址在⼆级⻚表区中对应的偏移量是$(PTbase&gt;&gt;9)&gt;&gt;9$。记作⼀级⻚表基地址。 </p><p>最后，⼆级⻚表区（2M）映射到⼀级⻚表（512个8B⻚表项，4K⼤⼩）。每个⻚表项映射了4K的空间，则⼀级⻚表基地址对应的⻚表项是第$(PTbase&gt;&gt;18)&gt;&gt;12$个，所以⼀级⻚表基地址在⼀级⻚表⾃⾝中对应的偏移量是$(PTbase&gt;&gt;18)&gt;&gt;9$。 </p><p>那么，三级⻚表⻚⽬录（即⼀级⻚表）的基地址为 $PTbase + (PTbase&gt;&gt;9) + (PTbase&gt;&gt;18) $;</p><p>映射到⻚⽬录⾃⾝的⻚⽬录项是 $PTbase + (PTbase&gt;&gt;9) + (PTbase&gt;&gt;18) + (PTbase&gt;&gt;27)$</p><h4 id="Question7-简单了解并叙述-X86-体系结构中的内存管理机制，比较-X86-和-MIPS-在内存管理上的区别。"><a href="#Question7-简单了解并叙述-X86-体系结构中的内存管理机制，比较-X86-和-MIPS-在内存管理上的区别。" class="headerlink" title="Question7: 简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别。"></a>Question7: 简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别。</h4><p>x86架构的内存管理机制分为两部分：分段机制和分⻚机制。 而Mips架构是单纯的分页机制。</p><p>分段机制为程序提供彼此隔离的代码区域、数据区域、栈区域，从⽽避免了同⼀个处理器上运⾏的多个程序互相影响。分⻚机制实现了传统的按需分⻚、虚拟内存机制，可以将程序的执⾏环境按需映射到物理内存。此外，分⻚机制还可以⽤于提供多任务的隔离。X86处理器⽆论在何种运⾏模式下都不可以禁⽌分段机制，但是分⻚机制却是可选选项。</p><p>针对分段机制而言，分段相当于完成了虚拟地址到线性地址的转化，x86架构提供了两种段描述符表：<strong>GDT</strong>（全局段描述符表Global Descriptor Table）和<strong>LDT</strong> （本地段描述符表Local Descriptor Table）。其中GDT描述系统段，包括操作系统本⾝；LDT描述局部于每个系统的段，包括其代码、数据、堆栈等，可以将GDT当作一级段表，LDT看作二级段表。当需要访问一个段时，需要将该段的选择子装进段寄存器中，对应的描述符从GDT或LDT取出。</p><p>若开启分页机制，则将得到的线性地址解释成页目录偏移+二级页表偏移+页内偏移，像是纯分页机制中的“虚拟地址”继续通过页表得到实际地址。若不开启分页机制，则得到的线性地址就是物理地址。</p><h2 id="二-实验难点"><a href="#二-实验难点" class="headerlink" title="二. 实验难点"></a>二. 实验难点</h2><p>本次实验重点在于对内存管理机制的初始化工作，对物理内存分页，并对页面实现申请与删除，并完成了一些与页表相关的函数。我认为pmap.c中页表函数是本次实验的难点，接下来我将依次梳理一下各个函数的用途与实现思路，并总结这些函数搭配使用产生的最终效果。</p><p>首先是物理页面的创建与构建空闲页面双向链表，难点在于链表宏的实现，需要用到数据结构的相关知识，前插后插需要分四步，每一步的顺序至关重要，以后插为例，elm为待插入元素，listelm为当前元素，先判断listelm后是否还有元素，若无则直接尾插即可，若有则如下图四步执行(画的略难看)，特别要注意指针的指针存的是指针的地址，即le_prev存的是le_next的地址，应使用le_prev = &amp;le_next。在构建页面时应按Page结构体物理地址从低到高与对应的物理页面地址从低到高对应。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008145312074.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008150409743.png" alt></p><p>接下来是对几个页表函数的理解。</p><p><strong>Page_walk</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008145436746.png" alt></p><p>给定虚拟地址，查找页目录，若能查到相应的二级页表，将va 虚拟地址所在的二级页表项的指针存储在 ppte 指向的空间上，若没查到，则建立二级页表，完成对页表页面的初始化，即引用次数置为1，后续操作同。</p><p><strong>Page_insert</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008145459210.png" alt></p><p>将一级页表基地址 pgdir 对应的两级页表结构中虚拟地址 va 映射到页控制块 pp 对应的物理页面，若va在页表中无相应二级页表则使用page_walk创建，若va在二级页表中对应的物理页面跟本次设置的不同，则需要清空tlb并重写二级页表，最后将对应的物理页面号填到二级页表当中，并设置权限。</p><p><strong>Page_look</strong>:</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008145510157.png" alt></p><p>作用是返回一级页表基地址 pgdir 对应的两级页表结构中虚拟地址 va 映射的物理页面的页控制块，同时将 ppte 指向的空间设为对应的二级页表项地址,若无则返回null，主要是用来配合tlb重填函数。</p><p>这一切的一切当发生缺页异常时，OS将执行如下步骤。</p><ol><li>从 BadVAddr 中取出引发 TLB 缺失的虚拟地址。</li><li>从 EntryHi 的6–11 位取出当前进程的 ASID。</li><li>以虚拟地址和 ASID 为参数，调用 _do_tlb_refill 函数。该函数是 TLB 重填过程的核心，其功能是根据虚拟地址和 ASID 使用look函数查找页表，若查找不到则会利用页面申请函数来申请一个物理页面，并使用insert函数将物理页面号存入页表之中，在insert和look的过程中又会调用walk函数查找二级页表项存不存在，直至look函数返回不为null。</li><li>将物理地址存入 EntryLo , 并执行 tlbwr 将此时的 EntryHi 与 EntryLo 写入到 TLB 中。</li></ol><p>以上函数间的调用关系便非常清晰明了，且我们发现这些页表函数<strong>统一服务于tlb重填操作</strong>，在重填的操作过程中，完成了页表的建立。</p><h2 id="三-实验感受"><a href="#三-实验感受" class="headerlink" title="三. 实验感受"></a>三. 实验感受</h2><p>在Lab2中，我们首次接触到了如此大型的程序，头文件C文件汇编文件应有尽有无一缺席，各种文件之间的配合也是令人眼花缭乱。在笔者拿到之初，一度无从下手，令人不禁翻看往届学长的代码，不过最后及时收手，想着还是自己先挑战挑战。最让人记忆犹新的是写page_walk，page_insert那个夜晚，因为create的逻辑问题，debug一度de到破防，甚至在怀疑是不是真出现了以前Lab写错的情况发生，de到在主楼沙发上撒泼打滚，好在我的朋友乐于助人，在一个个文件的来回切换中，最终锁定了问题，当时已然临近11点。好在第三部分的内容简单，Lab2实验部分在高潮之后很快便迎来尾声。不过想要理清内存管理的逻辑有些困难，想必有许多同学在写代码时只是单纯的根据提示去写，没有思考内在的逻辑，笔者也是在之后又继续翻阅指导书与代码才大致弄清逻辑。</p><p>总的来说本次实验是一次具有挑战感与收获感的实验，随着一遍遍阅读内核代码，笔者对于OS的原理也是愈发清晰，也愈发明白为什么说写OS的程序员都是最优秀的程序员了。</p><p><strong>Lab3冲冲冲！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『操作系统』操作系统实验LAB1——ELF文件,Printk</title>
      <link href="/post/50536630.html"/>
      <url>/post/50536630.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『操作系统』操作系统实验LAB1——ELF文件-Printk"><a href="#『操作系统』操作系统实验LAB1——ELF文件-Printk" class="headerlink" title="『操作系统』操作系统实验LAB1——ELF文件,Printk"></a>『操作系统』操作系统实验LAB1——ELF文件,Printk</h1><h2 id="一-思考题"><a href="#一-思考题" class="headerlink" title="一. 思考题"></a>一. 思考题</h2><h4 id="Question1-请阅读附录中的编译链接详解，尝试分别使用实验环境中的原生x86工具链（gcc、ld、readelf、objdump-等）和MIPS交叉编译工具链（带有-mips-linux-gnu-前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向-objdump-传入的参数的含义。"><a href="#Question1-请阅读附录中的编译链接详解，尝试分别使用实验环境中的原生x86工具链（gcc、ld、readelf、objdump-等）和MIPS交叉编译工具链（带有-mips-linux-gnu-前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向-objdump-传入的参数的含义。" class="headerlink" title="Question1: 请阅读附录中的编译链接详解，尝试分别使用实验环境中的原生x86工具链（gcc、ld、readelf、objdump 等）和MIPS交叉编译工具链（带有 mips-linux-gnu-前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向 objdump 传入的参数的含义。"></a>Question1: 请阅读附录中的编译链接详解，尝试分别使用实验环境中的原生x86工具链（gcc、ld、readelf、objdump 等）和MIPS交叉编译工具链（带有 mips-linux-gnu-前缀），重复其中的编译和解析过程，观察相应的结果，并解释其中向 objdump 传入的参数的含义。</h4><p>原生环境是基于x86架构下的，而运用MIPS交叉编译工具则是虚拟了一个MIPS架构环境，编译链接反汇编等建立在MIPS架构下，二者有很大不同。</p><p>对于Helloworld文件，下图是用GCC编译后的结果:</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008120611059.png" alt></p><p>下图是使用交叉编译器后的结果:</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008120618885.png" alt></p><p><code>objdump</code>是反汇编命令，观察LAB1内Makefile的<code>objdump</code>部分，有一些常用的参数如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objdump [command]</span><br><span class="line">-a ## 显示档案库的成员信息,类似ls -l将lib*.a的信息列出。 </span><br><span class="line">-l --line-numbers ## 用文件名和行号标注相应的目标代码</span><br><span class="line">-d ## 从objfile中反汇编那些特定指令机器码的section。 </span><br><span class="line">-D --disassemble-all ## 与 -d 类似，但反汇编所有section. </span><br><span class="line">-s --full-contents ## 显示指定section的完整内容。默认所有的非空section都会被显示。</span><br></pre></td></tr></table></figure><p> 一般而言，我们使用 <code>objdump -alds &lt;目标文件或可执行文件名&gt; -o &lt;得到的反汇编文件&gt;</code> 即可满足需求。</p><h4 id="Question2-思考下述问题"><a href="#Question2-思考下述问题" class="headerlink" title="Question2: 思考下述问题"></a>Question2: 思考下述问题</h4><p>• 尝试使用我们编写的 readelf 程序，解析之前在 target 目录下生成的内核 ELF 文件。<br>• 也许你会发现我们编写的 readelf 程序是不能解析 readelf 文件本身的，而我们刚才介绍的系统工具 readelf 则可以解析，这是为什么呢？</p><p>内核的节头地址如下图所示:</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008120840274.png" alt></p><p>用真正的<code>readelf -h</code>来查看我们编写的readelf头：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008120846976.png" alt></p><p>再来查看hello的头:</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008120858669.png" alt></p><p>Hello的Makefile如图所示,注意参数<code>-m32</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008120913079.png" alt></p><p>节选自<code>readelf.c</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008120931928.png" alt></p><p>综上分析，Hello在编译的过程中定义了类别为ELF32，而readelf的类别为ELF64，而可以看到readelf解析的是ELF32类别的文件，因此readelf无法解析它自身。</p><h4 id="Question3：在理论课上我们了解到，MIPS-体系结构上电时，启动入口地址为-0xBFC00000（其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？"><a href="#Question3：在理论课上我们了解到，MIPS-体系结构上电时，启动入口地址为-0xBFC00000（其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？" class="headerlink" title="Question3：在理论课上我们了解到，MIPS 体系结构上电时，启动入口地址为 0xBFC00000（其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？"></a>Question3：在理论课上我们了解到，MIPS 体系结构上电时，启动入口地址为 0xBFC00000（其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？</h4><p>我们在kernel.lds中设置好了各个节被加载的位置，即最终的 segment地址，同时使用了 ENTRY(_start)指定了程序入口（即内核入口）。而在stage1和2阶段时由bootloader掌管执行，在完成必要的初始化后，会将内核引导装填进内存中的指定位置(即lds中设置好的各个节被加载的位置)，最后将PC指向_start内核入口处，将控制权交给内核, 最终保证了内核入口能够被正确跳转。</p><h2 id="二-实验难点"><a href="#二-实验难点" class="headerlink" title="二. 实验难点"></a>二. 实验难点</h2><p>本次实验难点有二，其一是有关ELF文件的理解，其二是填写printk函数。</p><h3 id="ELF文件"><a href="#ELF文件" class="headerlink" title="ELF文件"></a>ELF文件</h3><ul><li><p>引用教程中的一张图，重点在于理解ELF文件内部的结构，首先一个满足条件的程序(可执行，共享，目标)即对应了一个ELF文件，他的主要组成包括:</p><ul><li><strong>ELF头</strong>：由一个结构体组成，包括程序的基本信息，比如体系结构和操作系统，同时也包含了节头表和段头表相对文件的偏移量（offset）。</li><li><strong>节头表</strong>：是由数个节头结构体组成的一个结构体数组(笔者一开始便云里雾里了很久)，每个节头称为一个节头表项，有固定的size。</li><li><strong>段头表</strong>：是由数个段头结构体组成的一个结构体数组</li><li>以及各个节的代码数据内容。</li></ul><p>我们可根据ELF头地址+节头表偏移量寻到节头表的首地址，然后再根据节头表的项数和节头的size找到每个节头的首地址，再指向其对应的节地址即可。需要注意对c语言中指针的理解，将一个int型指针加1实际则是在地址上加了4，<strong>它是以数据类型的大小为单位进行计算的</strong>。同时const void*是万能指针，由它可以转化为任何类型的指针(加上强转更好)，也可由任何类型的指针转为它，因为指针本质都是一个四字节的地址。</p><p><img src="/post/50536630/Users\86166\AppData\Roaming\Typora\typora-user-images\image-20241008121201685.png" alt></p></li></ul><h3 id="Printk函数"><a href="#Printk函数" class="headerlink" title="Printk函数"></a>Printk函数</h3><ul><li><p>有关printk函数的实现：与OO中Lexer词法分析器的实现类似，开始时字符串指针处于字符串头，用指针扫描每个字符，针对扫描到的指定字符进行分析，直至指针扫描到’\0’停止。</p><p>值得注意的是在八进制，十六进制，二进制中负数皆被看作补码形式，而十进制下有关负数的处理不同，它会保留负号输出，因此若从参数列表中提取出来的为负数，则应将其绝对值进行输出，再在前面加上负号。</p></li></ul><p><img src="/post/50536630/Users\86166\AppData\Roaming\Typora\typora-user-images\image-20241008122104513.png" alt="image-20241008122104513"></p><h2 id="三-实验总结"><a href="#三-实验总结" class="headerlink" title="三. 实验总结"></a>三. 实验总结</h2><p>本次LAB1实验带我们完成了内核的启动，readelf文件的编写，以及printk函数的实现，相比较LAB0，可以说这才是真正进入了操作系统世界的大门。而随着实验的深入，笔者明显察觉到的是指导书内容篇幅的增加以及读起来会有更多不理解的磕绊，同时C语言代码部分难度开始提高，令笔者不得不重新复习一年前学过的数据结构与指针等等基础知识(原来大一上了一年用处在这里)；同时做一道题依赖的文件数也变得连分屏都难以看过来，这令我不得不去尝试VScode的使用，当然还有英文注释带来不便感。然而我们更愿意相信如今苦难的背后一定是光明，克服烦躁，去享受操作系统带给我们的快乐吧！</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『操作系统』操作系统实验LAB0——Linux,Makefile,Bash</title>
      <link href="/post/3a1574c0.html"/>
      <url>/post/3a1574c0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『操作系统』操作系统实验LAB0——Git-Linux-Makefile-Bash"><a href="#『操作系统』操作系统实验LAB0——Git-Linux-Makefile-Bash" class="headerlink" title="『操作系统』操作系统实验LAB0——Git,Linux,Makefile,Bash"></a>『操作系统』操作系统实验LAB0——Git,Linux,Makefile,Bash</h1><h2 id="一-思考题"><a href="#一-思考题" class="headerlink" title="一. 思考题"></a>一. 思考题</h2><h4 id="Question1"><a href="#Question1" class="headerlink" title="Question1:"></a>Question1:</h4><p>Untracked， Staged，Modified如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008114226482.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008114152157.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008114159093.png" alt></p><p>README.txt文件在未add前，处于未跟踪的状态，在add后，处于暂存区中，即处在staged暂存状态，而在对该文件修改后且未再次add时，该文件处于已修改的状态。一旦初次跟踪该文件（add）后，除非删除该文件，否则将不会再处于未跟踪的状态，若对其进行修改，即使仍需再次add,那也是从已修改状态转移到暂存状态。</p><h4 id="Question2"><a href="#Question2" class="headerlink" title="Question2:"></a>Question2:</h4><ul><li><p>add the file: git add</p></li><li><p>stage the file: git add</p></li><li><p>commit the file: git commit -m</p></li></ul><h4 id="Question3"><a href="#Question3" class="headerlink" title="Question3:"></a>Question3:</h4><ul><li>git checkout —print.c</li><li>git checkout HEAD print.c</li><li>git rm —cached hello.txt</li></ul><h4 id="Question4"><a href="#Question4" class="headerlink" title="Question4:"></a>Question4:</h4><p>提交三次后版本信息如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008114616674.png" alt></p><p>进行第一次HEAD回退后如下图所示，可见往后回退一个版本到2。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/wps1.jpg" alt> </p><p>进行一次说明为1的哈希值回退后如下图所示，可见往后回退到版本1处。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008115505529.png" alt> </p><p>进行一次说明为3的哈希值回退后如下图所示，可见恢复到了版本3处</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008115510528.png" alt> </p><h4 id="Question5"><a href="#Question5" class="headerlink" title="Question5:"></a>Question5:</h4><p>执行第一条语句后终端回显first</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008115545711.png" alt> </p><p>执行第二条语句后打开output.txt，其中内容为second</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008115551094.png" alt> </p><p>执行第三条语句后output.txt如下图，可见原内容被覆盖掉了。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008115600887.png" alt> </p><p>执行第四条语句后output.txt如下图，可见新输出的文本追加在了原内容的后面。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008115605885.png" alt> </p><h4 id="Question6"><a href="#Question6" class="headerlink" title="Question6:"></a>Question6:</h4><ul><li><p><code>echo echo Start Shell</code> </p><ul><li>在Shell中输出 echo Start Shell</li></ul></li><li><p><code>echo &#39;echo Start Shell&#39;</code></p><ul><li>在Shell中输出 Start Shell</li></ul></li><li><p><code>echo echo $c &gt; file</code> </p><ul><li>在file中输出 echo</li></ul></li><li><p><code>echo &#39;echo $c &gt; file&#39;</code></p><ul><li>在file中无输出</li></ul></li></ul><p>为得到目标文本，command如图</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008115710704.png" alt> </p><p>Test文件如题目要求所示：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008115716337.png" alt> </p><p>将test赋予权限，作为批处理文件运行后，终端上显示：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008115722079.png" alt> </p><p>Result文件中内容为：</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008115727262.png" alt> </p><p>为创建test而在command脚本的输入中，用双引号将想要输出的文字括起来即可，注意面对“$”时应使用“\”转义。而执行test文件时，c,b,a三个参数所对应的值被存入不同的file文件中，最后再将三个文件中的内容依次重定向到result文件中，最后结果即为上图，输出3，2，1。</p><h2 id="二-难点分析"><a href="#二-难点分析" class="headerlink" title="二. 难点分析"></a>二. 难点分析</h2><p>本次lab0考察的是对于Linux命令行，Makefile，Bash脚本的基本操作编写方法，本身不算太难，其中我遇到了三个难点。</p><p>第一个难点是Makefile的嵌套调用<code>$(MAKE) -C &lt;子目录&gt;</code>，意思为调用子目录的makefile，实现类似于函数调用的机制。第二个难点在于两个object目标文件的链接，我们知道预处理只是加入了头文件的引用，然后并没有把实际内容放进来，这一步在链接操作中完成，可使用<code>gcc &lt;目标文件&gt; &lt;目标文件&gt;......</code>的方式来得到最后可执行代码。在预处理时，用到的头文件会进入系统自带的库中寻找，若该头文件是自己编写的该如何定位寻找呢，我们可以使用<code>gcc -I &lt;文件路径&gt;</code>的方式定位到手写的头文件。最后是对于各种参数的混淆与记忆不清，比如sed的各种使用方法，经常会使用错误或记不清，需要再次巩固记忆。</p><h2 id="三-实验体会"><a href="#三-实验体会" class="headerlink" title="三. 实验体会"></a>三. 实验体会</h2><p>本次LAB0实验我总共用时三小时左右，实验本身并无很硬核的难点，但由于我没有观看教学视频，导致很多东西都是在网上现学现卖，后来才得知视频中涵盖了我大部分的困惑点，以后要注意多看教程，这样才能少走弯路。同时我深感各种指令(尤其是文本指令)的繁琐，想必记忆并熟练运用好需要一点功夫，争取在闭卷的LAB0课下考试中取得优异成绩。</p><p>我的实验报告到此结束，谢谢。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『保研经历』保研经历Part3——总结与经验分享</title>
      <link href="/post/f053aa95.html"/>
      <url>/post/f053aa95.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『保研经历』保研经历Part3——总结与经验分享"><a href="#『保研经历』保研经历Part3——总结与经验分享" class="headerlink" title="『保研经历』保研经历Part3——总结与经验分享"></a>『保研经历』保研经历Part3——总结与经验分享</h1><p>写本篇时是十一最后一天，最近得了保研后综合征，一歇就是一整天，拖拖拉拉直至最后一天才完成本篇撰写。实际上保研人的大四并不会清闲，假后又要面对无尽的任务，有时无比怀念初高中时肆无忌惮和朋友们打游戏的假期，那些都已一去不复返🤦‍。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前文洋洋洒洒写了很多，更多关注一路走来的重大事件盘点与面试的技术细节，多是留给未来的自己回味的。当然，作为一篇保研经验贴，我同样希望大家因我的文章而受益。本篇进行一个浓缩精华的经验分享，不同于大多数老生常谈的如何去提升背景等，我想就我本心出发，谈谈本保研小白一路的成长与感悟。</p><h2 id="最后の总结"><a href="#最后の总结" class="headerlink" title="最后の总结"></a>最后の总结</h2><p>将时间拉回三年前，我对计算机的了解程度仅仅是用它打各种游戏，还总是将游戏下进C盘，高中信息老师教python时我都会嗤之以鼻。然而高考后，由于计算机专业的火爆，我脑子一热选择了北航信息大类，并<strong>在入学时便将最火爆的计院当作我的努力目标</strong>。我想，这冥冥中自有缘分，如果大类内网安最出名，门槛最高，我或许也会坚定的选择网安，无论如何，我很确定我最初并不是因为了解计算机并清楚学计算机会收获什么而选择了你6。</p><p>至如今，保研结束，这意味着至少未来6年我要在计算机/AI这条路上追逐前沿，并且在更遥远的以后，我相信计算机仍会是我最忠实的朋友，或许是鼓捣游戏，或许是贡献开源一些项目，又或许成为一颗螺丝钉。仍在感叹的是，这其实距离我敲下第一行C语言代码，屏幕中第一次出现“Hello world!”也不过三年，距离建立起对CS领域的全面系统认知，才仅仅不到半年。保研DDL正固定在那里，一动不动，我在想方设法去利用这有限的时间完成又一次攀登，但我也会在繁重的课业科研之余思考，短短三年，我<strong>所掌握的理论知识</strong>，<strong>所具备的科研能力</strong>是否支持我成为一位研究生开展研究。我想我必须先聊聊6系。</p><p>我的发展与6系是分不开的，6系对我来说是一个复杂的地方，我对其抱有极其复杂的情感。不可否认，在6系的两年，我完成了一次阶段性的进化，我能感受到我在各方面成长，变得成熟。推动我进化的，有两方面客观因素，一个是高强度的本科教学体系，一个是“压着我喘不过气”的同辈压力；有两方面主观因素，一个是我自身的兴趣点恰好点在计算机上，还有便是在这个“小社会”中逐渐被潜移默化的生存观念。这几方面汇聚在一起开始养蛊，最终造就了如今的我。顺便一提，我从小便有一种概念神的能力，无论在初中高中还是大学，我都能稳定维持中上游水平，诚然，在一层一层筛选上来的北航cs，想进5%甚至10%的确是难如登天。</p><p>大家都讲保研拼的就是信息差，大学乃至进入社会都仍是如此，我现在表示赞同。但我前两年闭关锁国，后知后觉，信息差这块被落下的就是我😀。众所周知，6系以大课重课闻名，coooos的课设无一不是硬茬，我在大二对即将面临的挑战满怀期待，在计组coding无数个日夜，通关P8，拿到了95分的高分后，我开始认为6系这种教育是无敌的，只要跟着6系专业课走，一定会有更美好的未来。在此，我并不过多地宣扬6系的课设有多么提升能力，仅讲一个保研前观念真正转变之时，那便是计组助教的面试（实际上我并非为了保研加分才去选择应聘助教）。当时是大二下学期中旬，我仍然痴迷于钻研课内，然而当时被问到web相关开发经验等等，我对此完全没有丝毫了解（虽然大三上学期就会接触web开发，但是在你6时间比金钱还要宝贵），更出乎意料的是，我发现有不少同学当时便掌握web开发的相关经验。随后果不其然，我收到了拒信，我此刻才意识到，原来同辈的大家也在不断进化，而我仍对着课内的成果沾沾自喜，同时，我在大二下开始接触更多本院同学，逐渐认识到和大家知识上的差距，也意识到参加一段科研工作的重要性，我决心开始自学。在改变命运的大二升大三暑假，我完整学完了50余小时的前后端开发教程，并花费了至少5倍时间进行实践，这也顺便为接下来的数据库课设和软工课设打下了坚实基础；与此同时，我开始参与第一段AI方向的横向科研，得益于大二冯如杯自己胡搞的手语识别，逐步入手自学了机器学习，深度学习的大量知识，系统踏入了人工智能领域的大门。这是第一次靠自己意识打破了信息差，同时依靠课内与自学，我脑海中的cs大厦，开始落成。</p><p>6系的本科教学像是一个理想主义者，扎实地培养起我们每个人的基本能力，但保研的现状却是一个现实主义者，那些费尽心血的专业课换来的只是一个较高的分数，并不会为保研带来更多实质性的进步。保研期间的经历，险些令我的观念再一次转变，随着夏令营一次次失败，陶瓷的一次次没有回音，我发觉，这两年呕心沥血做的课设似乎并没有用处，学校更看重的是冰冷的绩点与本科生本不必过于擅长，学院也缺乏引导的科研，那这还不如当初思政课上举手回答几个问题。我开始怀疑自己，怀疑6系的教学体系，也怀疑其他学校的老师“不识泰山”（并非自吹），所幸我始终抱着“是金子总会发光”的想法安慰自己，也受到高人指点用了些我平时看不上的招，比如开始精心包装自己的cv，略微夸大自己的贡献，为了保研找了份对口的实习，总算最终看到了曙光。</p><p>我保研的暂时成功，可能要归功于很多因素，要归功于六系的培养，要归功同辈的间接push，要归功于我一直以来的良好心态，要归功于运气好，还有很多很多。无论如何，我打破在6系生存的信息差还算为时不晚，但对于打破保研的信息差我想为时已晚，毕竟我很早就想润出北航，但直至最近几个月才着手下这一盘保研的棋局，尽管我似乎完成了一次较极限的逆风翻盘。倘若我能够在大二甚至大一便筹备保外，而不仅局限于课内和保研加分，结果或许会不一样么，过程或许也会不会不那么提心吊胆了？</p><p>短短三年间，我接触到了远超高中信息量的知识，或许在一年前，我会说，“我已经很懂计算机啦，计算机的运行原理不就是巴拉巴拉么，我都做过一遍，有什么难的”。但如今，正如某些人在大一时便有的感悟，我无法觉察计算机领域知识的边界，接触的越多，只会感慨自己懂得越少。</p><p>诚然，最后一轮面试AI Lab时，老师的问题一击致命，我本科阶段做过的第一段科研甚至是由一个横向项目转化而来，一些idea略显稚嫩，经不起细细推敲。前几年，我的确有很多决定做的草率，也想快速和本科阶段做一个切割，所幸Lab给了我这个重新做人的机会。如今已正式开始博0生活，经历了本科期间的广度搜索后，展望即将开始深度搜索的科研生涯，我想需要细细规划，我有幸获得了一个不错的平台，掌握了优质的资源，确定了一个前沿且前景广阔的大致方向，我现在仍具备对科研的动力与热情，以及对知识的热爱与敬畏，我会尽力做出“起码能说服我自己”的成果，接下来的这座山峰究竟能攀上多高暂未可知，希望未来五年不会碌碌无为吧。</p><p><del>最后，在学习计算机两年后，我尝试给出为何热爱计算机这门学科的答案，它代表着绝对理性，代表着人类利用自然学科理论创造的最高智慧结晶；那么，学习计算机的收获是什么呢，我想，是一种理性且批判看待问题的角度，一种习惯将复杂事物拆解的思维，一种遇到任何问题都会尝试解决的态度，一种用计算机可以改变世界的美好理想。</del></p><h2 id="经验分享"><a href="#经验分享" class="headerlink" title="经验分享"></a>经验分享</h2><p>有人能看懂前文的主旨么我想问问，最后给几点真正的干货吧，重点适用于六系能保研但想保外校的非顶尖同学，其次适用于其余想保外校的同学，对科研有追求的同学，同时欢迎有需要的同学私聊进一步交流：</p><h3 id="保研准备——减小信息差"><a href="#保研准备——减小信息差" class="headerlink" title="保研准备——减小信息差"></a>保研准备——减小信息差</h3><ol><li>rk &gt; 有产出科研 &gt; 无产出深度参与科研 &gt;&gt; 各种普通竞赛，专利，软著。</li><li>一定要尽早明白保研的流程，比如综测算哪些分不算哪些分，各个时间节点。</li><li>请相信北航cs的title，rk和其余中九比会放的比较宽，但无论如何课内均分永远是保外最重要的，在前五/六个学期尽可能拉高<strong>全科均分</strong>吧。首先要做的是用心完成全部核心专业课，不仅学分高，还能在你可能没啥可写的简历里留下一笔；其次，选课要慎重，六系的专业课我认为足够用了，选修课要求几门选几门即可，多选无益，不如自学并花时间搞科研。</li><li>最好在大三提前进组，进真正能参与科研（非横向打工），有研究生学长或老师亲自带的组，进你感兴趣方向的组，提前了解觉得没问题后，应积极深度参与，不要摸鱼。尽管你未来并不希望投身科研，那也应该去试错，尝试下这条路。若你是对清北有执念的，在前两年卷够均分后，尝试去联系清北的组，不要在北航找，离清北近是北航最大的优势。若你迫切想润出北航，那么可以找短期内能参与论文产出，或主导论文产出（判断自己是否具备主导一篇的能力）的组。</li><li>在大学，靠自学，要多学，你需要快速对计算机整个学科建立全方位了解，这也可以通过一些push的手段，顺带着把加分拿了，比如参加数模竞赛，参加系统能力设计大赛等等。</li></ol><h3 id="推免考核——放平心态"><a href="#推免考核——放平心态" class="headerlink" title="推免考核——放平心态"></a>推免考核——放平心态</h3><p>当你的材料顺利度过初筛后，就要靠学校的考核来决定你的命运了，我经历了十场面试，四场机试，两场笔试，不算多，但可以简单谈谈公式。</p><ol><li>面试的准备：一份简历，一份5min的自我介绍PPT，5min和2min的中英双语自我介绍，从课内成绩，竞赛，科研，未来规划四个方向展开，重点讲科研。</li><li>简历要扬长避短，尤其是不太懂的科研经历不要写，<strong>要使用简历来诱导面试官提问</strong>，回答要既切题又发散，这样可以在你熟悉的领域撑很长时间。比如我的简历花了很多笔墨在第一个项目经历RAG科研助手上（和我的读研方向match，前沿，可问内容多，最重要都是自己做的），面试官提问RAG相关细节与应用的概率高达5成，我为此也做了诸多准备，回答都比较到位。</li><li>对于面试的数学和专业课，千万不要慌，这绝对是最简单的一关！小编整理了cs保研数学和各个专业课的常见考点，关注下图公众号，私信“保研”二字即可领取。好吧，就我个人而言，我事先的确细致过了一遍<strong>网上领取的保研资料</strong>，可以说面试问到的题目几乎都涵盖在里面，比较高频的考点，如线代的特征值，线性相关，概统的贝叶斯，中心极限定理，计网的TCP,UDP，操作系统的进程与线程等等，都切切实实在我面试时被问到过。因此，首先确保你每门课都认真学过，其次，尽可能有至少一段充实的科研经历可供拷打，最后，看几遍网上提供的高频考点，应付面试的专业课拷打将绰绰有余。不放心的话，你还可以猛猛刷知乎的保研经验贴，或者刷刷我的。</li><li>对于上机，想必大家都经历过大一的程设且打过蓝桥杯且学过算法，那么我默认大家具备算法基础。你唯一要做的就是保持手感，如果你没有刷力扣的习惯，你可以保研开始前三个月，每天刷两道中等难度的算法题，优先拿下<strong>Hot100</strong>，并拿小本本总结一些板子和常见套路。上机有时候比的就是你见没见过这道/类题型，所以一定要多做多见，无需过于追求Hard难度和时间复杂度更低的偏门解法。</li><li>对于数学和专业课的笔试，的确不好速成。我建议在五月份报名个南大cs夏令营，逼迫自己完整的复习一遍三大数学和408，后续巩固时再看看保研资料速成。我当时是跟着csdn的期末复习笔记复习的，很多课已经忘光光了，任务量有点大，所以还是那句话，确保你每门课都认真学过，复习时或许就会触发大记忆恢复术。</li><li>对于一些弱com学校而言，需要你提前联系导师，参与导师的考核，相较学校面试会增加论文复现，论文汇报等环节，故需要积累较强的科研能力，才能让你脱颖而出。这部分我没有相关经历，不过多赘述。</li></ol><h3 id="决定去处——幸福的烦恼"><a href="#决定去处——幸福的烦恼" class="headerlink" title="决定去处——幸福的烦恼"></a>决定去处——幸福的烦恼</h3><p>最后的最后，优秀的你可能拥有多个offer，该如何抉择：</p><ol><li>一定不要当海王，我认为这涉及基本的为人问题。可以海投，但请尽早放弃你不考虑的offer，帮助更多比航✌差点的同学。</li><li>未来数年的幸福感 &gt; title，方向，组；不要因为短暂的喜悦冲昏了头脑，你要做的是影响接下来数年乃至一生的抉择，请优先去一个适宜你生存的地方，如果你可以知道组内情况的话。</li><li>外校直博更需要慎重，事先掂量掂量自己的能力，一不小心就是当七八年的牛马；相比较而言，外校的，比如浙大的硕士，我就非常推荐，详情参见预推免篇。若绝对以科研为导向，那么或许计算所这种老牌研究所，或是AI Lab，Tele AI这种联培项目会更适合你。</li></ol><p>现在的我也无法预料做出的选择从长远来看是否正确。总之，最后一句忠告，<strong>无论身边环境如何变化，怀揣着对知识的热爱与初心，你终将达成，你必将达成</strong>。</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>前半生最重要的时刻，一路走来想必会有贵人相助。</p><p>我最感谢的一定是6系大网红张君楷同学，我们由于一段科研缘分而相识。楷哥在保研期间始终鼓励我，分享招生信息，提供未来发展方向，缩减了大量信息差，我们勉励彼此度过了保研最艰难的时刻。在此，我务必要给楷哥最高级别的respect，祝愿楷哥在thu和法学妹妹一切顺利。</p><p>接下来，我想我会感谢jb老师，在最焦虑的时刻给了我机会，让我和楷茗开始了长达一年多的科研与工程能力锻炼。您对于我们循循善诱的引导，对我们撰写论文的细心修改，我始终心怀感激，同时也感谢您在保研期间为我不厌其烦签的四封推荐信😭。</p><p>感谢金楷茗同学和某人暑假陪我双排，今年暑假我们吃的螺蛳粉麦当劳吉野家烧烤盖饭各种馆子，和曾经并肩作战的日子，现如今无比怀念，那是我们在6系度过的峥嵘岁月，致我们热血燃烧过的青春！</p><p>感谢🐖姐，感谢牢周，感谢我的母亲，还有一起奋战过的大家，衷心祝愿大家都将奔赴更美好的未来，用心珍惜最后的本科时光！</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241008013316205.png" alt></p><blockquote><p>盛年不重来，一日难再晨。</p><p>及时当勉励，岁月不待人。</p></blockquote><p><em>写于2024.10.07</em></p><p><em>杨博文</em></p>]]></content>
      
      
      <categories>
          
          <category> 感想随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『保研经历』保研经历Part2——预推免</title>
      <link href="/post/5602dea1.html"/>
      <url>/post/5602dea1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『保研经历』保研经历Part2——预推免"><a href="#『保研经历』保研经历Part2——预推免" class="headerlink" title="『保研经历』保研经历Part2——预推免"></a>『保研经历』保研经历Part2——预推免</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着按下拟录取按钮的那一刻，五个月的保研之路暂告一段落，我做出了从当前视角看来最正确的决定，选择了中科大和上海人工智能实验室GVLab的联培直博，放弃了浙大cs学硕和北航cs学硕。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/f9e40c25152b79c3c2798f47bff9999.png" alt></p><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>相比较于夏令营期间，背景方面有变动：</p><ul><li>一篇能源化工领域（用深度学习方法解决工业问题）Sci一区论文在投</li><li>一篇对抗样本攻击领域论文完成度80%（即可以拿出来细讲的程度）待投</li><li><strong>智谱AI</strong>大模型算法岗实习生</li></ul><p>还有一些方面，比如：</p><ul><li>rk变为<strong>29/204（15%）</strong>，推免后期变为<strong>26/209（12%）</strong>（进不了10%都没卵用）</li><li>一份精心设计包装的简历（CV是非常非常重要的！）</li><li>全部项目源码开源（我想并不会有人看，感动自己）</li></ul><h2 id="预推免"><a href="#预推免" class="headerlink" title="预推免"></a>预推免</h2><div class="table-container"><table><thead><tr><th>学校学院</th><th>申请学位</th><th>入选</th><th>结果</th><th>备注</th></tr></thead><tbody><tr><td>清华大学自动化学院</td><td>学硕</td><td>×</td><td>×</td><td>外校强com，用尽全力向thu的最后一搏，遗憾</td></tr><tr><td>清华大学软件学院</td><td>专硕</td><td>×</td><td>×</td><td>有排名靠前的本院同学卡哥们，注定进不了惹</td></tr><tr><td>上海人工智能实验室-GVLab</td><td>直博</td><td>√</td><td>√（最终去向）</td><td>致敬传奇耐面王，两个组面了五轮</td></tr><tr><td>中国科学院计算技术研究所VIPL组</td><td>学硕</td><td>√</td><td>√</td><td>你航与计算所友谊长存</td></tr><tr><td>中国科学技术大学信息工程学院+AILab联培</td><td>直博</td><td>√</td><td>√（最终去向）</td><td>一年柯南体验卡</td></tr><tr><td>浙江大学计算机科学与技术学院</td><td>学硕</td><td>√</td><td>√</td><td>美丽的紫荆港，美丽的浙大（哭泣</td></tr><tr><td>南京大学计算机学院（夏令营的wl）</td><td>专硕</td><td>√</td><td>√</td><td>曾经的你对我爱答不理，现在的我对你…</td></tr><tr><td>北京航空航天大学计算机学院</td><td>学硕</td><td>√</td><td>√</td><td><strong>永别了，牢笼</strong></td></tr></tbody></table></div><ul><li>很直观的感受，预推免的bar变低了，复旦和上交由于AILab让我去候补导致被卡脖子了，否则还是很想去集邮的（不是。</li><li>暑假联系了多位北大计院的导师，均未收到回复，而且预推免的名额很少，还需要提前联系导师。当时已经在面试AI Lab了，因此放弃继续投北大。后续得知元宇宙所夏令营招的一个本校✌鸽了，预推免竟给了外校硕士，还是有些遗憾的。</li><li>清华可以报两个志愿，首先选择的是自动化学院，外校硕士强com，无需陶瓷，纯靠个人能力，最适合我；其次在网研院和软院中选择了软院，可能当时考虑到网研院是弱com，然而还是不自量力了，没有5%还想去清软？后面自动化也被拒了，至此清北无望。</li></ul><h3 id="⭐上海人工智能实验室—GVLab"><a href="#⭐上海人工智能实验室—GVLab" class="headerlink" title="⭐上海人工智能实验室—GVLab"></a>⭐上海人工智能实验室—GVLab</h3><p><strong>前言</strong>：上海AI Lab（后称Lab）在去年年末就有所耳闻，中国AI圣地，资源和产出一流，当初认为这个地方于我而言高不可攀，是至少得有一两篇A会的顶级选手才能去的地方。今年过年和高中同学聚会时，谈到未来，我跟朱老师讲，我其实研究生比较想去AI Lab，但是那里bar太高，希望渺茫，朱老师也表示听过且赞同。五六月份，在Github的夏令营信息上看到了数个Lab的招生信息以及它们繁琐困难的考核流程，受到楷哥的鼓舞，我在已经无营可去的七月初尝试向GV Lab投递了简历，不过来不及为困难的面试而焦虑，因为我根本没有收到任何后续通知。来到8.25日，我仍然是0 offer，仍在为预推免做着准备，无意间在xhs上看到了GV Lab d老师的招生信息，抱着再不抓机会就没学上的想法，当即使用北航邮箱投递了简历，无回复，后使用了🐖姐教的老招，用能邮件追踪的网易邮箱再次投递，结果数十分钟后，我看到邮件被阅读，附件被下载；随后的数个小时，我都在提心吊胆中度过，终于，我收到了加vx详聊的回信。命运的齿轮就此转动。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/fix-dir%2FTypora%2Ftypora-user-images%2F2024%2F10%2F12%2F22-18-26-22ca9c67cc22aa54be00cb89e84b3335-image-20241012221819056-8a3524.png" alt="image-20241012221819056"></p><p><strong>面试</strong>：耐面王，一周经历五场面试，最终已然达成每一页PPT和每一句自我介绍完美融合的超我境界。大概为InternVL组一轮技术面+一轮聊天面+一轮boss面，随后疑似被刷，转天被捞进InternVideo组，继续一轮聊天面+一轮技术面。内部情况可能比较复杂，我目前也无法得知全貌，仅在此聊聊技术面内容。</p><p><strong>第一轮技术面</strong>：8.27，Round1，往往是最硬核的，是一位博士生学长负责面试。流程包括PPT自我介绍，自身科研项目拷打，随后拿出一篇论文，大致为Transformer每层 Pre-Norm，Post-Norm等三种不同模块组合方式的优缺点分析，由于我此前并未了解过，只好现场从梯度消失，数值稳定性等角度分析，在学长的指点下答了个大概，后续又问了Transformer的缺点与如何优化等等。最后考察了一道算法，将数组分为和相同的两堆，我在10min内coding出了回溯法，后续问是否有时间复杂度更低的解法，秒答DP，但现场没想出来DP的标解，用嘴说了个现在看来驴唇不对马嘴的解法。</p><p><strong>第二轮聊天面</strong>：转天，收到通过初面通知，立刻约了二面。8.29，Round2，InternVL组的w老师负责面试。我在面试前紧张无比，结果开始面试时才得知我的二面就是聊天面，老师询问了联培学校的意愿（上交&gt;复旦&gt;科大），聊了聊课题组在做的方向，当询问到我有什么想问的时，我小心翼翼地问，“所以这是代表我过了么”，老师答，“差不多吧，听后续安排”。最后在我挑是去上交还是复旦的美好幻想中结束了这场面试。</p><p><strong>第三轮Boss面</strong>：8.31，Round3，招生阶段进入尾声，q老板亲自下场，要过一遍所有候选人。我听闻是走过场，于是心态很轻松地参加了这场面试。前面流程差不多，没想到的是q老板竟开始询问数学和专业课问题，首先介绍拉格朗日乘子法，再是介绍C++的继承与多态机制，后续询问了项目中RAG的相关内容，以及一些open且high level的问题，比如“你认为多模态大模型接下来的突破点会在哪里”，我是就模态对齐训练的设计，粘合模块的设计，类transformer架构的革新和更优质的数据等等角度做了回答，点答的很多但并不具备完整的逻辑，也算是我面试的通病。最后d老师问，为什么专业课分数这么高但排名那么低，我笑了，答我们院的实力都灰常恐怖，卷不过他们，但殊不知当天也有本院同学的参与hhh，这算是给大火背了个书么？</p><p><strong>第四轮聊天面</strong>：煎熬等待了两天，终于在9.2，收到了老师想再聊聊的通知。9.3，Round4，和一位小导简单交流了下，我面试的组由VL变为了Video，以及得知一些名额信息等。我在这场面试时是很懵逼的，不知道发生了什么，现在看来，第三轮后我应当是被VL组淘汰了，而后又被更晚面试或出现🕊的Video组捞上来了，进行Video组的考核。我明白，即使不能进入最想去的VL组，但仍还有最后一次机会。</p><p><strong>第五轮技术面</strong>：9.4，Round5，Video组深研院的一位老师对我进行最后的技术面。常规环节不过多赘述，如介绍一种机器学习算法。老师重点深挖了我的科研经历，其敏锐地感知到我第一段科研经历中存在一个最大的Bug，即为何编码器要使用A模块而解码器使用B模块，这个问题切中要害，因为撰写论文时我们对这部分的解释都无法说服我自己（总不能说我们的模块就是缝合怪吧）。我只好从深度学习理论和实验结果层面进行了简单的解释，但显然这更没有说服老师，反而继续追问，最后我只能以尴尬的 “还是下一段科研我更擅长一点” 结束了这个话题；第二段科研拷打时，被询问到“你们的demo只体现了简单场景，那复杂场景是否具备泛化性”时，同样回答的比较糟糕，彷佛是将原因归咎在了数据集和他人的目标模型。综上，这次是我个人认为被问穿的一次失败面试，结束后就觉得这轮完蛋了。</p><p><strong>结果</strong>：9.6，得知另一位同学在面试当天晚上便收到了offer，心彻底凉透了，一周前甚至还在纠结给科大的offer要不要去，转眼间便颗粒无收。正值预推免全面开始，我决定还是要将重心放在正经的预推免上，AI Lab终究是黄粱一梦😭。9.9，本已走出和Lab分手的痛苦，hr突然联系上我给了中科大的第一顺位候补。经过后续走访，得知仅有我获得了候补名额，据分析八成是当时有人打算🕊，因此才安排候补，故候补成功概率极大。9.15，顺利候补成功，折腾了这么久，终究拿下了Lab的offer。感谢老板们选择将候补机会给到了我，看人真准，我必会毫不犹豫的双向奔赴❤。</p><p><strong>总结</strong>：给最终去向足够的尊重，见最后の总结叭。</p><h3 id="计算所VIPL"><a href="#计算所VIPL" class="headerlink" title="计算所VIPL"></a>计算所VIPL</h3><p><strong>前言</strong>：计算所自古和北航是老交情，夏令营由于推荐信原因未报名，后来才知道能霸面。预推免时也是先填了材料，后因为当时太忙而放弃了。但是幽默的事情来了，从9.6开始，陆续有网络技术研究中心，分布式系统研究中心，智能装备实验室，无线通信技术研究中心的招生老师找到我，说我的材料很不错，是否有意愿前来面试，这无疑给了一个0 offer的人莫大的自信。于是，我主动出击最知名也最match的VIPL组，去官网找到了校友z老师，顺利获得了一个面试名额。</p><p><strong>笔试</strong>：VIPL的笔试是出了名的逆天，具体考核内容如下：</p><div class="table-container"><table><thead><tr><th>序号</th><th>考试科目</th><th>考试时长</th></tr></thead><tbody><tr><td>1</td><td>数学基础知识</td><td>60分钟</td></tr><tr><td>2</td><td>研究领域基础知识</td><td>30分钟</td></tr><tr><td>3</td><td>算法设计</td><td>30分钟</td></tr><tr><td>4</td><td>中英文写作</td><td>40分钟</td></tr><tr><td>5</td><td>综合能力测试</td><td>30分钟</td></tr></tbody></table></div><p>9.13号上午8:30~11:50，高强度全方位考核。</p><ul><li><p>数学为10道大题，一题10分，涉及线性代数（解行列式方程，没做出来），概率论（占一半，有古典概型，计算概率，离散随机变量的均值方差等），高数（不会积分了😭，最后有一道证明也没做出来）。整体比较简单，我考前专门复习了一遍概率论，正撞上枪口，最后做出来五六道的样子。</p></li><li><p>研究领域基础知识即人工智能基础知识，涵盖十分广泛，包括机器学习算法（计算SVM的决策超平面），计算机图形学算法（边缘检测，需要手算卷积），深度学习基础（过拟合如何解决，梯度消失/爆炸如何解决），大模型基础（Transformer，RNN，LSTM的优劣势，Self-Attention的计算公式，softmax以及带temperature的softmax计算等）。这部分我接触的比较多，基本上拿下。</p></li><li><p>算法设计考了三道算法，手写伪代码，比较难。前面有一道数组分治（疑似是），最后一道是二分图求不交叉的最多配线问题，用dp解，还有一道没写出来忘了（。感谢北航算法课练过手撕伪代码，总体时间还是有些赶，来不及细思考。</p></li><li><p>中英文写作，包括两个中译英段落，两个英译中段落，均为CV相关。还有一篇单选阅读和一道中英文摘要总结。这部分应该不占分，40分钟绝壁是写不完的，我翻译认真写了写，阅读直接瞎勾巴选了。</p></li><li><p>综合能力测试，像公务员的智商测试，包含逻辑，图形推理等小学奥数题（高端点可以说考了离散数学😀），还有句子连话，问段落主旨等语文题，算是最后让大火放松一下，灰常简单。</p></li></ul><p>个人建议准备好人工智能八股并完整复习一遍三大数学性价比最高，其它靠现场发挥。</p><p><strong>机试</strong>：9.13下午，可选C++/Python，我选了C++，要求必须用远古的VS2013，且不允许用stl，现场调环境调了10分钟没搞好（我看往年博客都是这样hhh），最后感谢学长将笔记本电脑借给我完成了考试。一小时五道题，包含字符串，数组的基本处理，还有一道缺失最小正整数的算法（力扣原题），经历过南大北大的上机和一暑假的算法训练，见到大一上难度的题显得格外亲切，30分钟秒了。</p><p><strong>面试</strong>：据说笔试机试刷掉了一些人，9.13晚通知我顺利进入了面试。9.14上午，我参与了推免期间最有意思的面试，首先是2+3min PPT自我介绍，随后我已经做好了被拷打科研经历的准备，结果VIPL的老师们一套逼问还有哪些offer的丝滑小连招起手，我只好说出有上海ailab的联培候补（实则9.13中午我便收到了候补成功的通知），老师们窃窃私语了一会后疑惑地问ailab那边的招生情况，随后追问候补成功概率，来VIPL组的概率（我答90%来，老师说那剩下的10%就是候补到你就一定去他们那呗）。接着跟我唠起了家常，包括但不限于北航降薪事件，北航各个食堂饭价，为什么我不想在北航继续读，如何理解什么是有意义的科研，为什么找z老师（我答因为z老师是俺们北航的校友，众老师笑），了解过z老师研究方向么，介绍VIPL组重点研究方向，询问是否真的了解过Lab那边做的事情么，记得原话是，”AI Lab那边zf投资了那么多钱，资源比我们这里多太多了，我们组做特定场景下视觉任务多一些，而那边有资源去做一些通用模型“，最后在我还懵逼时结束了面试。</p><p><strong>结果</strong>：面试当天中午便荣幸收到了z老师的电话，让我立刻回计算所一趟当面聊一聊。果不其然，z老师和我交流了组内的课题方向，并表示我是她的第一选择，愿意给到学硕的offer，但需要签署双选表，给了半天时间考虑。当时我已经下定决心去AI Lab了，因此晚上和z老师坦白，放弃了这个offer。</p><p><strong>总结</strong>：笔试强度最大的一集，也是收获的第一个学校offer，对我来说是有意义的。两个研究院性质的去处，我会选择前景更好的AI Lab，但无论如何，灰常感谢z老师愿意给我这个插班生考核的机会，也感谢老师们对我的认可，祝愿北航和计算所友谊长存。</p><p>最后解释下，我是在考核中途才收到了AI Lab的offer，并非海王555；而且我后来好奇面试为何如此与众不同，老师们说我的个人介绍和简历已经十分充实了，因此聊了20分钟天（本来还想着积累下面试经验来着），我想也许一是对航楠有滤镜，二也是认为我并不会去他们那里吧。</p><h3 id="中科大6系"><a href="#中科大6系" class="headerlink" title="中科大6系"></a>中科大6系</h3><p><strong>前言</strong>：前文说到AI Lab给到了中科大的offer，唯一一所无论是夏令营还是预推免我都没有考虑过的华五，也算是一种奇妙的缘分，当然更奇妙的是逃不开的<strong>6系</strong>。联培学校的面试说是走个过场，我当真了80%，9.13后便处于半歇逼的状态了，9.20截止报名，9.22在中科大主校区面试，9.23早上通过面试，结束战斗。</p><p><strong>面试</strong>：9.22下午，将近20位AI Lab的联培同学参加面试，前面的同学讲考了泰勒级数和傅里叶级数的区别等问题，说好像也不太走过场，吓得我一哆嗦，实际上考核内容和正常推免生是一致的。这场可以说是我发挥比较糟糕的一场面试，首先是1min的纯英自我介绍，随后老师开始拷打15min的基础知识和科研项目。</p><ul><li>A老师：用英文介绍ChatGLM，讲讲你们项目中的RAG技术，谈谈RAG技术的缺点并如何解决，最后回答的不好，应该答更依赖外部数据库，创造力不足，难以执行复杂任务等方面（当时支支吾吾答的记不起来了）；</li><li>B老师：计网，TCP的三次握手，UDP与TCP区别，常规；</li><li>C老师：科研经历，为什么将异常检测的任务称为无监督任务，确实有争议，和老师解释了一下；</li><li>D老师：算法和数学，算法即如何在数组内找两个数相加和为10，最糊涂的一集，在现场甚至没直接想到双循环，支支吾吾说了用回溯法，老师接着让讲讲算法细节，我用复杂的逻辑描述一遍后才发现这就是双循环（正解是用哈希表$O(n)$秒了，前几天刷到过的力扣原题）。最后数学问了求特征值的方法，判断一个矩阵满秩的三种方法（行列式，逆，化三角阵）。</li></ul><p><strong>结果</strong>：出会议室时，即使知道应该不会刷我，但我还是蚌埠住了。老师提问时特别说了一句”我看你打过算法比赛，那考你个算法吧“，当时怀疑老师会觉得我根本没学过算法甚至编程（哭，不过最后不出所料的通过了。</p><p><strong>总结</strong>：科大主校区分五个校区，尤其中区现代又漂亮，在科大旁边住了两天，发现周围的小吃街也不错。只是我目前对这所低调的学校知之甚少，并无什么滤镜与情怀，希望当柯南的一年能够多体会体会科大的风土人情（少废话，你GPA多少）。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241003120052180.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20241003120108442.png" alt></p><h3 id="浙大CS"><a href="#浙大CS" class="headerlink" title="浙大CS"></a>浙大CS</h3><p><strong>前言</strong>：浙大cs直博需要暑假期间进行考核，战线拖得很长，因此只在预推免报名了浙大cs硕士。浙大cs据说比较喜欢收985的学生，我还有很多同排名的同学都收到了面试通知。当时已经做好了去科大直博的准备，因此简要记录。</p><p><strong>面试</strong>：9.25上午，20min，5（2+3）min PPT自我介绍，若前2min英语介绍则可免英语提问环节，接下来开始拷打。</p><ul><li>老师A：编译器是否参考他人框架，如何实现公共子表达式删除和死代码删除优化，实现异常检测的方法（把重建序列的流程重新叙述了一遍）；</li><li>老师B：Transformer内部细节与优缺点，在无人机上部署大模型和传统视觉模型各有哪些优劣，无人机上部署大模型存在哪些问题及如何解决等等；</li><li>老师C：政治题，知道flg么，持何态度。</li></ul><p><strong>结果</strong>：这场是我认为保研期间发挥最好的一场面试，最终浙大本校和外校共同排名，我位于49名，拿到了软件工程方向（第二志愿）的学硕offer。老师B的问题令我印象深刻，给出了一个具体场景令我给出解决方案，当时便很好奇为何是问无人机，结果当天下午还没出结果时便收到了这位老师的电话，说我回答的不错，也对这方面比较了解，可以给到一个专硕的offer负责一个智能无人机的项目，这下破案了。后续我拒掉了这位老师，也拒掉了考察政治题的那位老师，没有主动联系其他导师，但是把offer留到了最后，9.29上午释放。</p><p><strong>总结</strong>：浙大cs楼在玉泉路校区，紧邻西湖，古香古色。前一天和高哥约好去到了伟大的紫金港校区参观，着实令我大开眼界，高哥说是”中国小剑桥“一点也不为过。浙大的草坪足以建上两个新主楼，校区内部竟有三趟不同线路的摆渡车，很难想象我这三年上的是什么大学。不过在北航上学也有好处，宿舍到主楼仅需10min，不耽误任何学习时间，真是赢赢又winwin啊。就差一步迈入top3（的有力竞争者）高校，着实遗憾未能和高哥相约浙大做校友了，如果AI Lab没有候补上我，我一定一定毫不犹豫的选择浙大❤。</p><p>多图预警！</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/69eea53c832e7bed1398f795d894b8f.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/8e90374eabae6700a02cc5308d3dad3.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/56f43188671a3aeeb36f98dd3deecca.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/d89097142a1ecbc98a7e31c84c7e3bc.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/d2a2cb3c5caa56081e7e54620a3da7b.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/3b391eeec39089c507897dec6b6ddf8.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/cc7e70fcc4e8fa0c336e1c07b6fd310.jpg" alt></p><h3 id="北航CS"><a href="#北航CS" class="headerlink" title="北航CS"></a>北航CS</h3><p>我那含辛茹苦拉扯我长大的母校啊。</p><p><strong>前言</strong>：活全家的6系安排考核在9.27~9.28两天，9.28晚上才公布硕士面试结果。其实本不用参加本校的考核，拿到浙大保底后，直接放弃面试就好，当时我向自己解释的理由，一是有始有终，陪伴北航走完最后一程，二是我能占上一个名额，让那些候补的非本校学生不敢赌，提前确定其他学校，保本校的同学们上岸。但诚然也有凑个热闹，体验下航子的面试的想法。</p><p><strong>面试</strong>：机试用10%的CSP抵了，懒得再上机了。教务特别将本院的同学安排在面试后几位，但是面试当天本组前面有四五个同学直接放弃，我很早就面上了试。无自我介绍，直接拷打。</p><ul><li><p>政治英语：抽一道政治题，我抽的是“结合自己所学专业讲讲对科教兴国的理解”，不占分。朗读英文段落，并翻译。后半句我没翻译明白，主要是没理解散步为何能和拯救生命联系起来。老师一直鼓励说，“前面翻译的很不错，后面再多想想”😂。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For years, thousands of us have been pounding the pavements, trying to reach that magic goal of 10,000 steps a day to stay fit and healthy, but new research has found that walking just half of that could also save lives</span><br><span class="line"></span><br><span class="line">近年来，我们成千上万的人热衷于散步，尝试到达一天一万步的神奇目标来保持身体健康，但是新的研究发现每天仅走一半的步数也可以拯救生命（保持身体健康）。</span><br></pre></td></tr></table></figure></li><li><p>数学：离散数学三连击，什么是数理逻辑中的可判定性，命题逻辑和谓词逻辑的可判定性如何；用集合论的规则定义什么是函数；什么是哈密顿图，欧拉图，如何判断这两种图。我没有系统复习过离散（悲，只能靠印象答，吞吞吐吐往外蹦字，老师一直在安慰我说，“一定是学的太久有点忘记了吧”😂。后续还问了解释先验概率，后验概率，全概率，条件概率等概念（结合贝叶斯和全概率公式答）。</p></li><li><p>专业课：讲讲面向对象的多态性质，并举例；父类静态方法能否重写，为什么；操作系统的主要功能；进程和线程的区别；进程虚拟空间有哪些分区；不同线程间有哪些资源可以共享。</p></li><li><p>科研：问了项目中RAG技术的使用，优缺点，如何改进。</p></li></ul><p><strong>结果</strong>：问英语和离散时，会议室氛围一度十分十分尴尬，多亏了老师耐心的提醒与安慰，回答上来个大概，后半段发挥好转很多，最后喜提学硕倒数第二名，保住了本校最后的颜面。在9.29上午释放offer。</p><p><strong>总结</strong>：与众不同的一次尴尬体验，当其他学校都在问科研经历的时候，只有你航在问数学专业课，亲身证明了尤其爱问离散一和二，一定要重点复习！这是我保研期间参加的第十场也是最后一场面试，<strong>永别了，牢航</strong>。</p><h2 id="预推免小结"><a href="#预推免小结" class="headerlink" title="预推免小结"></a>预推免小结</h2><p>实际上自9.15以后，我的心绪便以飞远，甚至开始学习如何当一名博士。9.27，南大cs候补到了专硕名额，当即拒绝。</p><p>在预推免阶段，并没有像夏令营那样失败，反而比预期顺利的有些梦幻，我亲身经历并认可了“预推免才是大部分保研生的主战场”这句名言，也逐渐找回了信心，正确认识到了自己的能力与上限。</p><p>从初心来看，我收获了计算所+三所华五的offer，顺利完成了<strong>站着离开北航</strong>的核心目标，为这三年的奋斗画上了一个阶段性的句号。</p><p><em>写于2024.09.29~2024.10.06</em></p><p><em>杨博文</em></p>]]></content>
      
      
      <categories>
          
          <category> 感想随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『保研经历』保研经历Part1——夏令营</title>
      <link href="/post/97f9a153.html"/>
      <url>/post/97f9a153.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『保研经历』保研经历Part1——夏令营"><a href="#『保研经历』保研经历Part1——夏令营" class="headerlink" title="『保研经历』保研经历Part1——夏令营"></a>『保研经历』保研经历Part1——夏令营</h1><p><strong>保研经历</strong>：特指从24年5月至24年9月这五个月的经历。</p><p><strong>Part</strong>：本经历主体共分三个部分，分别为夏令营，预推免，总结与经验分享。</p><p>秉着不半场开香槟的原则，笔者优先记录下夏令营情况，尘埃落定后再完成预推免部分。文字部分尽量做到客观，实事求是描述事件发生时笔者的所见所想。</p><p>我在知乎上看了无数的保研经历，自认为本人经历不具备任何的普适性，权当对本人学习计算机三年来的最高潮做一次分享。</p><h2 id="宇宙级免责声明"><a href="#宇宙级免责声明" class="headerlink" title="宇宙级免责声明"></a>宇宙级免责声明</h2><p>本文中若有泄露高校敏感信息（如考题）行为，或有过失言论，完全非主观行为，请联系我，我会第一时间改正！</p><p>本文为完全免费对外开放的经验分享贴，无任何收费观看行为。是经验就必然不可避免地存在着主观色彩的语言文字，如果侵犯到个人利益或集体利益，请联系我，我会第一时间道歉并改正，致歉会公示在本文（永久）！</p><p>求仙问卜，不如自己做主，念佛诵经，不如本事在身。人生百态，竞相怒放，一个人的经验不可能完全地适配任何人，如果完全按照本文的经验套用在自己身上，造成的任何后果均不由我（本文作者）承担。</p><p>文章会更新，请以最新版为主，如因阅读了旧版本而造成了损失，造成的任何后果均不由我（本文作者）承担。</p><p>本人爱党爱国，如若评论区出现不当言论，均非本人恶意所为，会第一时间删除！</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>保外校是很早很早之前做的决定，一是想证明三年的艰苦奋斗总会有收获（为了更好的title和资源），二是慢慢发现本学校和学院某些方面与我个人发展并不相符。</p><p>我的大学三年是依靠知识驱动的，我给自己定下的目标是全力完成核心专业课，完成每一个project，完成每一场竞赛，但对于保研的方法流程，以及cs保研的竞争激烈程度均一无所知。我想这便是”生于忧患，死于安乐“，中国计算机最顶尖的学院之一已然成为了我的舒适圈，我既没有一定要去清华北大这种顶级高校的决心，也没有明确的未来规划，更没有事先为保研做出充足的准备，比如用水课刷均分，刷绩点。因此当我着手润出北航的大计时，一切的阻碍随之而来。</p><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p><strong>背景</strong>：北航cs，夏令营时<strong>25/204（13%）</strong>，几个保研不得不参加的省奖，两段深度参与的科研经历，无产出，课内经历丰富（燃烧了两年，70%的时间都花在课内，你6懂得都懂）。</p><p><strong>优势</strong>：第一优势，<strong>北航计院</strong>；第二优势，具备基本的科研能力，项目大多与AI相关，涉及RAG，大模型，CV，可信赖AI安全等方向；当前两点优势足以让我进面时，具有第三优势，笔者自以为算的上对cs领域涉猎广泛，懂得略多，尤其是AI上下五千年。</p><p><strong>劣势</strong>：第一劣势，活全家的6系课内压力过重，投入产出不对等，且由于我铸币直至大三下才知道保外拼的是全科排名，而我的全科排名和专业课排名比起来一个天上一个地下；第二劣势，本人由于没有高人指点+不积极+排名不高，难以掌握6系的优质科研资源，因此直至参加完最后一个夏令营也没有一篇论文再投；第三劣势，性格原因，不擅长交际，也不喜欢陶瓷这种手段，更不擅长高压下的面试，前中期属于听天由命型。</p><p><strong>策略</strong>：重点投清北华五两所，当时认为直博风险大且需推荐信，故只投CS/AI学院的学硕。由于未来大概率走科研学术这条路，有的地方个人狂妄地认为还不如你航，省的海投了。title ＞ 北航即可，方向 &gt; 导师。</p><p><strong>总结</strong>：对自我认知有数，夏令营很难有好结果，权当增长面试经验，为预推免做准备。只要让我进面试就是胜利，可惜除了是航男以外看不到让我过筛进面的点。</p><h2 id="夏令营"><a href="#夏令营" class="headerlink" title="夏令营"></a>夏令营</h2><div class="table-container"><table><thead><tr><th>学校学院</th><th>申请学位</th><th>入营</th><th>结果</th><th>备注</th></tr></thead><tbody><tr><td>南京大学计算机学院（wlm组）</td><td>不区分</td><td>√</td><td>wl</td><td>机试难难难，纯旅游</td></tr><tr><td>清华大学计算机学院</td><td>直博</td><td>×</td><td>×</td><td>碰瓷贵系失败</td></tr><tr><td>复旦大学计算机学院</td><td>硕士</td><td>×</td><td>×</td><td>可惜，据说只收rk5，祝鸽穿</td></tr><tr><td>上海交通大学计算机学院</td><td>硕士</td><td>×</td><td>×</td><td>可惜，合理</td></tr><tr><td>中国人民大学高瓴学院</td><td>硕士</td><td>×</td><td>×</td><td>可惜，合理</td></tr><tr><td>中国人民大学信息学院</td><td>硕士</td><td>×</td><td>×</td><td>oq</td></tr><tr><td>北京大学计算机学院（元宇宙研究所）</td><td>博士</td><td>√</td><td>×</td><td>离北大最近的一集，给本校✌跪了</td></tr><tr><td>中国科学院自动化所</td><td>不区分</td><td>×</td><td>×</td><td>疑似你6被拉黑了</td></tr></tbody></table></div><ul><li><p>挺对仗，入了一个南京大学，一个北京大学，其余全部寄。</p></li><li><p>硕士太难入了，投直博应当会好入一些。推荐信是最麻烦的，本人在计院比较小透明，且害怕麻烦老师（虽然后续也麻烦了不少），所以能不要推荐信就尽量不要，只有投北大时认真撰写提交了推荐信材料，最后也奇妙入营了。</p></li><li><p>没有参与过任何老师的提前考核面试等。</p></li></ul><h3 id="南大计院夏令营"><a href="#南大计院夏令营" class="headerlink" title="南大计院夏令营"></a>南大计院夏令营</h3><p><strong>前言</strong>：南大cs是开的最早的营，5.5截止报名，本人五一期间紧急麻烦教务开的排名证明，自此正式开始了保研之路。5.11，材料通过初审，首战告捷，全面复习408与数学，准备笔试。</p><p><strong>笔试</strong>：5.18笔试，那天也正值冯如杯现场展示，早起先去的答辩现场，又回寝室参加笔试。再次征引名言”南大cs不要运气不好的学生“，60分钟，40道单选，30道多选（错漏不得分），涉及408，编译，数据库，三大数学，离散（集合论，群论），算法，编程语言等所有cs基础知识，题目难度也偏大。题量大难度高，就不是让普通人全做的，所以必须有所取舍，全神贯注速度读速度跳，把会做的都拿下。个人认为平时上课认真学了，再花了一周左右复习，即可通过，这部分分数最后会算到录取的综合分数上，所以也是分数越高越好。最后感谢南大让我在5月份就完成了基础知识一轮完整复习，并整理出了一份复习笔记，真是我的保研贴心小助手！</p><p><strong>机试</strong>：6.1早上上机，灰常难，得分121分，满分300，问了下航子朋友和南大朋友，人均100出头，纯英文题面，第二第三题非传统算法题且题目是小作文长度，第二题是一道类似模式识别的题目，给定一副图像的灰度图，判断图像中的图形是等腰三角形/平行四边形/椭圆形，用自创算法凑了21分，后续wlm给我开小灶说可以通过大致确定图像内的直线条数来判断；第三道考指针的内存管理，涉及c++模板/java泛型，完全没时间细看。</p><p><strong>面试</strong>：</p><ol><li>学校面试：三个老师，分别问科研，专业课，思政。无自我介绍。首先一道英文题，解释快速排序和时间复杂度，经典题目，支支吾吾的把点都答上来了。接下来讲科研经历，着重拷打了第一段有关异常检测的，从项目问到了一些AI的基础知识，过拟合如何解决这个问题没回答好(太紧张了)，没回答出dropout和正则化。专业课老师人很好，让我选择一门专业课，我说计网要期末考试了，考计网吧，结果考了网络流(?)，我回答了TCP的流量控制，老师追问有没有不通过报文交互进行流量调节的方法，事后想可能问的是VLAN划分，当时没想好，说的是必须双方要经过协商才可以，老师微笑的顺着我的意思继续说下去了。思政问了个人优势，无关紧要。</li><li>组内面试（多媒体视觉计算组，wlm）：半聊天，先是自我介绍，体系结构说太多了，wlm让我直接跳过说科研，着重聊了第二段物理对抗攻击的科研。不涉及太多基础知识，问了未来的想法，我答出国读博，又问知不知道现在CV很卷(大家都无奈笑了笑)，想不想要学术成果之类的，我也表达了一下我迫切想要投入科研的心。还讨论了上机的第二题，问机试多少分，第二题的思路等等，说现在我们这帮人动不动就神经网络，早就都抛弃了传统方法，这部分一开始聊了半分钟，最后变成王老师教我做题。氛围很不错，比下午的面试强太多，但归根到底优营还是要靠下午决定。</li></ol><p><strong>总结</strong>：超强com，南大两日游，很不错，第一天在仙1教学楼呆了一下午+一晚上，虽然不是同一地点，但彷佛又回到了北航，高中同学邵哥带我骑电动车去两座山上都溜了一圈，还体验了特色滑板。不得不吐槽教学楼有时不开空调热的一批，而且里面的厕所实在不如你航一根毛，考核整体不算太压力，还和高中同学，大学同学happy了一波，下次还有机会来么。。 <strong>记录于24.6.3</strong></p><p><strong>结果</strong>：来不了了，wl了，上机占比太大了，不是给人做的。 <strong>记录于24.6.15</strong></p><p>放两张南大仙林校区的美景吧！</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240916215524168.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240916215517391.png" alt></p><h3 id="北大计院夏令营"><a href="#北大计院夏令营" class="headerlink" title="北大计院夏令营"></a>北大计院夏令营</h3><p>南大入了以后到达了愚昧山峰，没有意识到今年夏令营环境多么恶劣，和几个同学相约上海见，结果上海学校营都入不了一点。</p><p><strong>前言</strong>：夏令营的高潮也是结束。北大谁不想去（星星眼，计院听闻是超弱com，我便开始搜集情报，了解到了一个参加过元宇宙研究所考核的学长，说相比较而言比较好进，我便第一次厚脸皮找老师要了两封推荐信，并且提前陶瓷了某l老师（老师回复的很官方，说期待我能胜出）。6.13，收到是否考虑硕转博的短信，我当即答应（感觉这是有戏啊）。6.22，一大早收到入营名单，赫然在北航入营的11人中找到我的名字（不会是同名吧？？？），随后收到了邮件，我踏马直接<strong>彻底疯狂</strong>，已经畅想在北大校园的美好生活，当即再次联系了l老师表达了感谢之情，并加上了v，当询问到是否需要提前交流一下时，便没有下文了。被泼了一盆冷水后，也意识到可能就是拉我过去凑个热闹，名额已经被安排好了，但是仍抱着希望，开始准备完整的自我介绍与PPT（这份PPT也一直更新迭代用到了最后），刷北大上机算法题。</p><p><strong>机试</strong>：说是机试，记录下6.27一天。早，和🍊姐一起去北大参加开营仪式，留下了在北大的影像痕迹，下午参加了元宇宙研究所的答疑环节，得知以下信息，入营38进10，面试10进4，竞争对手有3个本校✌，面试不会考虑场外因素，事实上在场的各位疑似也没有提前实习过的同学；晚，上机考核，C++，一道题只有点全过才得分，有罚时机制，最终10道算法题，过3道，拉了坨大的。考察的有并查集，栈，DP等等，题型比较常规但难度不低，除了本身是个废物外，由于之前错刷成了北大预推免的上机题，错误估计了夏令营上机的难度，加之编程环境非常不适应（CLion惯的）等等原因，最终导致了这次失败，排名170/230，不算罚时的话有120个同学大于3道，这下被永远铭记在北大OJ的耻辱柱上力。</p><p>补：结束后，把上机题重做了一遍，有的并没有想象中那么难，还是见得少+太紧张了，痛定思痛，暑假开始狂刷算法。</p><p><strong>面试</strong>：抱着机试占比不大的想法，速度调整心态，准备转天下午面试。博士4进2，两个本校✌，一个我很感激且很牛逼的金牌哥们，一个鼠鼠我。我经历过（好像也就第二次哈）最正式的面试，面试前要验明正身那种，时长20分钟。</p><ul><li>Part1: 5分钟PPT中文自我介绍；</li><li>Part2: 选一个数，抽一道题，包含数学（瞥见前一个哥们在手算矩阵），编程语言等等问题，我抽到的是<code>请介绍static,const,指针,引用的区别与用法</code>，挺八股，指针和引用不难，static和const直接按自己理解说的，说过一轮之后老师让我再多说点，我又凭自己的印象扯了点，const更是扯到了编译器设计；</li><li>Part3: 聊科研经历，让我讲讲生成式模型，我开始讲科研中使用的VAE的原理，老师们追问了解Diffusion么，前两天刚手搓过必须了解，但是我不擅于把这种硬核的技术讲明白，感觉回答的思路一塌糊涂，最后还扯到了条件Diffusion等等；</li><li>Part4: 英语文献翻译，由于前面我扯得太多，要超时了，就让读和翻译了两段，离散傅里叶变换相关的文章，我读的比较慢，有停顿，有的单词发音也有问题，这部分应该表现也比较一般。最后，l老师问我想读硕还是博，在网上看一般问这种问题已经是考虑录了，我紧张的说老师我愿意读博，最后在我无限的幻想中结束了这场面试。</li></ul><p><strong>结果</strong>：面试后和金牌哥们一起出的楼，聊了很多，得知他的工作和这边的工作很match，并且最后也问了相同的问题，加上两个本校✌，心凉了大半。晚上，金牌哥微信通知我收到了l老师的电话，但是他由于已经有其他去处打算放掉，有可能顺位到我，我的心率再一次飙到了180。后续就是，金牌哥没拒绝，但是北大最后也没给他优营，疑似被操盘了，这就是我们弱com啊。</p><p><strong>总结</strong>：不愧是北大，一路上历经多个惊心动魄的瞬间，和楷哥寄材料时遇见狂风暴雨，收到短信，收到入营通知，面试被问意向，以及收到金牌哥的微信。最后发现北大还是高攀了，但是当时伴随着其他营也没再入过，我开始怀疑自己的能力，对究竟能不能润出北航产生质疑，后续一段时间开始找本校导师，准备好烂在本校了云云，下文再谈。抛开机面试，北大这段经历的确令我难忘，和焦哥狂吃狂玩了两天，刷爆了北大送的200元食堂卡，在北大到处走走逛逛，也认识了来自校内校外的朋友。<del>我想人生就是在一次次没有预料的经历中才会变得有趣，我拼尽全力想要换一个环境也是为此。</del></p><p>扔几张北大两日游的图片（随时都能去，就不放风景照了哈哈）</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/d092d9d5f196dbbc54ecf6893dd6f66.jpg" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240916231818162.png" alt></p><h2 id="夏令营小结"><a href="#夏令营小结" class="headerlink" title="夏令营小结"></a>夏令营小结</h2><p>夏令营可以说是以全面失败告终，有我自己的原因，其一，bg无论是排名还是科研均差着点，rk是硬伤更是无力回天；其二，有着身为6系航男的傲气，只认准清北华五的计算机学院的学硕，还有点看不起清深北深等；其三，当时的想法是通过攻读研究生来寻找方向，而不是找到方向后有目标的寻找研究生归宿，仍处于很迷茫的状态（夏令营结束后更迷茫了）；当然也有专业学校等原因，比如今年的CS保研疑似又卷到了全新高度，同时北航向上保选择有限，更加艰难，后续发现身边的大家普遍有这种感受，有了些自我安慰。</p><p>但同时我也意识到了和他人的差距，并给出了暑假两个月内的最优解，将重心重点放在提升科研背景上，完成两篇论文的撰写，同时辅以练习CSP/力扣算法题，争取在预推免的初筛和机试两个环节中提高竞争力。</p><p>However，我对于面试一直感到十分恐惧，当初面试CO,OO,OS助教均失败的画面还历历在目。这两段经历使我积累了一些笔机面的经验，并养成了面试结束后及时复盘总结的良好习惯。</p><p><em>写于2024.09.16</em></p><p><em>杨博文</em></p>]]></content>
      
      
      <categories>
          
          <category> 感想随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 保研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『智谱清言』Linux裸机配置</title>
      <link href="/post/510af8c4.html"/>
      <url>/post/510af8c4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『智谱清言』Linux裸机配置"><a href="#『智谱清言』Linux裸机配置" class="headerlink" title="『智谱清言』Linux裸机配置"></a>『智谱清言』Linux裸机配置</h1><p>裸机只有网络功能，先挂载磁盘至<code>/data</code>。</p><h2 id="安装GCC"><a href="#安装GCC" class="headerlink" title="安装GCC"></a>安装GCC</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential</span><br></pre></td></tr></table></figure><h2 id="安装Nvidia驱动"><a href="#安装Nvidia驱动" class="headerlink" title="安装Nvidia驱动"></a>安装Nvidia驱动</h2><ol><li><p>查看显卡型号（4位16进制数）</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci | grep -i vga</span><br></pre></td></tr></table></figure><p> <img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240903142351811.png" alt></p></li><li><p>进入网站 <strong><em><a href="https://admin.pci-ids.ucw.cz/read/PC/10de/">https://admin.pci-ids.ucw.cz/read/PC/10de/</a></em></strong> ，查询4位16进制数，得到显卡型号</p><p> <img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240903142137410.png" alt></p></li><li><p>Nvidia官网下载对应版本的驱动（<strong><em><a href="https://www.nvidia.com/en-us/drivers">https://www.nvidia.com/en-us/drivers</a></em></strong>）文件 <code>NVIDIA-Linux-x86_64-550.107.02.run</code>，将文件放进<code>/root</code>目录下</p></li><li><p>安装驱动 <code>sh /path/to/your/driver</code>，<code>nvidia-smi</code>正常使用即为安装成功</p><p> <img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240903154739813.png" alt></p></li></ol><h2 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h2><ol><li>检查CUDA版本：12.4，查看Linux版本：Ubuntu 22.04.4 LTS</li><li><p>进入网站 <strong><em><a href="https://developer.nvidia.com/cuda-12-4-0-download-archive">https://developer.nvidia.com/cuda-12-4-0-download-archive</a></em></strong>，找到对应版本的安装包，下载安装（自动重定向到国内源）。</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/12.4.0/local_installers/cuda_12.4.0_550.54.14_linux.runsudo </span><br><span class="line">sh cuda_12.4.0_550.54.14_linux.run</span><br></pre></td></tr></table></figure></li><li><p>在<code>~/.bashrc</code>文件中写入（路径可查看安装后的输出信息，一般为以下路径，更改cuda版本号即可）：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/local/cuda-12.4/bin<span class="variable">$&#123;PATH:+:<span class="variable">$&#123;PATH&#125;</span>&#125;</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/local/cuda-12.4/lib64<span class="variable">$&#123;LD_LIBRARY_PATH:+:<span class="variable">$&#123;LD_LIBRARY_PATH&#125;</span>&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p>​    并 <code>source ~/.bashrc</code>更新，使用<code>nvcc -V</code>，若显示版本信息，则安装成功。</p><h2 id="安装AnaConda（一般不在宿主机运行Python…）"><a href="#安装AnaConda（一般不在宿主机运行Python…）" class="headerlink" title="安装AnaConda（一般不在宿主机运行Python…）"></a>安装AnaConda（一般不在宿主机运行Python…）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#下载annaconda</span><br><span class="line">wget https://repo.anaconda.com/archive/Anaconda3-2022.05-Linux-x86_64.sh</span><br><span class="line"></span><br><span class="line">#安装annaconda，安装中需要键入ENTER或输入yes</span><br><span class="line">bash Anaconda3-2022.05-Linux-x86_64.sh</span><br><span class="line"></span><br><span class="line">#配置annaconda环境变量，将下面命令写入~/.bashrc文件中（或.bash_profile文件，因系统而异）</span><br><span class="line">export PATH=/root/anaconda3/bin:$PATH</span><br><span class="line"></span><br><span class="line">#重新加载用户主目录下的.bash_profile文件，使设置的变量生效</span><br><span class="line">source ~/.bashrc</span><br><span class="line">#或者</span><br><span class="line">source .bash_profile</span><br><span class="line"></span><br><span class="line">#初始化Conda shell，使得Conda环境能够在当前的Shell中正常运行</span><br><span class="line">conda init</span><br></pre></td></tr></table></figure><h2 id="安装Docker-Nvidia-Docker"><a href="#安装Docker-Nvidia-Docker" class="headerlink" title="安装Docker/Nvidia-Docker"></a>安装Docker/Nvidia-Docker</h2><p>先安装正常的Docker</p><ol><li><p>安装依赖：</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install apt-transport-https ca-certificates curl gnupg-agent software-properties-common -y</span><br></pre></td></tr></table></figure></li><li><p>添加GPG密钥，设置stable仓库：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">sudo add-apt-repository  \</span><br><span class="line"><span class="string">&quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>安装docker:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></li><li><p><code>docker --version</code> 检查无误即安装成功！</p></li><li><p>设置镜像源，进入 <code>/etc/docker/daemon.json</code>配置文件，添加：</p></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://dockerproxy.com/&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://hub-mirror.c.163.com/&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://mirror.baidubce.com/&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://ccr.ccs.tencentyun.com/&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.rainbond.cc/&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>为使Docker内可以正常使用GPU，Nvidia提供了改进版的Docker，Nvidia-Docker</p><ol><li><p>配置存储库并更新包列表：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \</span><br><span class="line">  &amp;&amp; curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \</span><br><span class="line">    sed &#x27;s#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g&#x27; | \</span><br><span class="line">    sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list</span><br><span class="line">    </span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></li><li><p>安装 NVIDIA Container Toolkit 软件包：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y nvidia-container-toolkit</span><br></pre></td></tr></table></figure></li><li><p>使用 nvidia-ctk 命令配置容器</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nvidia-ctk runtime configure --runtime=docker</span><br></pre></td></tr></table></figure></li><li><p>重启Docker服务</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li></ol><h2 id="测试Docker"><a href="#测试Docker" class="headerlink" title="测试Docker"></a>测试Docker</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo docker container run hello-world  <span class="comment"># 测试docker</span></span><br><span class="line"></span><br><span class="line">sudo docker run --gpus all --name <span class="built_in">test</span> -it -v /home/user/:/workspace --ipc=host --<span class="built_in">ulimit</span> memlock=-1 --<span class="built_in">ulimit</span> stack=67108864 ubuntu:22.04 bash  <span class="comment"># 测试nvidia-docker</span></span><br></pre></td></tr></table></figure><p>启动后出现hello-world等信息，Docker即配置成功。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240903175805388.png" alt></p><p>启动后若能正确查看GPU信息，Nvidia-Docker即配置成功。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240903175652897.png" alt></p><p>注：非root用户执行docker命令时需要sudo权限，若不想每次都输入sudo，则可设置Docker权限后，重新登陆。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker <span class="variable">$USER</span> <span class="comment"># 当前用户</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://blog.csdn.net/QQ896710872/article/details/136782475">https://blog.csdn.net/QQ896710872/article/details/136782475</a></li><li><a href="https://blog.csdn.net/magic_ll/article/details/139985543">https://blog.csdn.net/magic_ll/article/details/139985543</a></li><li><a href="https://blog.csdn.net/qq_40647372/article/details/134940480">https://blog.csdn.net/qq_40647372/article/details/134940480</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 机器学习系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> Linux </tag>
            
            <tag> 实习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『智谱清言』CogVLM2部署实践</title>
      <link href="/post/b5b4da6e.html"/>
      <url>/post/b5b4da6e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『智谱清言』CogVLM2部署实践"><a href="#『智谱清言』CogVLM2部署实践" class="headerlink" title="『智谱清言』CogVLM2部署实践"></a>『智谱清言』CogVLM2部署实践</h1><p>入职智谱后的第一项工作的一个Part，浅浅记录。</p><h2 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h2><p><code>CUDA 12.1</code> 的<code>ubuntu</code>宿主机一台</p><p>注意：cuda版本应与torch版本对应，实测 CUDA 12.0 也可以正常运行</p><p>下载适配<code>TGI</code>的<code>CogVLM2</code>模型至路径<code>/model</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> modelscope <span class="keyword">import</span> snapshot_download </span><br><span class="line"></span><br><span class="line">model_dir = snapshot_download(<span class="string">&#x27;ZhipuAI/cogvlm2-llama3-chinese-chat-19B-tgi&#x27;</span>, cache_dir=<span class="string">&quot;/data/cogvlm2-llama3-chinese-chat-19B&quot;</span>)</span><br></pre></td></tr></table></figure><p>下载适配<code>CogVLM2</code>的<code>TGI</code>包至路径<code>/tgi</code>: <strong><em><a href="https://github.com/leizhao1234/cogvlm2">https://github.com/leizhao1234/cogvlm2</a></em></strong></p><h2 id="正式流程"><a href="#正式流程" class="headerlink" title="正式流程"></a>正式流程</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载conda并安装</span></span><br><span class="line">curl -O https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line">sh Miniconda3-latest-Linux-x86_64.sh</span><br><span class="line"><span class="comment">#创建conda环境</span></span><br><span class="line">conda create -n tgi python=3.10</span><br><span class="line">conda activate tgi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加速rust下载</span></span><br><span class="line"><span class="built_in">export</span> RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static</span><br><span class="line"><span class="built_in">export</span> RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup</span><br><span class="line"><span class="comment"># 安装rust</span></span><br><span class="line">curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 -sSf https://sh.rustup.rs | sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载protobuf</span></span><br><span class="line">PROTOC_ZIP=protoc-21.12-linux-x86_64.zip</span><br><span class="line">curl -OL https://github.com/protocolbuffers/protobuf/releases/download/v21.12/<span class="variable">$PROTOC_ZIP</span></span><br><span class="line">sudo unzip -o <span class="variable">$PROTOC_ZIP</span> -d /usr/local bin/protoc</span><br><span class="line">sudo unzip -o <span class="variable">$PROTOC_ZIP</span> -d /usr/local <span class="string">&#x27;include/*&#x27;</span></span><br><span class="line"><span class="built_in">rm</span> -f <span class="variable">$PROTOC_ZIP</span></span><br><span class="line"></span><br><span class="line">pip install torch==2.3.0 torchvision==0.18.0 torchaudio==2.3.0 --index-url https://download.pytorch.org/whl/cu121 <span class="comment"># 注意torch和cuda版本的对应！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 openssl 和 pkg-config 工具</span></span><br><span class="line">apt-get install libssl-dev gcc -y</span><br><span class="line">apt install pkg-config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 cmake</span></span><br><span class="line">apt install cmake</span><br></pre></td></tr></table></figure><p>此时基础环境安装完毕，接下来是编译环节。</p><p>首先打开<code>/tgi/rust-toolchain.toml</code>，将版本修改为<code>&gt;=1.79.0</code>，如下：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[toolchain]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Released on: 02 May, 2024</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># https://releases.rs/docs/1.79.0/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">channel</span> = <span class="string">&quot;1.79.0&quot;</span> </span><br><span class="line"><span class="attr">components</span> = [<span class="string">&quot;rustfmt&quot;</span>, <span class="string">&quot;clippy&quot;</span>]</span><br></pre></td></tr></table></figure><p>接下来进入<code>TGI</code>的根目录<code>/tgi</code>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入text-text-generation-inference目录，编译基本组件 </span></span><br><span class="line">BUILD_EXTENSIONS=True make install</span><br><span class="line"></span><br><span class="line">cd server</span><br><span class="line">make install-vllm-cuda </span><br><span class="line">make build-apex </span><br><span class="line">make install-flash-attention-v2-cuda</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：Makefile中涉及从Github上拉取<code>vllm</code>和<code>apex</code>包的代码，若服务器无法访问Github，则需使用其他方法下载<code>vllm</code>(<strong><em><a href="https://github.com/Narsil/vllm">https://github.com/Narsil/vllm</a></em></strong>)和<code>apex</code>(<strong><em><a href="https://github.com/NVIDIA/apex">https://github.com/NVIDIA/apex</a></em></strong>)后（<code>master</code>分支即可），将其放于<code>/tgi/server</code>目录下，最终文件结构为<code>/tgi/server/vllm, /tgi/server/apex</code>。随后删除<code>/tgi</code>目录下的<code>Makefile-apex, Makefile-vllm</code>文件中<code>git</code>相关命令，再执行上述<code>make</code>命令编译。</p><h2 id="测试与部署"><a href="#测试与部署" class="headerlink" title="测试与部署"></a>测试与部署</h2><p>检查<code>TGI</code>是否编译成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text-generation-launcher --version</span><br><span class="line">text-generation-launcher 2.0.5-dev0</span><br></pre></td></tr></table></figure><p>使用<code>TGI</code>部署模型，其余配置含义请参考（<strong><em><a href="https://huggingface.co/docs/text-generation-inference/en/reference/launcher">https://huggingface.co/docs/text-generation-inference/en/reference/launcher</a></em></strong>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CUDA_VISIBLE_DEVICES=6,7 text-generation-launcher --model-id &#123;/model&#125; --num-shard 2 --port 8081 --max-concurrent-requests 409600 --max-input-length 8190 --max-total-tokens 8192 --max-batch-prefill-tokens 8192 --trust-remote-code --max-waiting-tokens 2 --waiting-served-ratio 0.2 --cuda-memory-fraction 0.97 --cuda-graphs 0 --dtype bfloat16</span><br><span class="line"></span><br><span class="line">CUDA_VISIBLE_DEVICES=6,7: 选定使用的GPU编号</span><br><span class="line">--num-shard 2: 使用GPU数目</span><br><span class="line">--port 8081: 开放端口</span><br></pre></td></tr></table></figure><p>全程无报错即为启动成功！</p><p>测试参考<strong><em><a href="https://modelscope.cn/models/ZhipuAI/cogvlm2-llama3-chinese-chat-19B-tgi">https://modelscope.cn/models/ZhipuAI/cogvlm2-llama3-chinese-chat-19B-tgi</a></em></strong>，暴露的路径应为<code>/generate</code>，因此需要修改代码中<code>url</code>变量为<code>url = &#39;http://localhost:&#123;port&#125;/generate&#39;</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 深度学习 </category>
          
          <category> MLLM/LLM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 实习 </tag>
            
            <tag> MLLM/LLM </tag>
            
            <tag> 机器学习系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『黑神话悟空』游玩感想</title>
      <link href="/post/7418dfd8.html"/>
      <url>/post/7418dfd8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『黑神话悟空』《黑神话-悟空》游玩感想"><a href="#『黑神话悟空』《黑神话-悟空》游玩感想" class="headerlink" title="『黑神话悟空』《黑神话-悟空》游玩感想"></a>『黑神话悟空』《黑神话-悟空》游玩感想</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>8月24日上午，《黑神话-悟空》刚发售四天，打过二郎神和最终boss后，我想来不及进一步细细品味，便需要立即投身迫在眉睫的预推免之中，然而在此之前，还是有必要为这款游戏谈一谈感触，画上一个短暂不圆满的句号。</p><h3 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h3><p>作为铁血魂小将，我在高二升高三的暑假肝了150小时的魂三，第一支预告片发出的第一时刻我便在现场见证历史，随后被其深深震撼，“魂游”(别喷我)+西游，要素拉满，而且Demo里的美术，场景等已经相对成熟，我当时便断定这款游戏必定会掀起轩然大波，随后了解到当时只是在开发初期，缺人手，发售遥遥无期。还记得哥几个都在开玩笑说，大学能玩上就是胜利，接着投入到备战高考的复习中去。</p><p>时间一晃过了四年，我经历了高考，选择了北航，沉浸式游玩了<strong>《艾尔登法环》</strong>，进入了计算机学院，遭受两年惨无人道的折磨并成长着，这款游戏想必也是如此。每年的相同时候都会发布最新预告片，我也会毫无例外的准时观看，然而随着课业压力的加重，大幅降低了很快想玩到的期待感，直至最近，正值在高考后的又一人生关键转折点，黑神话终于千呼万唤始出来，我见证了它的从无到有，彷佛它也见证了我的前半段人生。</p><h3 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h3><p>发售当天乃至后三日，我在中科院计算所参加暑期学校，发售当天上午听着讲座时我便已经归宿舍似箭，然而总是到晚上才有时间启动，于是不可避免的熬了几天夜，也在转天教授们的报告上打了瞌睡（对不住）。当然除了时间上的debuff，设备上更是给我上了debuff，八月初手贱把注册表删了一部分，导致资源管理器的下边工具栏无法操作，游戏无法全屏；落后的1650的显卡导致画质低渲染慢；外置硬盘存储导致加载一个场景就要五分钟，这几个原因为我三天的开荒游玩带来了极其糟糕的体验，好在回学校后迎来了新笔记本，在更困难的后半段收获了顶级游戏体验，也让我不禁感慨，用旧电脑干二郎神怕是一辈子都过不去。</p><p>这款游戏从战斗难度而言与魂相比不算高，大致全流程通关花费了30个小时左右，无论如何，能在此时此刻拿出30个小时的时间去玩游戏，怎么想还是很大胆，因此在游玩过程中，我始终抱着“赶快通关这一章”，“打完赶快结束”这类想法，剧情CG没跳看了个爽，但并未细致阅读过游戏内的文本。战斗难度于我而言适中，但是架不住量大管饱，有几个卡的时间较久的boss趁现在记录一下，<strong>虎先锋</strong>，<strong>黄风大王</strong>，<strong>寅虎</strong>，<strong>百眼魔君</strong>，以及最出生的黑神话版女武神<strong>二郎显圣真君</strong>。好在魂游爱好者+学计算机学的我练就了好心态，诚然这份心态已大不如前，在某种程度上被现实境遇所裹挟，失去了曾经玩游戏的本心，想必未来有时间时，可以沉下心来再一次细品这款游戏。</p><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>先说结论，摒弃掉影响本人的客观因素，这款游戏值得9.5分乃至10分（只狼可以给10，法环9.5），无论今年年度最佳究竟落谁家，相信在我乃至无数人心里《黑神话》便是最佳。</p><p>接下来谈谈我这款游戏的优点和缺点，这款游戏最先吸引我的是“魂类”抖m玩法，boss的多样性与挑战性，随后是西游IP的情怀加成，我曾经便想象过八十一难这么多妖怪能设计出多少有趣的boss，加之已有的中国神话世界观，怎么想都和“魂类”游戏契合无比，而如今事实也证实了这点。</p><p>先是<strong>战斗系统设计</strong>。即使面对一些boss时已经看腻了实机演示，没有初见的惊喜感，但是亲自上手挑战时能发现制作者对于动作的极致用心，猴子随着等级成长的高性能换来的是boss的越来越高性能，这便允许设计师放开手设计boss，战斗令人印象深刻的有教官虎先锋大开大合，韧狗寅虎迅捷如风而又势大力沉的进攻，四管甲三形态的二郎神，演出有亢金龙娘，黄眉，红孩儿，二郎神等的眼花缭乱的超帅战斗演出，总体来说每个妖王和头目级的boss都各有特色且有众多彩蛋，并未出现素材重用的情况，从细节上来说，关底boss总是对应一件克制其的与原著对应的法宝，使用可以大幅降低难度，让受苦玩家有了常规的通关手段。主角的战斗系统类似仁王的一种武器分为三种战斗模组，配合定身，替身等法术，还有“魂核”，“魔化”和法宝(救我狗命)这三样战斗底牌，自由分配流派加点策略，自由度高，但在游戏发售前期并未有过多开发，套路较为固定，坦白说不如众多boss设计出彩，但也无可厚非，毕竟用原始人大战三体人正是挑战的乐趣。从交互上来讲，游戏有只狼类似的弹刀，棍反机制，极限闪避机制，多方法攒豆机制等，无论是压制策略还是回合制策略，资源交换是战斗的核心要素，除了读指令等不可不尝的游戏特色外，游戏中存在一些较为恶意的机制，比如受击吞法术等，这方面仍有待提高。</p><p>接着是<strong>剧情与流程设计</strong>。全篇以老套的收集六样物品复活悟空为主线分六章，每一章都有半符合原著的与守关boss相关的各自剧情，主线大致立意是在讨论善恶，以及赞颂孙悟空的斗争精神。于我个人而言较为出彩应当是各章节的独立设计，包括狠狠文化输出的令人惊艳的章节末中国式动画，把主线和章节间的联系，曾经的西行，遇到过的大妖的前世今生，或隐晦或直接的以动画形式表现。将非主角的人设（五大妖+众多支线人物）营造出色而非扁平化，制作组很好的做到了这一点。眼下有众多论调，谈及主线剧情烂，与预告片不符云云，诚然剧情还有待解读，便不发表过多看法。从流程设计来讲，章节难度递进把控到位，并未出现类似法环雪原的数值怪，然而地图设计大而空，空气墙多，小怪分布少，以boss场地居多，越往后章节越明显，同时流程无引导，有些支线和地图隐藏极深，不细致阅读文本或看攻略则必然错过，而隐藏内容占据了该游戏很大部分，不过这也算不得不品的特色，就像是只狼里挑战盛年义父的隐藏流程一样。地图并非传统魂类箱庭式地图（或者说没学到精髓），还算做人的是把遇到的支线npc会标注在传送点上，不过何必以“魂类”设计去约束设计呢，令我惊喜的是土地庙的名字都很好听，充满了中国气息，总体来说瑕不掩瑜。</p><p>最后是<strong>美术音乐设计</strong>。六张大地图，包含森林，荒漠，雪原，山脉等各具特色的地形，有机结合了来自中国多个文化古迹的场景建模，文化输出拉满，打坐时带来全景IMAX顶级享受，然而仅限于惊讶于全景的设计，在跑图时我往往忽略了欣赏周围的景色，在战斗时又沉浸在与boss的交锋之中。提到令人沉浸那不得不提战斗音乐，魂游吸引我的一大理由便是每个boss都专门设计其主题曲，一来是增加战斗沉浸感，二来是细细品味歌词与旋律后，为boss塑造起血与肉。令我印象深刻的有最终boss战时疑似《敢问路在何方》的改编版，逐渐昂扬的曲调令游戏效果达到顶峰，然而在游玩时，许多boss和猪八戒都是话痨，嘴一刻不闲，故并未过多关注音乐，不过对白同样能起到营造人设的效果，况且诸多对白充满神话与武侠色彩，听的我热血沸腾，中二之魂燃起。总结而言便是我打的有点急，这部分并未关注，日后细品，着急结尾。</p><h3 id="终"><a href="#终" class="headerlink" title="终"></a>终</h3><p>一转眼写了两个小时，也该摒弃杂念面对生活了，这份四年的等待并没有让我失望。</p><p>结尾报幕时，我看到一款游戏需要付出的人力物力远超出想象，更难以想象PM是如何能有条不紊的调度一切。几年的学习让我明白开发游戏并非遥不可及，而我也期望开发一款伟大的游戏，如今以初步具备了个人条件，只是未来的路究竟在何方。</p><p><em>“敢问路在何方，路在脚下”</em></p>]]></content>
      
      
      <categories>
          
          <category> 感想随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『机器学习系统』Deepseekv2</title>
      <link href="/post/d5823525.html"/>
      <url>/post/d5823525.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『机器学习系统』Deepseek-V2"><a href="#『机器学习系统』Deepseek-V2" class="headerlink" title="『机器学习系统』Deepseek-V2"></a>『机器学习系统』Deepseek-V2</h1><p>基于Decoder-Only架构，对FFN和Attention做出了改进。</p><h2 id="MLA（Multi-head-Latent-Attention）："><a href="#MLA（Multi-head-Latent-Attention）：" class="headerlink" title="MLA（Multi-head Latent Attention）："></a>MLA（Multi-head Latent Attention）：</h2><ol><li><p><strong>传统MHA</strong>：需要 $2 \ast len \ast nhead \ast d_{nhead}$ 的空间存储 <em>KV Cache</em></p></li><li><p><strong>MLA</strong>: 将<em>K</em>和<em>V</em>进行低秩联合压缩，以减少KV缓存，类似LoRA。将KV以低维度缓存，使用时再通过投影层变换回去。减少内存占用的同时丢失部分精度。</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240802145514573.png" alt></p></li><li><p>旋转位置编码：待补充</p></li></ol><h2 id="FFN-MoE"><a href="#FFN-MoE" class="headerlink" title="FFN(MoE):"></a>FFN(MoE):</h2><ol><li><p>MoE: 混合专家模型，在本模型架构中主要是在FFN层体现</p></li><li><p>将专家分为共享专家与路由专家，以token为粒度：</p><ol><li>共享专家：每个 $input$ 必须要通过$N_s$个共享专家，无权重，直接相加。</li><li>路由专家：在$N<em>r$个路由专家中选取$Top_k$个亲和度最高的专家激活，并计算每个激活专家归一化后的权重$g</em>{i,t}$，将输出按权重分配相加。</li><li><strong>如何选择专家</strong>：router的权重为$R^{nRoutedExperts \ast gatingDim}$($gatingDim=h$)，对每个token($R^{(bsz \ast l)\ast h}$)计算一个门控分数，再对最后一维做softmax得到分数$R^{(bsz \ast l) \ast nRoutedExperts}$，每个token各自排序得到前$topk$个亲和力最高的专家，进行后续传播。</li><li>专家通常分配到不同的硬件加速器上，为减少通信开销，额外要求每个token最多分布到$M$个设备上。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240802151223792.png" alt></p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240802150403312.png" alt></p></li></ol><h2 id="三个辅助损失函数"><a href="#三个辅助损失函数" class="headerlink" title="三个辅助损失函数"></a>三个辅助损失函数</h2><ol><li><p><strong>专家级负载平衡</strong>：减少路由崩溃的风险</p><ol><li>理想情况下，每个专家的负载应该为 $seq \ast topk/nRouterExperts$</li><li>统计现实情况下的负载（对于一个样本）：$R^{nRouterExperts}$统计每个experts使用的次数</li><li>现实负载除以理想负载，得到差异$f_i$，理想情况下应该为全1，现实情况应当部分大于1，部分小于1。</li><li>计算每个专家对于所有token的平均亲和度，记为$P_i \in R^{nRouterExperts}$</li><li>二者点积后乘超参数得到损失</li><li><p>设计理念：既希望每个专家能够均衡负载，又需要考虑每个专家的贡献（负载均衡+贡献均衡）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">scores_for_aux = scores</span><br><span class="line">aux_topk = self.top_k</span><br><span class="line"><span class="comment"># always compute aux loss based on the naive greedy topk method</span></span><br><span class="line">topk_idx_for_aux_loss = topk_idx.view(bsz, -<span class="number">1</span>)</span><br><span class="line">scores_for_seq_aux = scores_for_aux.view(bsz, seq_len, -<span class="number">1</span>)</span><br><span class="line">ce = torch.zeros(</span><br><span class="line">    bsz, self.n_routed_experts, device=hidden_states.device</span><br><span class="line">)</span><br><span class="line">ce.scatter_add_(</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    topk_idx_for_aux_loss,</span><br><span class="line">    torch.ones(bsz, seq_len * aux_topk, device=hidden_states.device),</span><br><span class="line">).div_(seq_len * aux_topk / self.n_routed_experts)</span><br><span class="line">aux_loss = (ce * scores_for_seq_aux.mean(dim=<span class="number">1</span>)).<span class="built_in">sum</span>(</span><br><span class="line">    dim=<span class="number">1</span></span><br><span class="line">).mean() * self.alpha</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240802153340709.png" alt></p></li></ol></li><li><p><strong>设备级负载平衡</strong>：将专家分为D组，分配到D个设备上，类似于专家损失，此时负载差异值的计算仍是以专家为单位，只不过计算了每个设备上专家负载的均值</p><ol><li>对于每台设备，计算$f_{i}^{‘}$，即一台设备上每个专家的负载差异均值</li><li>对于每台设备，计算$P^{‘}_{i}$，即一台设备上每个专家的平均亲和度之和</li><li><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> 实现device_loss，假设按顺序将专家分组</span></span><br><span class="line"><span class="comment"># [bsz, num_experts] -&gt; [bsz, n_groups]</span></span><br><span class="line">alpha2 = self.alpha</span><br><span class="line">experts_per_device = self.n_routed_experts // self.n_group</span><br><span class="line">ce_groups = ce.view(bsz, self.n_group, experts_per_device).mean(dim=-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># [bsz, seq_len, num_experts] -&gt; [bsz, num_experts] -&gt; [bsz, n_groups]</span></span><br><span class="line">p_groups = scores_for_seq_aux.mean(dim=<span class="number">1</span>).view(bsz, self.n_group, experts_per_device).<span class="built_in">sum</span>(dim=-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># [bsz, num_groups] -&gt; [bsz] -&gt; value</span></span><br><span class="line">device_loss = (ce_groups * p_groups).<span class="built_in">sum</span>(dim=<span class="number">1</span>).mean() * alpha2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240802160810459.png" alt></p></li></ol></li><li><p><strong>通信级负载平衡</strong>：保证各设备的通信均衡，每个设备接收到的token数量也应该保持均衡</p><ol><li>理想情况下，由于设备限制，每个token最多被发送到$M$台设备，则每台设备的接收量大约应为$M \ast seqlen/D$ 个token。</li><li>计算现实情况下每台设备的实际token接收量</li><li>后续流程相同</li><li>代码实现：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> 实现comm_loss</span></span><br><span class="line">alpha3 = self.alpha</span><br><span class="line">ce_comm = torch.zeros(</span><br><span class="line">    bsz, self.n_routed_experts, device=hidden_states.device</span><br><span class="line">)</span><br><span class="line"><span class="comment"># [bsz, n_groups]</span></span><br><span class="line">ce_comm = ce_comm.scatter_add_(</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    topk_idx_for_aux_loss,</span><br><span class="line">    torch.ones(bsz, seq_len * aux_topk, device=hidden_states.device),</span><br><span class="line">).view(bsz, self.n_group, experts_per_device).<span class="built_in">sum</span>(dim=-<span class="number">1</span>).div_(seq_len * self.topk_group / self.n_group)</span><br><span class="line">p_comm = p_groups</span><br><span class="line">comm_loss = (ce_comm * p_comm).<span class="built_in">sum</span>(dim=<span class="number">1</span>).mean() * alpha3</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240802164334858.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>三个负载平衡机制层次由低至高，从底层的<strong>专家平衡</strong>、到中层的<strong>设备平衡</strong>、再到顶层的<strong>通信平衡</strong>共同作用，旨在优化MoE系统的资源利用并解决专家崩溃等问题，实现了强大的性能。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 深度学习 </category>
          
          <category> MLLM/LLM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> 实习 </tag>
            
            <tag> MLLM/LLM </tag>
            
            <tag> 机器学习系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『机器学习系统』Ray使用文档</title>
      <link href="/post/aa8ef5fe.html"/>
      <url>/post/aa8ef5fe.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『机器学习系统』Ray使用文档"><a href="#『机器学习系统』Ray使用文档" class="headerlink" title="『机器学习系统』Ray使用文档"></a>『机器学习系统』Ray使用文档</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>ray的用法做个拆解，弄清ray的基础原理和用法</p></li><li><p>着重介绍利用ray如何部署 vLLM？比如怎么启动ray，怎么启动多个vLLM实例，多个dp rank 怎么调用它？</p></li></ol><h2 id="Ray是什么"><a href="#Ray是什么" class="headerlink" title="Ray是什么"></a>Ray是什么</h2><p>Ray是一个开源分布式计算框架，为AI等上层应用提供了<strong>并行处理的计算层</strong>，大幅降低分布式工作流程的复杂性。</p><ol><li>可以跨多节点和GPU并行和分配ML的工作负载</li><li>可以提供计算抽象（统一的API）进行ML系统的扩展集成</li><li>自动处理关键流程，如编排，调度，容错，自动缩放等。</li><li>大量的库都使用Ray作为并行执行的组件</li></ol><h2 id="Ray的基本原理"><a href="#Ray的基本原理" class="headerlink" title="Ray的基本原理"></a>Ray的基本原理</h2><h3 id="Ray-Core"><a href="#Ray-Core" class="headerlink" title="Ray Core"></a>Ray Core</h3><h4 id="Task（任务）："><a href="#Task（任务）：" class="headerlink" title="Task（任务）："></a>Task（任务）：</h4><p>异步执行的Ray函数称作“任务”，也成为Ray远程函数。当一个新的Task被实例化时，会创建一个新的进程(worker)进行对其的调度。Ray使任务能够根据CPU，加速器等资源来指定其资源需求。</p><p>使用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ray.remote  </span><span class="comment"># 通过该装饰器将函数改装为Ray远程函数，默认分配一个CPU</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">obj_ref = fun.remote(a)  <span class="comment"># 通过使用remote()方法激活函数，首先立即会返回一个结果的future对象，并创建一个异步任务开始执行</span></span><br><span class="line">value = rey.get(obj_ref)  <span class="comment"># 通过ray.get获得返回结果</span></span><br></pre></td></tr></table></figure><p>同时，远程对象引用也可以当作参数传递：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ray.remote</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function_with_an_argument</span>(<span class="params">value</span>):</span><br><span class="line">    <span class="keyword">return</span> value + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">obj_ref2 = function_with_an_argument.remote(obj_ref)  <span class="comment"># 将对象引用作为任务的参数</span></span><br><span class="line"><span class="keyword">assert</span> ray.get(obj_ref2) == <span class="number">2</span></span><br></pre></td></tr></table></figure><p>此时，第二个任务取决于第一个任务的输出，因此第二个任务要等待第一个任务执行完毕才开始。若调度在不同的设备上，则结果需要通过网络传输。</p><h4 id="Actors（参与者）："><a href="#Actors（参与者）：" class="headerlink" title="Actors（参与者）："></a>Actors（参与者）：</h4><p>将函数扩展到类，参与者本质上是能存储状态的函数/服务。当一个新的Actor被实例化时，会创建一个新的进程进行对其的调度。同样，参与者支持CPU,加速器和自定义的资源请求。</p><p>使用方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ray.remote </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.value = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increment</span>(<span class="params">self</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        self.value += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;counter: <span class="subst">&#123;self.value&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_counter</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.value</span><br><span class="line"></span><br><span class="line">c = Counter.remote()  <span class="comment"># 实例化，创建一个worker，等待调度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="comment"># 调用类内函数的方式与执行Task一样，采用remote()激活</span></span><br><span class="line">    <span class="comment"># 采用异步执行方式，调度器提交的任务会发送至参与者的等待队列中，参与者依次执行等待队列中的任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;scheduler: <span class="subst">&#123;_&#125;</span>&#x27;</span>)</span><br><span class="line">    c.increment.remote()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ray.get(c.get_counter.remote()))</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">scheduler: 0</span><br><span class="line">scheduler: 1</span><br><span class="line">scheduler: 2</span><br><span class="line">scheduler: 3</span><br><span class="line">scheduler: 4</span><br><span class="line">scheduler: 5</span><br><span class="line">scheduler: 6</span><br><span class="line">scheduler: 7</span><br><span class="line">scheduler: 8</span><br><span class="line">scheduler: 9</span><br><span class="line">(Counter pid=32160) counter: 1</span><br><span class="line">(Counter pid=32160) counter: 2</span><br><span class="line">(Counter pid=32160) counter: 3</span><br><span class="line">(Counter pid=32160) counter: 4</span><br><span class="line">(Counter pid=32160) counter: 5</span><br><span class="line">(Counter pid=32160) counter: 6</span><br><span class="line">(Counter pid=32160) counter: 7</span><br><span class="line">(Counter pid=32160) counter: 8</span><br><span class="line">(Counter pid=32160) counter: 9</span><br><span class="line">(Counter pid=32160) counter: 10</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h4 id="Objects（对象）："><a href="#Objects（对象）：" class="headerlink" title="Objects（对象）："></a>Objects（对象）：</h4><p>在Ray中，任务和参与者在对象上创建和计算，将这些对象成为远程对象。它们可以存储在Ray集群的任何位置，并通过对象引用（指针）来引用它们。</p><p>远程对象可以被缓存在Ray的分布式共享内存中，集群的每个节点都有一块共享内存，同时一个远程对象也可以存放在多个节点中。</p><p>创建对象引用的两种方式：</p><ol><li>remote函数调用获取返回值的对象引用</li><li><code>ray.put()</code>将某对象放置于Ray的共享内存上并返回在该共享内存上的远程对象引用</li></ol><h4 id="Env-Dependency（依赖环境）："><a href="#Env-Dependency（依赖环境）：" class="headerlink" title="Env Dependency（依赖环境）："></a>Env Dependency（依赖环境）：</h4><p>每个节点需要相同的依赖环境，Ray提供两种方案：</p><ol><li><p>静态依赖时，在运行前使用Ray Cluster Launcher将依赖打包</p></li><li><p>动态依赖时，使用Ray的运行时依赖环境，在运行时安装仅对Ray应用可见的包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runtime_env = &#123;<span class="string">&quot;pip&quot;</span>: [<span class="string">&quot;emoji&quot;</span>]&#125;</span><br><span class="line"></span><br><span class="line">ray.init(runtime_env=runtime_env)</span><br></pre></td></tr></table></figure></li></ol><h4 id="Scheduling（调度）："><a href="#Scheduling（调度）：" class="headerlink" title="Scheduling（调度）："></a><strong>Scheduling（调度）</strong>：</h4><p>对每个任务和参与者都有指定的资源需求。</p><h5 id="资源："><a href="#资源：" class="headerlink" title="资源："></a>资源：</h5><ol><li><p>节点的资源：</p><ol><li><p>资源初始化：每个节点通过<code>ray.init(num_cpus=?,num_gpus=?,memory=?,custom_resource=?)</code>进行资源初始化</p></li><li><p>资源用键值对表示：键为资源名称，值为浮点数</p></li><li><p>使用逻辑资源抽象：不需要物理资源建立一对一映射</p></li><li><p>通常CPU的使用不会隔离，而GPU的使用会隔离</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240804164915305.png" alt></p></li></ol></li><li><p>节点的状态（针对需要资源的任务或参与者）：</p><ol><li><p>可行：又分为可用（具有资源且此刻可使用）与不可用（具有资源但此刻被占用）</p></li><li><p>不可行：节点无法分配所需的资源</p></li></ol></li><li><p>加速器资源：支持GPU,TPU,NPU等等</p><ol><li>Ray内部可通过改变环境变量<code>CUDE_VISIBLE_DEVICE</code>在任务或参与者进程中只暴露分配给他们的GPU资源，也可人为在外部设置环境变量隐藏某些物理设备。</li><li>碎片化分配：分配加速器的数量可以是小数，使得多个任务可共享同一加速器</li><li>可强制指定加速器类型</li></ol></li><li><p>内存资源：</p><ol><li><p>Ray系统内存：用于存储每个节点信息，每个节点上的进程信息等内容</p></li><li><p>应用程序内存:</p><ol><li>工作堆</li><li>对象存储内存：应用程序通过ray.put在对象存储创建对象以及从远程函数返回值时使用的内存</li><li>对象存储共享内存：应用程序通过ray.get读取对象时使用的内存，通常节点上若已存储该对象，则无需额外的分配</li></ol></li></ol><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240804185436515.png" alt></p></li></ol><h5 id="调度策略："><a href="#调度策略：" class="headerlink" title="调度策略："></a>调度策略：</h5><p>决定可行节点中的最佳节点</p><ol><li>默认：根据利用率由低至高排序取前k个节点，再随机选择。对于不需要任何资源（num_cpus=0）的任务，会随机选择一个节点。</li><li>Spread：将任务分散到全部节点。</li></ol><h5 id="Placement-Groups（置放组）："><a href="#Placement-Groups（置放组）：" class="headerlink" title="Placement Groups（置放组）："></a>Placement Groups（置放组）：</h5><p>允许用户跨多个节点进行组调度，可用于安排任务和参与者，使其尽可能靠近本地（PACK）或分散（SPREAD）。</p><p>Buddle(捆绑包)：将一系列资源打包成捆绑包，作为预留资源，仅通过专门操作才能调度这些资源。</p><p>Placement Group(置放组)：一组捆绑包列表，根据集群节点的放置策略放置捆绑包</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240804173905557.png" alt></p><h3 id="Ray集群"><a href="#Ray集群" class="headerlink" title="Ray集群"></a>Ray集群</h3><p>由单个头节点和任意数量的连接工作节点组成，<strong>Ray中节点的最小单位是服务器</strong></p><ol><li>头节点：运行负责集群管理的单例进程，包括自动缩放器，GCS（全局控制服务），Ray驱动，其余功能与工作节点一致<ol><li>自动缩放器（AutoScaling）：根据负载动态增加删除工作节点</li><li>Ray驱动：接收提交的Ray作业，调度作业，将其分配至各工作节点执行。</li></ol></li><li>工作节点：运行任务或参与者的用户代码</li><li>作业（Ray Jobs）：单个应用程序，源自同一脚本的任务，参与者等集合。各个节点都可以通过Ray Job API或Python脚本来运行作业。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240804192104232.png" alt></p><h4 id="集群建立"><a href="#集群建立" class="headerlink" title="集群建立"></a>集群建立</h4><ol><li><p>使用Ray的配置文件，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cluster_name:</span> <span class="string">my_cluster</span></span><br><span class="line"><span class="comment"># 分为头节点和多个工作节点，其他进程或机器通过头节点连接进集群</span></span><br><span class="line"><span class="attr">head_node:</span></span><br><span class="line">  <span class="attr">node_ip_address:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">node_name:</span> <span class="string">node1</span></span><br><span class="line"><span class="attr">worker_nodes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">node_ip_address:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line">    <span class="attr">node_name:</span> <span class="string">node2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">node_ip_address:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.3</span></span><br><span class="line">    <span class="attr">node_name:</span> <span class="string">node3</span></span><br></pre></td></tr></table></figure></li><li><p>使用CLI： <code>ray start --head --port=&#123;port&#125; --redis-password=&quot;&#123;password&#125;&quot;</code></p></li><li><p>使用python脚本： <code>ray.init()</code></p></li></ol><h4 id="集群连接（工作节点-主节点的其他进程-连接进主节点）"><a href="#集群连接（工作节点-主节点的其他进程-连接进主节点）" class="headerlink" title="集群连接（工作节点/主节点的其他进程 连接进主节点）"></a>集群连接（工作节点/主节点的其他进程 连接进主节点）</h4><p><code>ray.init(address=&quot;&#123;ip&#125;:&#123;port&#125;&quot;, redis_password=&#123;password&#125;)</code></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>采用Python API的方式，而非CLI。</p><h3 id="启动Ray并部署vLLM"><a href="#启动Ray并部署vLLM" class="headerlink" title="启动Ray并部署vLLM"></a>启动Ray并部署vLLM</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ray</span><br><span class="line"><span class="keyword">from</span> vllm <span class="keyword">import</span> LLM, SamplingParams</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&quot;HF_ENDPOINT&quot;</span>] = <span class="string">&quot;https://hf-mirror.com&quot;</span></span><br><span class="line">ray.init(num_gpus=<span class="number">8</span>, num_cpus=<span class="number">64</span>)</span><br><span class="line"><span class="built_in">print</span>(ray.nodes())  <span class="comment"># CPU: 96, GPU: 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># assert 1 == 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ray.remote(<span class="params">num_gpus=<span class="number">2</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vLLMWrapper</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.model = LLM(model=<span class="string">&quot;facebook/opt-125m&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self, prompts, sampling_params</span>):</span><br><span class="line">        outputs = self.model.generate(prompts, sampling_params)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Print the outputs.</span></span><br><span class="line"></span><br><span class="line">        re_outputs = []</span><br><span class="line">        <span class="keyword">for</span> output <span class="keyword">in</span> outputs:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># prompt = output.prompt</span></span><br><span class="line"></span><br><span class="line">            generated_text = output.outputs[<span class="number">0</span>].text</span><br><span class="line">            re_outputs.append(generated_text)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># print(f&quot;Prompt: &#123;prompt!r&#125;, Generated text: &#123;generated_text!r&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> re_outputs</span><br><span class="line"></span><br><span class="line">prompts = [</span><br><span class="line">    <span class="string">&quot;Hello, my name is&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The president of the United States is&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The capital of France is&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The future of AI is&quot;</span>,</span><br><span class="line">]</span><br><span class="line">sampling_params = SamplingParams(temperature=<span class="number">0.8</span>, top_p=<span class="number">0.95</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 vLLM 实例</span></span><br><span class="line">vllm_instance = vLLMWrapper.remote()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成文本</span></span><br><span class="line">generate_task = vllm_instance.generate.remote(prompts, sampling_params)</span><br><span class="line">generated_text = ray.get(generate_task)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出生成的文本</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Input Text:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(prompts)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Generated Text:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(generated_text)</span><br></pre></td></tr></table></figure><h3 id="部署多个vLLM并做数据并行推理"><a href="#部署多个vLLM并做数据并行推理" class="headerlink" title="部署多个vLLM并做数据并行推理"></a>部署多个vLLM并做数据并行推理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建多个 vLLM 实例, 此时分配的资源需要注意</span></span><br><span class="line">num_instances = <span class="number">4</span></span><br><span class="line">use_gpus = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]  <span class="comment"># 每个实例可能所用资源不一样</span></span><br><span class="line">vllm_instances = [vLLMWrapper.options(num_gpus=num_gpu).remote() <span class="keyword">for</span> num_gpu <span class="keyword">in</span> use_gpus]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备输入数据</span></span><br><span class="line">input_texts = [<span class="string">&quot;Text 1&quot;</span>, <span class="string">&quot;Text 2&quot;</span>, <span class="string">&quot;Text 3&quot;</span>, <span class="string">&quot;Text 4&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 并行生成文本</span></span><br><span class="line">generate_tasks = [vllm.generate.remote(text) <span class="keyword">for</span> vllm, text <span class="keyword">in</span> <span class="built_in">zip</span>(vllm_instances, input_texts)]</span><br><span class="line">generated_texts = ray.get(generate_tasks)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出生成的文本</span></span><br><span class="line"><span class="keyword">for</span> text <span class="keyword">in</span> generated_texts:</span><br><span class="line">    <span class="built_in">print</span>(text)</span><br></pre></td></tr></table></figure><h3 id="DP（Data-Parallel）-Rank调用"><a href="#DP（Data-Parallel）-Rank调用" class="headerlink" title="DP（Data Parallel） Rank调用"></a>DP（Data Parallel） Rank调用</h3><p><strong>DP Rank</strong>：模型并行将数据集划分为多个子集，每个子集被分配给独立的进程（称为rank），因此DP Rank指这些并行训练的进程。</p><p>若推理则与上述大致一致；若为训练，还需要<code>AllReduce同步梯度</code>，通过<code>ray.get()</code>与<code>ray.put()</code>完成集合通信实现梯度的取入和取出。</p><h2 id="多节点并发场景设计方案"><a href="#多节点并发场景设计方案" class="headerlink" title="多节点并发场景设计方案"></a>多节点并发场景设计方案</h2><h3 id="主节点"><a href="#主节点" class="headerlink" title="主节点"></a>主节点</h3><ol><li>服务器资源紧张</li><li>KV Cache莫名会申请特别多显存，即使长度等参数已经开的很小，有待研究</li></ol><p>故简单模拟了大模型的行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ray</span><br><span class="line"><span class="keyword">from</span> vllm <span class="keyword">import</span> LLM, SamplingParams</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line">os.environ[<span class="string">&quot;HF_ENDPOINT&quot;</span>] = <span class="string">&quot;https://hf-mirror.com&quot;</span></span><br><span class="line">ray.init(num_gpus=<span class="number">8</span>, num_cpus=<span class="number">64</span>, address=<span class="string">&quot;local&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(ray.nodes())  <span class="comment"># CPU: 96, GPU: 8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ray.remote(<span class="params">num_gpus=<span class="number">1</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vLLMWrapper</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.model = LLM(model=<span class="string">&quot;facebook/opt-125m&quot;</span>, </span><br><span class="line">                        <span class="comment"># tensor_parallel_size=2,</span></span><br><span class="line">                        <span class="comment"># gpu_memory_utilization=1,</span></span><br><span class="line">                        <span class="comment"># # pipeline_parallel_size=4,</span></span><br><span class="line">                        <span class="comment"># max_num_seqs=2,  # 控制并发序列数</span></span><br><span class="line">                        <span class="comment"># max_num_batched_tokens=64,  # 控制批处理大小</span></span><br><span class="line">                        <span class="comment"># max_seq_len_to_capture=32,  # 控制单个序列的最大长度</span></span><br><span class="line">                        <span class="comment"># max_model_len=32,  # 控制模型的最大长度</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self, prompts, sampling_params</span>):</span><br><span class="line">        <span class="comment"># print(torch.cuda.memory_summary(device=None, abbreviated=False))  # 详细的内存使用报告</span></span><br><span class="line">        outputs = self.model.generate(prompts, sampling_params)</span><br><span class="line">        <span class="comment"># print(torch.cuda.memory_summary(device=None, abbreviated=False))  # 详细的内存使用报告</span></span><br><span class="line">        <span class="comment"># Print the outputs.</span></span><br><span class="line">        re_outputs = []</span><br><span class="line">        <span class="keyword">for</span> output <span class="keyword">in</span> outputs:</span><br><span class="line">            <span class="comment"># prompt = output.prompt</span></span><br><span class="line">            generated_text = output.outputs[<span class="number">0</span>].text</span><br><span class="line">            re_outputs.append(generated_text)</span><br><span class="line">            <span class="comment"># print(f&quot;Prompt: &#123;prompt!r&#125;, Generated text: &#123;generated_text!r&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># return prompts </span></span><br><span class="line">        <span class="keyword">return</span> re_outputs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于调度输入分批次,利用vLLM的高并发能力生成输出 </span></span><br><span class="line"><span class="meta">@ray.remote(<span class="params">num_cpus=<span class="number">1</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vLLMScheduler</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, model</span>):</span><br><span class="line">        self.bsz = <span class="number">2</span></span><br><span class="line">        self.model = model</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">schedule</span>(<span class="params">self, <span class="built_in">input</span>: <span class="type">List</span>[<span class="built_in">str</span>]</span>):</span><br><span class="line">        results = [self.model.generate.remote(<span class="built_in">input</span>[i:i+self.bsz], sampling_params=<span class="literal">None</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(<span class="built_in">input</span>), self.bsz)]</span><br><span class="line">        results = [item <span class="keyword">for</span> sublist <span class="keyword">in</span> results <span class="keyword">for</span> item <span class="keyword">in</span> ray.get(sublist)]</span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line">    </span><br><span class="line">prompts = [</span><br><span class="line">    <span class="string">&quot;Hello, my name is&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The president of the United States is&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The capital of France is&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The future of AI is&quot;</span>,</span><br><span class="line">]</span><br><span class="line">sampling_params = SamplingParams(temperature=<span class="number">0.8</span>, top_p=<span class="number">0.95</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 vLLM 实例</span></span><br><span class="line">vllm_instance = vLLMWrapper.remote()</span><br><span class="line">scheduler_instance = vLLMScheduler.options(name=<span class="string">&quot;scheduler&quot;</span>, namespace=<span class="string">&quot;head&quot;</span>).remote(vllm_instance)</span><br><span class="line"><span class="comment"># 生成文本</span></span><br><span class="line">generate_task = vllm_instance.generate.remote(prompts, sampling_params)</span><br><span class="line">generated_text = ray.get(generate_task)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出生成的文本</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Input Text:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(prompts)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Generated Text:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(generated_text)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="工作节点"><a href="#工作节点" class="headerlink" title="工作节点"></a>工作节点</h3><p>目前并无两台同一局域网下的设备，使用同个节点的两个Python进程模拟不同节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ray</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 连接到已存在的Ray集群</span></span><br><span class="line">    ray.init(address=<span class="string">&quot;auto&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取所有Actor的句柄</span></span><br><span class="line">    scheduler = ray.get_actor(name=<span class="string">&quot;scheduler&quot;</span>, namespace=<span class="string">&quot;head&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 找到ModelServer的句柄</span></span><br><span class="line"></span><br><span class="line">    inputs = [<span class="string">f&quot;test<span class="subst">&#123;i&#125;</span>&quot;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> scheduler <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ModelServer not found in the cluster&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 使用模型进行推理</span></span><br><span class="line">        result = ray.get(scheduler.schedule.remote(inputs))</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong>输出</strong>:</p><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/image-20240806201825903.png" alt></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/OpenRLHF/OpenRLHF">https://github.com/OpenRLHF/OpenRLHF</a></li><li><a href="https://docs.ray.io/">https://docs.ray.io/</a></li><li><a href="https://zhuanlan.zhihu.com/p/678828949">https://zhuanlan.zhihu.com/p/678828949</a></li><li><a href="https://www.usenix.org/system/files/osdi18-moritz.pdf：Ray">https://www.usenix.org/system/files/osdi18-moritz.pdf：Ray</a>: A Distributed Framework for Emerging AI Applications</li><li><a href="https://openmlsys.github.io/">https://openmlsys.github.io/</a></li><li><a href="https://www.cnblogs.com/jsxyhelu/p/18155194">https://www.cnblogs.com/jsxyhelu/p/18155194</a></li><li><a href="https://docs.vllm.ai/">https://docs.vllm.ai/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 机器学习系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实习 </tag>
            
            <tag> 机器学习系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『软件工程』EPP小组软工感想</title>
      <link href="/post/cef0ace1.html"/>
      <url>/post/cef0ace1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『软件工程』EPP小组软工感想"><a href="#『软件工程』EPP小组软工感想" class="headerlink" title="『软件工程』EPP小组软工感想"></a>『软件工程』EPP小组软工感想</h1><p><em><strong>Copyfrom zjy</strong></em></p><h2 id="hyx"><a href="#hyx" class="headerlink" title="hyx"></a>hyx</h2><p><img src="https://cdn.jsdelivr.net/gh/UyJZ/imagebed@master/blog/202406132301953.png" alt="image-20240613230140896"></p><p>经过这次软工项目的磨砺，我的专业能力、沟通技巧和团队合作意识得到了前所未有的提升，使我受益匪浅。在这个综合性的软件开发过程中，我身兼前端工程师、后端工程师和服务器运维工程师三重职责，全面锻炼了我的各项技能。</p><p>在前端开发的环节中，我逐渐摒弃了仅仅套用模板的陋习，开始深入理解前端开发的规范和技巧。特别是针对CSS样式的表现力，我获得了更加深刻的认知，能够灵活运用各种样式属性来打造出更加美观、符合用户体验的界面。在后端开发方面，我进一步加深了对Django框架的理解。通过对模型、视图、模板和ORM映射等关键概念的掌握，我能够更加熟练地运用Django进行业务逻辑的实现和数据库操作。此外，我还通过实践掌握了前后端部署的技巧，对SSL证书和Nginx的配置也有了更加清晰的认识。更值得一提的是，我自主设计并实现了一套Django项目本地、GitHub和服务器三端流水线部署的框架，极大地提高了项目的开发效率和可维护性。</p><p>在这个过程中，我深刻感受到了团队合作的重要性。尽管我们团队中每个人都面临着繁重的课外任务，但大家都能够积极投入，尽全力完成自己的工作任务。面对困难时，我们互相支持、共克时艰，充分发挥每个人的特长和优势，使得整个团队能够保持高效的协作状态。最终，我们的项目顺利完成了“发布会”，并获得了大家的一致好评。这次经历不仅让我学会了如何在团队中发挥自己的价值，更让我明白了团队合作的真谛：不在于能够迅速完成任务，而在于在合作的过程中共同成长，积累宝贵的经验和回忆。正如那句名言所说：“旅途中最美的风景并非终点，而是沿途的风景和陪伴我们的人。”</p><h2 id="ybw"><a href="#ybw" class="headerlink" title="ybw"></a>ybw</h2><p><img src="https://avatars.githubusercontent.com/u/137391849?s=400&amp;u=3435b4fafcf172fff5a26102ee381a491117e4d2&amp;v=4" alt></p><p>我们软工团队开发了一款AI赋能的文献调研助手，支持文献研读，检索，综述生成等核心功能，我主要负责了大模型本地部署，RAG流程构建、文献的深度研读以及高效语义检索系统。这是一段充满价值的软工开发经历。</p><p>首先是我认识到一个好团队的重要性，从组队时我便发现我的队友们都很有责任心，即使都在忙冯如杯等其他事情，周哥仍主动承担了队长的职责，并带领大家开展工作。在需求分析时，由于要迭代的版本太过于杂乱无章，队伍内部出现了继续迭代/另起炉灶的分歧，因此第一次需求分析做的不是很到位，还被老师约谈。但是在随后的第二次需求分析，任务分工，以及开发过程中，大家迅速进入状态，并始终保持领先预期进度的速度开发，在alpha与beta评审中均被老师/助教夸赞，这也给了我们极大的正向反馈去继续优化项目。同时，我们的团队开发过程中，<strong>没有出现</strong>通宵开发，在功能上起争执，某人因能力不足而延缓开发进度的情况，这些都难能可贵，同时也展现出我们团队卓越的个人能力与团队默契。</p><p>其次，在此前我对大模型接触的不是很多，软工开发给了我机会去了解并自己上手实现大模型与RAG相关任务，即使我们的网站用到的只是RAG的冰山一角(文本文件的知识库解读)，本来有一些做更进一步的如多路召回，重排序的想法，但由于时间原因作罢。同时我还学会了使用Django框架做后端开发，充分感受到了在开发效率上真是遥遥领先Springboot。这些后端开发与大模型应用的经验或许会对我未来的发展有着更大益处。</p><p>记得一天凌晨一点金哥还在新主通宵自习室写前端，真是泪目。和大火合作让我拥有了一段体感良好的开发经历，也是大三下我为数不多的幸运。最后再次感谢项目中的所有人，感谢牢周，黄神，华哥，萌姐，xxx。Epp，启动 !</p><h2 id="zjy"><a href="#zjy" class="headerlink" title="zjy"></a>zjy</h2><p><img src="https://cdn.jsdelivr.net/gh/UyJZ/imagebed@master/blog/202406132303196.png" alt="image-20240613230352150"></p><p>本学期的软工正式告一段落辣，感谢大火的陪伴，很幸运作为组长和AI后端的工程师完整走完了软件开发的流程，和大火一起干活总是让我受益匪浅。本学期的事情实在太多，除了软工，jwsy，计网，冯如杯的压力实在是太大了，中期压力一度要把我本人压垮，朋友们总是能体会我的难处，我们之间互帮互助，成功完成了我们软件的开发。</p><p>我们的开发之旅并非一帆风顺，第一次需求评审由于迭代项目屎山，可以说的上是完全失败。但是我们迅速调转方向选择重新自己做一个软件，并且非常成功的完成了第二次的需求评审。在开发阶段，我们都在尽心尽力的开发，当时的我事情非常多，至今难忘在去沙河的校车上和杨哥讨论RAG的逆天Bug的场景，从沙河答辩回来之后又紧锣密鼓的继续开发。我在Alpha版本化身鬼见愁，push组员们尽快的完成工作（<strong>以金哥为主</strong>，金哥的抗压能力实在是太强了！泪目）但是我的push和安排从结果上看是科学而合理的，下半学习计网实验的压力暴增，还有冯如杯答辩等等事项，我们在alpha版本完成大部分工作量绝对是明智之举。</p><p>而beta版本主要是美化和加速，我在beta版本干的活不如alpha阶段多，主要的任务在alpha版本已经解决，我主要负责了一些操作的异步优化和热门文献生成。而黄神作为前端美工的总负责人，设计了非常流畅的动画和界面，和萌姐金哥华哥完成了我们beta阶段的美化工作，实在是太好看辣。在最后的发布会，萌姐也是颇有乔布斯风范，顺利的为我们的项目画上了句号，太有实力辣！从开发中，我更加丰富了我对大模型方面的知识，更加熟悉了前后端的开发技术，杨哥也给我带来了很多有用的信息。</p><p>我们团队绝对称得上是氛围非常融洽，也为我们的开发添了一份催化剂（你管我叫哥，我管你叫哥）。感谢团队的每个人：黄神，杨哥，金哥，华哥，萌姐。</p><p><strong>EPP,启动!</strong></p><h2 id="lym"><a href="#lym" class="headerlink" title="lym"></a>lym</h2><p><img src="https://cdn.jsdelivr.net/gh/UyJZ/imagebed@master/blog/202406132305524.png" alt="image-20240613230524468"></p><p>努力一学期的软工课要到尾声啦！一次次commit代表的是我们EPP的一点点完善，一次次课程汇报展示了我们小组每周坚持不懈的改进。很幸运能和五位大佬一起组队，每个人都帮助了我很多，在大家的带领下我也从软工小白变成了有一些开发经验的技术人员。我在团队中主要负责的是前端的页面展示，之前我在做页面时可能只会关注如何将所有功能展示到页面上，更关注代码层面的逻辑，但这次软工开发让我学会了如何站在用户的视角去规划布局。要想象自己是产品使用者，然后在此基础上思考每个页面的展示和功能划分，同时也要注意排查一些隐藏bug。开发过程中我也遇到了许多与后端交互的问题，我的队友每次都能很及时地帮我解决，这也让我学会了如何跟团队成员沟通和协作。总之这学期的软工开发经历是一次非常难忘且宝贵的经历，这不会是我最后一次做软工开发，我相信之后每次做项目我都会回想起这学期的开发经历，这次经历不仅提升了我的开发水平，更让我学会了如何参与团队协作，如何发挥自己的优势。最后，感谢王老师和谭老师一学期的教学和指导，感谢助教团队的帮助。感谢我的五位队友，跟大家一起做项目是十分幸运且开心的事情！</p><h2 id="jkm"><a href="#jkm" class="headerlink" title="jkm"></a>jkm</h2><p><img src="https://cdn.jsdelivr.net/gh/UyJZ/imagebed@master/blog/202406132306483.png" alt="image-20240613230600436"></p><p>本学期的软工经历对我来说是一次非常宝贵且难忘的经历，首先对于我本人来说，我积累了丰厚的前后端开发经验，可以说代码能力无疑有了一个质的飞跃，并且这应该是我首次在一个团队项目中进行开发，所以我也积累了很多团队开发的经验与技巧。总的来说，这可能是我在六系上过这么多门课中，积累了最多对于将来的实习、就业有用的知识的一门课。</p><p>下面是有关团队的部分，我必须感激地说，我认为我的软工是在一个非常优秀的团队中度过的。在学期伊始，其实对于软工我是抱有着忐忑的心情的，因为我开发网页的经历属实不是很丰富，况且在开始分工的时候，我还被分到了不擅长的前端，所以我非常害怕会拖了团队的后腿。但幸运的是，团队的其他成员并没有嫌弃一开始我的一些很基础的问题，而是不厌其烦的教我一步步开发，确实让我感受到了团队的力量与温暖。我衷心的感谢Epp团队与团队里的每一个成员，大伙的能力都太强了，甚至光读队友的代码我都能收获很多；并且我们的领导周哥太有领导力了，分工明确合理，我作为团队的帕鲁虽然一直被鞭策但没有被奴役的感觉。也正因如此，本学期的开发一直是有条不紊的，在Alpha版本就已经实现了绝大多数功能，在Beta版本也收获了老师与助教的赞扬。当然这也要归功于我们良好的团队氛围，每次开会都是在欢声笑语中进行，既没有发生争执也没有熬夜开发。团队氛围良好促进了代码开发，代码进展顺利又促进了团队氛围，达到了一个良性循环。</p><p>软工这门课给我的收获太丰富了，不仅提高了我的代码水平、让我了解了团队项目中的代码规范、积累了团队开发的经历，也让我结识了很多优秀的朋友，让我体会到了在一个氛围良好的的团队里开发是什么感觉。还是非常荣幸可以与大伙共度一学期的软工之旅。</p><h2 id="cjh"><a href="#cjh" class="headerlink" title="cjh"></a>cjh</h2><p><img src="https://cdn.jsdelivr.net/gh/UyJZ/imagebed@master/blog/202406132306712.png" alt="image-20240613230625651"></p><p>软件工程是一门综合性学科，涵盖了软件开发生命周期的各个方面，包括需求分析、设计、编码、测试和维护等环节。本课程通过理论讲解和项目工程开发相结合，使我对软件开发过程有了更深刻的理解。</p><p>回顾整个软件工程项目的开发，我们团队的每位成员都投入了大量时间和精力。在项目初期，我们积极讨论和分工，根据每个人的特点分配任务，并制定了详细的工作计划。在后续开发过程里，我们通过每周的组会检查进度，并积极交流意见，解决各种问题。这样的合作保证了我们项目的稳定推进，也让我们在开发中找寻了很多乐趣。</p><p>整个开发过程中，我学习了很多。从最初参与数据库设计，到后来的后端功能开发和维护，再到尝试前端开发，我不仅拓宽了技能，还更加注重代码的可维护性、可扩展性和可读性，努力提升自己编写工程代码的能力，真正意义上，将软件项目视为一个产品，不仅追求功能的丰富和稳定，也关注美观和用户体验。</p><p>最后，感谢EPP团队的每一位成员，特别感谢组长的出色组织和领导能力。没有他们的辛勤付出，我们的项目不可能如此成功。这次成功的团队合作凝结了每个人的努力，是一次宝贵的经验。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『计算机网络』计算机网络实验——常用指令</title>
      <link href="/post/3a21a286.html"/>
      <url>/post/3a21a286.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『计算机网络』计算机网络实验——常用指令"><a href="#『计算机网络』计算机网络实验——常用指令" class="headerlink" title="『计算机网络』计算机网络实验——常用指令"></a>『计算机网络』计算机网络实验——常用指令</h1><h2 id="配置NAT（关键）"><a href="#配置NAT（关键）" class="headerlink" title="配置NAT（关键）"></a>配置NAT（关键）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[R1]acl basic 2001 // 在V7设备中（线下设备），使用acl basic命令；在V5设备中（线上设备），使用acl number命令</span><br><span class="line">[R1-acl-2001]rule permit source 10.0.0.0 0.0.0.255 // 根据局域网的网段配置</span><br><span class="line">[R1-acl-2001]rule deny sourse any // 允许IP源地址为10.0.0.0/24的外出数据包</span><br><span class="line">[R1]nat address-group 1 // 进入地址池1</span><br><span class="line">[R1-address-group-1]address 192.168.5.105 192.168.5.109 // 定义一个包含5个公网地址的地址池，地址池名为1</span><br><span class="line">[R1]interface e 1/0/1</span><br><span class="line">[R1-Ethernet 1/0/1]nat outbound 2001 address-group 1 // 在出接口e 1/0/1启动地址转换，指定number和group</span><br><span class="line">[R1]ip route-static 0.0.0.0 0.0.0.0 192.168.5.1 // 在路由表添加默认静态路由，</span><br><span class="line">分别是目标IP，目标IP子网掩码，下一条地址</span><br><span class="line"></span><br><span class="line">acl basic/number 2001</span><br><span class="line">rule permit source 10.0.0.0 0.0.255.255 // 看情况</span><br><span class="line">rule deny source any // 可以不用</span><br><span class="line">nat address-group 1</span><br><span class="line">address x.x.x.x x.x.x.x</span><br><span class="line">inter e0/1</span><br><span class="line">nat outbound 2001 address-group 1</span><br><span class="line">ip route-static 0.0.0.0 0.0.0.0 192.168.5.1</span><br></pre></td></tr></table></figure><h3 id="当于OSPF结合时，需要通告默认路由"><a href="#当于OSPF结合时，需要通告默认路由" class="headerlink" title="当于OSPF结合时，需要通告默认路由"></a>当于OSPF结合时，需要通告默认路由</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[R1]ospf // 进入ospf</span><br><span class="line">[R1-ospf-1]default-route-advertise cost 100 // 通告默认路由配置</span><br></pre></td></tr></table></figure><h2 id="VLAN：数据链路层"><a href="#VLAN：数据链路层" class="headerlink" title="VLAN：数据链路层"></a>VLAN：数据链路层</h2><h3 id="VLAN端口分类"><a href="#VLAN端口分类" class="headerlink" title="VLAN端口分类"></a>VLAN端口分类</h3><p>交换机的端口可以分为Access, Trunk和Hybrid三类。</p><ul><li>Access：连接不支持VLAN技术的终端设备（如主机）的（交换机）端口，主机和交换机的连接端口通常都是Access</li><li>Trunk：连接支持VLAN技术的网络设备（如交换机）的（交换机）端口，收到的数据一般带有VLAN标签（数据帧VLAN和端口默认VLAN ID相同的除外）；向外发送数据帧时，须保证接收端可以区分不同的VLAN，因此常常需要添加VLAN标签（数据帧VLAN ID和端口默认VLAN  ID相同的除外），一般<strong>用于交换机之间的连接</strong>。</li><li>Hybrid：Access和Trunk的混合模式，在Hybrid下工作的端口可以属于多个VLAN，可以接收和发送多个VLAN的报文，可以用于交换机之间的连接，也可以用于连接用户。</li></ul><h3 id="默认VLAN"><a href="#默认VLAN" class="headerlink" title="默认VLAN"></a>默认VLAN</h3><p>每个（交换机）端口的属性，值为pvid，可以人为设置。交换机从某个端口收到一个不带VLAN标签的数据帧的时候，会在交换机内部将该数据帧视为带默认VLAN标签的数据帧。</p><p>H3C交换机初始化时，将每个端口设置为VLAN1，且VLAN1是每个端口的默认VLAN(pvid=1)，VLAN1是untagged的。</p><h3 id="带标签（tagged）和不带标签（untagged）"><a href="#带标签（tagged）和不带标签（untagged）" class="headerlink" title="带标签（tagged）和不带标签（untagged）"></a>带标签（tagged）和不带标签（untagged）</h3><p>tagged和untagged是端口的VLAN属性，用于确定从该端口发出的数据帧是否带VLAN标签。</p><p>一般来说，Access端口是untagged的；Trunk端口只有默认VLAN才是untagged，其他端口都是tagged；Hybrid端口比较灵活，可以自由设置。</p><h3 id="创建VLAN"><a href="#创建VLAN" class="headerlink" title="创建VLAN"></a>创建VLAN</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[h3c]vlan 2 // 创建vlan 2，2可以替换为其他vlan id，执行后会变为[h3c-vlan2]</span><br><span class="line">[h3c]undo vlan 2// 删除vlan 2，2可以替换为其他vlan id</span><br></pre></td></tr></table></figure><h3 id="VLAN添加端口"><a href="#VLAN添加端口" class="headerlink" title="VLAN添加端口"></a>VLAN添加端口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[h3c]vlan 2 // 创建/进入 vlan 2</span><br><span class="line">[h3c-vlan2]port ge 1/0/1 to ge 1/0/3 // 进入vlan后，使用port ... to ...将某一范围内的端口添加到该VLAN，使用的是基于端口的VLAN划分。需要注意的是，e是Ethernet的缩写，线下网络实验室应当使用g</span><br><span class="line">[h3c-vlan2]undo port ge 1/0/1 to ge 1/0/2 // 将e 1/0/1 to e 1/0/3从VLAN2中删除</span><br></pre></td></tr></table></figure><h4 id="指定端口类型（trunk）"><a href="#指定端口类型（trunk）" class="headerlink" title="指定端口类型（trunk）"></a>指定端口类型（trunk）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[h3c]int e 1/0/1 // 首先进入指定的端口</span><br><span class="line">[h3c-Ethernet 1/0/1]port link-type trunk // 将端口类型设置为trunk</span><br><span class="line">[h3c-Ethernet 1/0/1]undo port link-type // 取消端口类型设置</span><br><span class="line">[h3c-Ethernet 1/0/1]port link-type hybrid // 将端口类型设置为hybrid</span><br></pre></td></tr></table></figure><h4 id="指定-删除Trunk端口可以通过的VLAN数据帧"><a href="#指定-删除Trunk端口可以通过的VLAN数据帧" class="headerlink" title="指定/删除Trunk端口可以通过的VLAN数据帧"></a>指定/删除Trunk端口可以通过的VLAN数据帧</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[h3c-Ethernet 1/0/1]port trunk permit vlan 2 to 3 // 允许通过2和3的数据帧</span><br><span class="line">[h3c-Ethernet 1/0/1]undo port trnk permit vlan 2 to 3</span><br></pre></td></tr></table></figure><h3 id="配置VLAN-IP"><a href="#配置VLAN-IP" class="headerlink" title="配置VLAN IP"></a>配置VLAN IP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[H3C]inter vlan 2 // 进入interface vlan 2</span><br><span class="line">[H3C-Vlan-interface3] ip addr 40.1.1.1 24 // 配置VLAN2的ip</span><br></pre></td></tr></table></figure><p>二层交换机的端口不会配置IP，VLAN 的 IP 地址是为了在网络层上为该 VLAN 中的所有端口提供服务，而不是给每个端口单独配置 IP 地址，<strong>给 VLAN 配置 IP 地址意味着你在设置一个网络层的接口，供 VLAN 中的所有设备共用作为通信的网关</strong>。</p><h2 id="三个数据链路层协议"><a href="#三个数据链路层协议" class="headerlink" title="三个数据链路层协议"></a>三个数据链路层协议</h2><h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[R1-Serial1/0]link-protocol ppp // 配置PPP</span><br><span class="line">&lt;R1&gt;debugging ppp all // 打开PPP的debug开关</span><br><span class="line">&lt;R1&gt;terminal debugging // 显示debug信息</span><br><span class="line"></span><br><span class="line">[R1-Serial 1/0]shutdown // 关闭接口</span><br><span class="line">[R1-Serial 1/0]undo shutdown // 启用接口</span><br></pre></td></tr></table></figure><h3 id="PAP验证"><a href="#PAP验证" class="headerlink" title="PAP验证"></a>PAP验证</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// R1 主验证方</span><br><span class="line">[R1]local-user RTB class network // 配置用户</span><br><span class="line">[R1-local-network-RTB]service-type ppp // 配置服务类型</span><br><span class="line">[R1-local-network-RTB]password simple aaa // 配置用户密码</span><br><span class="line">[R1]interface Serial 1/0</span><br><span class="line">[R1-Serial1/0]ppp authentication pap // 授权PAP验证</span><br><span class="line">// R2 被验证方</span><br><span class="line">[R2]interface Serial 1/0</span><br><span class="line">[R2-Serial 1/0]ppp pap local-user RTB password simple aaa // 配置PAP用户名和视图</span><br><span class="line"></span><br><span class="line">&lt;R1&gt;debugging ppp pap all</span><br><span class="line">&lt;R1&gt;terminal debugging</span><br></pre></td></tr></table></figure><h3 id="CHAP验证"><a href="#CHAP验证" class="headerlink" title="CHAP验证"></a>CHAP验证</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[R1]local-user RTB class network // 配置用户列表</span><br><span class="line">[R1-luser-network-RTB]service-type ppp // 配置服务类型</span><br><span class="line">[R1-luser-network-RTB]pasword simple aaa // 配置用户对应的密码</span><br><span class="line">[R1]Serial 1/0</span><br><span class="line">[R1-Serial 1/0]ppp authentication-mode chap // 授权CHAP验证</span><br><span class="line">[R1-Serial 1/0]ppp chap user RTA // 配置本地名称</span><br><span class="line"></span><br><span class="line">[R2]local-user RTA class network // 配置用户列表</span><br><span class="line">[R2-luser-network-RTA]service-type ppp //配置服务类型</span><br><span class="line">[R2-luser-network-RTA]password simple aaa // 配置用户对应的密码</span><br><span class="line">[R2]interface Serial 1/0</span><br><span class="line">[R2-Serial 1/0]ppp chap user RTB // 配置本地名称</span><br><span class="line"></span><br><span class="line">&lt;R1&gt;debugging ppp chap all</span><br><span class="line">&lt;R1&gt;terminal debugging</span><br></pre></td></tr></table></figure><h3 id="查看路由表"><a href="#查看路由表" class="headerlink" title="查看路由表"></a>查看路由表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[H3C]display ip routing-table</span><br></pre></td></tr></table></figure><h2 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h2><h3 id="配置Router-ID"><a href="#配置Router-ID" class="headerlink" title="配置Router ID"></a>配置Router ID</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;H3C&gt;system-view</span><br><span class="line">[H3C]router id 1.1.1.1 // 配置路由器的router id为1.1.1.1</span><br><span class="line">[H3C]undo router id  // 删除router id</span><br></pre></td></tr></table></figure><h3 id="启动OSPF"><a href="#启动OSPF" class="headerlink" title="启动OSPF"></a>启动OSPF</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[R1]router id 1.1.1.1 // 有时候不需要这一步</span><br><span class="line">[R1]ospf // 启动ospf协议进程</span><br><span class="line">[R1]undo ospf // 关闭ospf协议进程 reset ospf all process</span><br><span class="line">[R1-ospf-1]area 0 // 创建area 0区域视图</span><br><span class="line">[R1-ospf-1]undo area 0 // 删除area0</span><br><span class="line">[R1-ospf-1-area-0.0.0.0]network 1.1.1.0 0.0.0.255 // 指定网段运行OSPF协议，最重要, 前面是网段，后面是掩码取反</span><br></pre></td></tr></table></figure><h3 id="显示OSPF调试信息"><a href="#显示OSPF调试信息" class="headerlink" title="显示OSPF调试信息"></a>显示OSPF调试信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;R1&gt;debugging ospf event</span><br><span class="line">&lt;R1&gt;terminal debugging  // 然后断线重连</span><br><span class="line"></span><br><span class="line">&lt;R1&gt;reset ospf all process // 重启ospf进程</span><br></pre></td></tr></table></figure><h3 id="配置回环地址（LoopBack）"><a href="#配置回环地址（LoopBack）" class="headerlink" title="配置回环地址（LoopBack）"></a>配置回环地址（LoopBack）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[h3c]inter loop 1 // 进入loopback1</span><br><span class="line">[h3c-LoopBack1]ip addr 4.4.4.4 32 // 配置ip为4.4.4.4/32</span><br></pre></td></tr></table></figure><h3 id="配置串口（Serial）"><a href="#配置串口（Serial）" class="headerlink" title="配置串口（Serial）"></a>配置串口（Serial）</h3><p>路由器间不能使用以太网口直连，需要使用串口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[R1]interface s 0/0 // 进入串口0/0，e就是serial</span><br><span class="line">[R1-Serial 0/0]ip addr 192.168.1.1 24</span><br></pre></td></tr></table></figure><h3 id="配置OSPF-Cost"><a href="#配置OSPF-Cost" class="headerlink" title="配置OSPF Cost"></a>配置OSPF Cost</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 为VLAN配置ospf cost</span><br><span class="line">[R1]inter vlan 3</span><br><span class="line">[R1-Vlan-Interface3]ospf cost 100 /// 配置ospf cost</span><br><span class="line">// 为端口配置ospf cost</span><br><span class="line">[R1]inter g 0/0</span><br><span class="line">[R1-G..0/0]ospf cost 100 // 配置ospf cost</span><br><span class="line">// 为串口配置ospf cost</span><br><span class="line">[R1]inter s 0/0 // 进入串口</span><br><span class="line">[R1-Serial0/0]ospf cost 200 // 配置ospf cost</span><br></pre></td></tr></table></figure><h3 id="配置缺省路由"><a href="#配置缺省路由" class="headerlink" title="配置缺省路由"></a>配置缺省路由</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[H3C]ip route-static 0.0.0.0 0.0.0.0 129.0.0.1 // 配置缺省路由器为129.0.0.1，和计算机网关的作用类似</span><br><span class="line">第一个0.0.0.0目的网络地址，第二个0.0.0.0目的地址子网掩码，第三个129.0.0.1下一跳地址</span><br></pre></td></tr></table></figure><h3 id="查看OSPF-LSDB（五类LSA如何查看）"><a href="#查看OSPF-LSDB（五类LSA如何查看）" class="headerlink" title="查看OSPF LSDB（五类LSA如何查看）"></a>查看OSPF LSDB（五类LSA如何查看）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">display ospf lsdb # 所有LSA</span><br><span class="line">display ospf lsdb router # 第一类LSA</span><br><span class="line">display ospf lsdb network # 第二类LSA</span><br><span class="line">display ospf lsdb summary # 第三类LSA</span><br><span class="line">display ospf asbr # 第四类LSA，第五类过边界</span><br><span class="line">display ospf ase # 第五类LSA，外部信息注入</span><br></pre></td></tr></table></figure><h3 id="排查故障指令"><a href="#排查故障指令" class="headerlink" title="排查故障指令"></a>排查故障指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[R1]display ospf peer // 查看邻居路由器状态</span><br><span class="line">[R1]reset ospf all // 重启ospf协议</span><br></pre></td></tr></table></figure><h3 id="路由引入（重点中的重点）"><a href="#路由引入（重点中的重点）" class="headerlink" title="路由引入（重点中的重点）"></a>路由引入（重点中的重点）</h3><p>将静态路由或直连路由导入到动态路由协议中，使得其他路由器可以通过动态路由协议学习到这些路由。</p><p>直连路由：路由器的端口与127.0.0.1的连接，端口对应的网段与端口之间的连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[S1-ospf]import-route direct // 引入直连路由</span><br><span class="line">[R1]ip route-static 192.168.5.0 255.255.255.0 192.168.3.2 // 配置静态路由</span><br><span class="line">[R1-ospf]import-route static // 引入静态路由</span><br></pre></td></tr></table></figure><h3 id="tracert"><a href="#tracert" class="headerlink" title="tracert"></a>tracert</h3><p>tracert命令可以追踪经过的路由器路径，验证cost配置的正确性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert &#123;-d&#125; 10.35.3.1 // PC可以使用-d，但是路由器和交换机似乎不支持</span><br></pre></td></tr></table></figure><p>网络设备默认不回应tracert命令，因此需要手动开启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[S1]ip ttl-expires enable</span><br><span class="line">[S1]ip unreachables enable</span><br></pre></td></tr></table></figure><h3 id="OSPF的五种报文以及其交互过程"><a href="#OSPF的五种报文以及其交互过程" class="headerlink" title="OSPF的五种报文以及其交互过程"></a>OSPF的五种报文以及其交互过程</h3><p><img src="https://cdn.jsdelivr.net/gh/YangYzzzz/image-store@main/img.png" alt></p><h3 id="路由器和交换机相连是某个网段相连，在这个网段下会选举路由器的接口作为DR，产生三类LSA；而两台路由器之间是点对点连接，无网段，无DR-BDR。"><a href="#路由器和交换机相连是某个网段相连，在这个网段下会选举路由器的接口作为DR，产生三类LSA；而两台路由器之间是点对点连接，无网段，无DR-BDR。" class="headerlink" title="路由器和交换机相连是某个网段相连，在这个网段下会选举路由器的接口作为DR，产生三类LSA；而两台路由器之间是点对点连接，无网段，无DR,BDR。"></a>路由器和交换机相连是某个网段相连，在这个网段下会选举路由器的接口作为DR，产生三类LSA；而两台路由器之间是点对点连接，无网段，无DR,BDR。</h3><p>OSPF状态转移图：</p><p><img src="/post/3a21a286/img2.png" alt="img.png"></p><h3 id="BDR和DR选举过程："><a href="#BDR和DR选举过程：" class="headerlink" title="BDR和DR选举过程："></a>BDR和DR选举过程：</h3><p>在全连接网络中，Hello报文交换时选举，每台路由器拥有全部信息，则使用相同的算法就可以选举出DR和BDR。</p><h2 id="BGP实验"><a href="#BGP实验" class="headerlink" title="BGP实验"></a>BGP实验</h2><p><img src="/post/3a21a286/img3.png" alt="img.png"></p><h3 id="启动BGP，并配置邻居（以上图为例），注入回环路由信息"><a href="#启动BGP，并配置邻居（以上图为例），注入回环路由信息" class="headerlink" title="启动BGP，并配置邻居（以上图为例），注入回环路由信息"></a>启动BGP，并配置邻居（以上图为例），注入回环路由信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[R1]bgp 100 // 在R1上启动BGP协议，AS号为100（重要）</span><br><span class="line">[R1]undo bgp</span><br><span class="line">[R1-bgp]peer 1.1.1.2 as-number 300 // 配置它的邻居IP，即与它相邻的路由器接口的IP地址与对应的AS号</span><br><span class="line">[R1-bgp]address-family ipv4 unicast // 新版本要进入ipv4使能邻居，考试时必须注意</span><br><span class="line">[R1-bgp-ipv4]peer 1.1.1.2 enable</span><br><span class="line"></span><br><span class="line">[R1]bgp 100 // 进入BGP视图</span><br><span class="line">[R1-bgp]network 5.5.5.5 255.255.255.255 // 注入5.5.5.5/32网段的路由信息，令5.5.5.5通过bgp在不同AS间传播。目的地址，子网掩码</span><br><span class="line">/////////////////////////////////</span><br><span class="line">[S1]bgp 300</span><br><span class="line">[S1-bgp]peer 1.1.1.1 as-number // 其余路由器同理，注意AS与邻居的AS</span><br></pre></td></tr></table></figure><h3 id="强制下一跳为本身接口（next-hop-local）"><a href="#强制下一跳为本身接口（next-hop-local）" class="headerlink" title="强制下一跳为本身接口（next-hop-local）"></a>强制下一跳为本身接口（next-hop-local）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[S1-bgp]peer 3.1.1.2 next-hop-local // 强制下一跳为本身接口</span><br><span class="line">*意思是由s1发出去的bgp信息的下一跳字段，如果是3.1.1.2（即从s2过来的），则改为本地接口*，这是由于在IGP内部没有配置OSPF导致的，如配置了OSPF则无问题</span><br></pre></td></tr></table></figure><p><em>同一网段直接相连的两个接口可通过直连路由产生路由表</em></p><h4 id="BGP协议状态转移"><a href="#BGP协议状态转移" class="headerlink" title="BGP协议状态转移"></a>BGP协议状态转移</h4><p><img src="/post/3a21a286/img4.png" alt="img.png"></p><h3 id="查看BGP路由表"><a href="#查看BGP路由表" class="headerlink" title="查看BGP路由表"></a>查看BGP路由表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[R1-bgp]display bgp routing-table // 查看BGP路由表</span><br></pre></td></tr></table></figure><h3 id="查看BGP邻居状态"><a href="#查看BGP邻居状态" class="headerlink" title="查看BGP邻居状态"></a>查看BGP邻居状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[R1]display bgp peer</span><br></pre></td></tr></table></figure><h3 id="debug信息，查看BGP协商过程"><a href="#debug信息，查看BGP协商过程" class="headerlink" title="debug信息，查看BGP协商过程"></a>debug信息，查看BGP协商过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;R1&gt;debugging bgp event</span><br><span class="line">&lt;R1&gt;terminal debugging</span><br></pre></td></tr></table></figure><h3 id="路由引入"><a href="#路由引入" class="headerlink" title="路由引入"></a>路由引入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[R1-bgp]import-route direct // 引入直连路由</span><br><span class="line">[R1-bgp]import-route static // 引入直连路由</span><br></pre></td></tr></table></figure><h3 id="BGP路由聚合"><a href="#BGP路由聚合" class="headerlink" title="BGP路由聚合"></a>BGP路由聚合</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[R1]bgp 100</span><br><span class="line">[R1-bgp]aggregate 192.168.0.0 255.255.240.0 //通过具体路由和聚合路由</span><br><span class="line">[R1-bgp]undo aggregate 192.168.0.0 255.255.240.0</span><br><span class="line"></span><br><span class="line">[R1-bgp]aggregate 192.168.0.0 255.255.240.0 detail-supressed // 只通告聚合路由</span><br></pre></td></tr></table></figure><h3 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h3><h4 id="基于ACL的路由过滤"><a href="#基于ACL的路由过滤" class="headerlink" title="基于ACL的路由过滤"></a>基于ACL的路由过滤</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[R2]acl number 2001</span><br><span class="line">[R2-acl-basic-2001]rule 0 deny source 5.0.0.0 0.255.255.255 </span><br><span class="line">[R2-acl-basic-2001]rule 1 permit source 0.0.0.0 255.255.255.255</span><br><span class="line">[S2]bgp 300</span><br><span class="line">[S2-bgp]peer 2.1.1.2 filter-policy 2001 export // 配置基于ACL的路由过滤</span><br></pre></td></tr></table></figure><h4 id="配置基于AS-Path的路由过滤"><a href="#配置基于AS-Path的路由过滤" class="headerlink" title="配置基于AS-Path的路由过滤"></a>配置基于AS-Path的路由过滤</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[S1]ip as-path 1 deny \b200$ // 设置拒绝来自AS200的路由</span><br><span class="line">[S1]ip as-path 1 permit ^$ // 设置允许本AS的路由</span><br><span class="line">[S1]bgp 300</span><br><span class="line">[S1-bgp]peer 1.1.1.1 as-path-acl 1 export // 将1.1.1.1接口配置基于AS-Path的路由过滤，即令r1无法收到来自AS200的BGP信息，关键</span><br></pre></td></tr></table></figure><h4 id="配置基于Route-Policy的路由过滤"><a href="#配置基于Route-Policy的路由过滤" class="headerlink" title="配置基于Route Policy的路由过滤"></a>配置基于Route Policy的路由过滤</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[S1]acl number 2001  // number是v7</span><br><span class="line">[S1-acl-basic-2001]rule 1 deny source 6.0.0.0 0.255.255.255</span><br><span class="line">[S1-acl-basic-2001]rule 2 permit source any</span><br><span class="line">[S1-acl-basic-2001]quit</span><br><span class="line">[S1]route-policy deny6 permit node 10 // 配置route-policy内容</span><br><span class="line">[S1-route-policy]if-match ip address acl 2001</span><br><span class="line">[S1-route-policy]apply cost 888</span><br><span class="line">[S1-route-policy]quit</span><br><span class="line">[s1]Bgp 300</span><br><span class="line">[S1-bgp-default]address-family ipv4 unicast</span><br><span class="line">[S1-bgp-default-ipv4]peer 1.1.1.1 route-policy deny6 export</span><br></pre></td></tr></table></figure><h3 id="BGP四种报文"><a href="#BGP四种报文" class="headerlink" title="BGP四种报文"></a>BGP四种报文</h3><p>Open, KeepAlive, Update, Notification</p><h3 id="BGP配置LocalPre和Med"><a href="#BGP配置LocalPre和Med" class="headerlink" title="BGP配置LocalPre和Med"></a>BGP配置LocalPre和Med</h3><p>V5：</p><p>LocalPre: 是一个本地属性，用于在一个自治系统（AS）内部选择最佳路由，默认为100，越大越选择。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[R1-bgp]default local-preference xx</span><br></pre></td></tr></table></figure><p>Med: 是一个用于跨 AS 边界的属性，用来告知相邻 AS 如何选择进入本 AS 的最佳路径。它主要用于在多条进入路径中选择优先级, 默认值为0，越小越选择。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[R1-bgp]default med 10</span><br></pre></td></tr></table></figure><p>V7:</p><p>LocalPre:</p><h3 id="模拟题1"><a href="#模拟题1" class="headerlink" title="模拟题1"></a>模拟题1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">为使 4.4.4.4 -&gt; 5.5.5.5</span><br><span class="line">[R2]ip route-static 1.x.0.0 255.255.0.0 2.x.1.1</span><br><span class="line">[S2]ip route-static 5.5.5.5 255.255.255.255 3.x.1.1</span><br><span class="line">为使 5.5.5.5 -&gt; 4.4.4.4</span><br><span class="line">[S1]ip route-static 2.x.0.0 255.255.0.0 3.x.1.2</span><br><span class="line">[S2]ip route-static 4.4.4.4 255.255.255.255 2.x.1.2</span><br></pre></td></tr></table></figure><h2 id="复杂组网de坑"><a href="#复杂组网de坑" class="headerlink" title="复杂组网de坑"></a>复杂组网de坑</h2><ol><li><p>将内部全部配好ospf与ibgp，注意边界端口的ip不要引入ospf中。</p></li><li><p>每个路由器/交换机的ospf中都要引入router id</p></li><li>非边界路由器只需配置内部全部peer即可（慢慢敲）</li><li>边界路由器需要做几项工作<ol><li>配置内部全部peer</li><li>配置对端外部peer</li><li>将自己的ospf引入bgp. <strong>import-route ospf 1</strong></li><li>将自己的边界端口对应ip引入bgp</li></ol></li></ol><p>如此可全网互通。</p><ol><li><p>把VRRP配了(未检查，应该不太重要)</p><p><img src="/post/3a21a286/img5.png" alt="img.png"></p></li><li><p>将全网联通 （配置路由器和交换机的指令记录）</p></li><li><p>将路由过滤，只保留192.168的路由</p><p>在边界路由器上配置</p><p><code>[R2]acl number 2001</code><br><code>[R2-acl-basic-2001]rule 0 permit source 192.168.0.0 0.0.255.255</code><br><code>[R2-acl-basic-2001]rule 1 deny source any</code><br><code>[S2]bgp &lt;as号&gt;</code><br><code>[S2-bgp]peer &lt;跨as的peer&gt; filter-policy 2001 export // 配置基于ACL的路由过滤</code></p><p><code>[S2-bgp]peer &lt;跨as的peer&gt; filter-policy 2001 import</code></p></li><li><p>将NAT配置</p></li><li><p>将优选路径配置</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机科学 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 课内实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『学期总结』大三下学期总结</title>
      <link href="/post/f430acf6.html"/>
      <url>/post/f430acf6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『学期总结』大三下学期总结"><a href="#『学期总结』大三下学期总结" class="headerlink" title="『学期总结』大三下学期总结"></a>『学期总结』大三下学期总结</h1><p>在大三下，我终将直面自己的未来。</p><p>即使如今本学期尚未结束，一切都并未尘埃落定，但在这寥寥几个月内我的心境，所思所想发生了翻天覆地的变化，我不清楚这趟列车究竟通往何方，迷茫与清晰，自卑与自信交错地占据了这个学期。</p><p>从年初到今年的四月份，我的心里只有一件事，那就是要在北航的冯如杯上证明自己，我们在征集的项目中选择了一个感兴趣的“变色龙”项目，并结识了一位专精学术的博士学长，一拍即合。我最初为自己定下的目标是保底二等奖(去年三等奖)，从寒假开始固定一周一次的论文汇报，确定方向思路，再到学期初高强度的开发，没日没夜的改模型，跑实验，很幸运的是我们的方法work了，即使不多但还是在真实世界呈现了效果，同时我们的指导老师自诩明白“冯如杯”这个游戏怎么玩，在PPT和答辩上多次在有益的方向指导了我们，这和去年的我们比已是质的飞跃，一切都在往冲击更高奖项的方向发展。然而实际却不尽如人意，这也是我大三下迷茫的开始，现场答辩以惨淡收场，我看着其他项目人均与xx企业合作，xx篇论文中稿，而我们的项目仅仅只有我们的团队，还有博士学长尚未被接收的工作，再加之后来听说今年计院想找回去年的场子，各大实验室的顶尖项目倾巢而出，而本科生更多的是以一个“宣传者”的身份站在答辩舞台前，而我们的项目只换来一句“想法很好，但是应用性太差”，我那几天脑海中充斥着对冯如杯，乃至对北航无尽的愤怒。</p><p>那么，我真正想要什么呢？马后炮来说，这次的冯如杯我完全不应该花时间准备，我目前的排名已经足够允许我保研，也不需要冯如杯的海量加分，本学期最需要做的是充实简历，找到研究生的归宿。以自我的利益来说，这算得上是一段充实的科研经历，如果不是各种无用功，一开始抱着发论文的想法做，没准如今论文已经在审了，我或许能去向更高的地方。是的，但是我的队友还需要冯如杯的加分，我个人能够放下对冯如杯的意见，因为它本质除了对我的自信造成了打击外，并无太多利益上的损害，而我处于保研边缘的队友乃至其他同学，由于这场实验室资源秀，很可能彻底错失了保研的机会，我身为他们的队长兼朋友，对这届冯如杯/六系冯如杯的加分政策表示强烈不满。</p><p>最近一个月开始为未来焦虑，也开始天天刷知乎，刷邮箱，看联系的导师，投的夏令营有没有回复，这彷佛是保研选手的必经之路，毕竟我真的非常渴望在学术上有所建树，我清楚我不能再保持沉默，找一个好导师将大于一切，但是我感兴趣的CV多模态/LLM领域已经卷上天了，我时常觉得自己没什么拿的出手的成果，怎么能和大佬们碰，又时常觉得我的理论知识很扎实，或许有大牛导师会欣赏我。昨天刘雪峰老师最后一堂课的发言打动了我，什么是真正的幸福呢，通常人们会给出两种解答，第一种是在和社会内其他人的比较中获得幸福，第二种是因人生体验更多而幸福，极端而言第一种会成为追名逐利之徒，第二种会成为躺平摆烂之辈。我共同拥有这二者的想法，但却互相拉扯，当我在冯如杯失利时，我可以认为现场答辩是一次难能可贵的经历，当我望见我的排名时，我又会沾沾自喜自己可以打败六系的众多强者。老师后续又道，真正的幸福，应该二者取其中(更具体的忘了)，这和我目前的情况不谋而合，那么自适应的幸福算得上是一种精神胜利法吗？在保研这件大事上，我是该秉持着自己的想法，还是更追名逐利一些呢？目前保研的号角刚刚奏响，我在上周刚去南大参加完第一个夏令营，所幸结果暂未可知，目前可以将它当做一段难忘的经历。无论结果如何，这两年我在六系见到了很多人，学到了很多事，我从不后悔选择了六系。我会继续自省，继续前进，尽管这学期真的事事不尽如人意，仍希望两个月后我可以为我的本科生涯交上一份满意的答卷。</p><p>最后致谢低谷时陪伴我的好兄弟们，感谢朱姐两年来不离不弃的相伴，感谢金哥❤萱姐分担我的压力，为我的生活带来快乐，感谢软工小组的所有人，是你们让我拥有一段完美的开发经历，感谢君楷在保研路上给我的指导，感谢我结识的越来越多的大佬们，遗憾未和大家早些相识，给大火磕一个了。</p>]]></content>
      
      
      <categories>
          
          <category> 感想随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学期总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『学期总结』大二下学期总结</title>
      <link href="/post/7e0b8bd6.html"/>
      <url>/post/7e0b8bd6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『学期总结』大二下学期总结"><a href="#『学期总结』大二下学期总结" class="headerlink" title="『学期总结』大二下学期总结"></a>『学期总结』大二下学期总结</h1><p>最近北京的云彩总是那么迷人，漫步在夕阳下的北航校园，因为OO，OS等产生的不安焦躁情绪总是会一扫而空，抬起手来拍一朵云，望蔚蓝的天空，忘掉种种烦恼，感受生活的一切美好(然而转身又要投入ooos的怀抱)。</p><p>本学期的课业压力较重，要同时上操作系统和面向对象这两门大课，每周两次的上机令人欲仙欲死，课下的代码量超乎想象，要学习的新知识指数级增长，可想而知这四个月来我是怎么度过的。当然，本学期的关键词少不了“冯如杯”三字，从准备阶段每周二组员固定碰头又纷纷没有思绪，再到最后阶段论文的不断改进再改进，答辩的一遍遍排练打磨，成就了最辛劳也是最难忘的一段时光，结果是拿了个三等奖，还算比较满意叭~</p><p>繁忙的课业之余自然需要怡怡情，学期中听了京剧的表演令人感叹国粹的绝妙，没有抢到五月天的票导致在鸟巢外模糊的听了半场，以及去了雍和宫迷信一波保佑自己一切顺顺利利…… </p><p>刚刚结束OS挑战性任务的答辩，在洋洋洒洒写了20页实验报告后，繁忙的大二下终将要告一段落，回首往昔，“成长”与“自我反省”这两词用来描述我这个学期再合适不过，在经历两次面试失败，各种答辩表现都不尽如人意后，痛定思痛反思自己在学业包括社交上的不足，我想很快我会得到答案，也希望我可以带着这份答案走到更远，大三见。</p>]]></content>
      
      
      <categories>
          
          <category> 感想随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学期总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『学期总结』大三上学期总结</title>
      <link href="/post/df81f82.html"/>
      <url>/post/df81f82.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『学期总结』大三上学期总结"><a href="#『学期总结』大三上学期总结" class="headerlink" title="『学期总结』大三上学期总结"></a>『学期总结』大三上学期总结</h1><p>今天是12月24日，第十六周周末，上午刚把数据库的各项报告写完并整理打包，不得不说报告总共写了80多页真的是有够能肝，下午又忙着准备周二的模式识别答辩，以及火烧眉毛的编译上机期末考试，决定此时动笔写学期总结并非我的一厢情愿，而是想到还有一笔没动的算法第四次作业和万恶的英文论文就头疼，到了期末总是会一如既往的泄劲，于是打算先把文字工作都处理妥当。</p><p>已经有多久没回家看看了呢，自从十一回天津后，近两个月再也没有踏上归家的列车，甚至几乎是很少离开过学校方圆一公里，在我的印象里只有数学建模庆功宴吃海底捞时出过一趟远门(指20分钟路程)，说的好像很惨，的确是那么惨，回想上学期疫情解封后，思乡心切的我几乎每周末都要回去睡哥们的大床，可如今安稳入眠已是奢侈，这就是大三上学期，大家开始真正为前程奋斗的第一站。有同学说经常看到我在主楼的沙发上，雷打不动，一呆就是一整天，甚至有的哥们已经摸清了我的行动轨迹，经常和我制造偶遇。诚然，自从老主楼开门后，我就抛弃了新主楼而将老主楼沙发(一楼南侧北侧和二楼北侧，实在没地就去主南302，我们一般称那个教室为碰碰车)作为在北航的第二个家，要问为何不去二楼南侧的沙发，因为那里没有插头，而我的电脑，包括我的人，离开插头40分钟就会鼠掉。我更喜欢空旷的一个人的环境，自习时是这样，任何情况下都是这样，以至于在教室中看到有超过五个人自习就会遗憾离场。</p><p>话说回这学期最重要的两门专业课的两件最重要的大事，编译实验和数据库大作业，它们贯穿了这十六周始终。所幸目前来看结果还不错，编译优化取得了23名的成绩，也希望明天的上机考试可以给编译原理画上一个圆满的句号。数据库大作业更是费心费神，不像是写编译器那般一个人与计算机交互冥思，数据库需要三个人间的默契配合与频繁交流，这会给本就不太擅长交流的我增添了难度，因此我找到了我的两位老队友并一起度过了一段难忘的“与爱同航”开发之旅，大家也都在本次开发中投入了十二分的辛勤与努力，我希望并相信在一月初的答辩中能够收获大家的认可。感谢我的女朋友不离不弃的陪伴，即使我的闲暇时间越来越少；感谢我的数学建模队友jkm，wyx；我的数据库队友，zyj，mtx，和所有在这学期无论是编译期末，编译实验抑或是其他方面互帮互助过的同学们，我想一个i人不社交也会鼠掉。最后的最后感谢我自己——我永远最好的队友，<strong>一往无前虎山行，拨开云雾见光明</strong>，寒假与下学期继续冲刺！</p>]]></content>
      
      
      <categories>
          
          <category> 感想随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学期总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>『学期总结』大二上学期总结</title>
      <link href="/post/a39d5253.html"/>
      <url>/post/a39d5253.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="『学期总结』大二上学期总结"><a href="#『学期总结』大二上学期总结" class="headerlink" title="『学期总结』大二上学期总结"></a>『学期总结』大二上学期总结</h1><p> 不知不觉间，时光匆匆溜走，大二上的学习生活随着疫情时代的告终而迎来了尾声。与计算机学院携手共度的半载，说短不短，说长不长，在这里我见识到了知识储备雄厚为我们提供各种帮助的巨佬学长，痴迷于高老板讲的一堂又一堂生动有趣的计组课程，也亲身经历了经久不衰，“恶贯满盈”的招牌课程计组实验，我发觉了在计院生活和大一入学时的差别，也真切感受到自己在这一年中的微妙变化(如日渐稀疏的头发)。这一学期我用两个词来总结，坎坷，成就。</p><p>首先是坎坷，这一学期受到疫情的影响，从一开学便住进了培训中心五天，再到每天的核酸，后期学校内爆发的大规模疫情，给无论是我，还是师生学校，都造成了极大的影响，在这里也很感谢在疫情爆发初期大家众志成城做出的努力。好在我及时回家，避过了后面的阳性大潮。坎坷不仅于此，在学业上同样称得上是坎坷，从前半个学期每周一次的讲着CPP却用JAVA写的大作业，再到中间一段时间JAVA和计组实验冲突导致强度压力激增，再到P4后计组实验难度的骤升，我一周大概需要投入四天至五天完成实验课代码的编写调试，经常一坐就是一整个下午加晚上，好在我面对de不完的bug时早已养成了平稳的心性（乐，这期间很感谢我的朋友们，我们互相探讨问题，解决问题，在平淡的生活中找到了些许志同道合的归属感。</p><p>其次便是成就，不用多言，写出一段让人心悦神怡的代码自然是喜出望外的，当我迭代写出JAVA第三次作业，看着我整齐划分的类和格式美观的代码时，我感受到这二三十个小时的付出是值得的，计组同样也是如此，当P8实验中LED灯第一次按照要求亮起，串口第一次不被卡崩而是显示出结果，这一切的一切都是激励我不断向前的源动力，我会带着这份对计算机的热爱，对科学的热爱，不断前行。</p>]]></content>
      
      
      <categories>
          
          <category> 感想随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学期总结 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
